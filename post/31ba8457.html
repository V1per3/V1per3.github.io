<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>leetcode刷题笔记 | V1per3</title><meta name="keywords" content="算法"><meta name="author" content="V1per3"><meta name="copyright" content="V1per3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="516.最长回文子序列（dp） 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例1： 123输入：s &#x3D; &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 题解 对于一个子序列而言，如果它是回文子序列，并且长度大于 2">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题笔记">
<meta property="og:url" content="https://v1per3.github.io/post/31ba8457.html">
<meta property="og:site_name" content="V1per3">
<meta property="og:description" content="516.最长回文子序列（dp） 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例1： 123输入：s &#x3D; &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。 题解 对于一个子序列而言，如果它是回文子序列，并且长度大于 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://v1per3.github.io/img/post1.png">
<meta property="article:published_time" content="2023-01-04T10:37:32.652Z">
<meta property="article:modified_time" content="2023-11-04T01:13:00.522Z">
<meta property="article:author" content="V1per3">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://v1per3.github.io/img/post1.png"><link rel="shortcut icon" href="/img/fav.jpg"><link rel="canonical" href="https://v1per3.github.io/post/31ba8457"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode刷题笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-04 09:13:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">V1per3</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode刷题笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-04T10:37:32.652Z" title="发表于 2023-01-04 18:37:32">2023-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-04T01:13:00.522Z" title="更新于 2023-11-04 09:13:00">2023-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<h2 id="516-最长回文子序列（dp）">516.最长回文子序列（dp）</h2>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>
示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong><br>
对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。</p>
<p>用 dp[i][j] 表示字符串 s 的下标范围[i,j] 内的最长回文子序列的长度。假设字符串 s的长度为 n，则只有当0&lt;=i&lt;=j&lt;n时,才会有dp[i][j]&gt;0，否则dp[i][j]=0。</p>
<p>由于任何长度为 1 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0&lt;=i&lt;n，都有dp[i][i]=1。</p>
<p>当 i&lt;j 时，计算 dp[i][j] 需要分别考虑 s[i] 和s[j] 相等和不相等的情况：</p>
<ol>
<li>
<p>如果 s[i] = s[j]，则首先得到 s 的下标范围 [i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和s[j]，即可得到 s 的下标范围[i,j] 内的最长回文子序列，因此dp[i][j]=dp[i+1][j−1]+2；</p>
</li>
<li>
<p>如果s[i] !=s[j]，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此dp[i][j]=max(dp[i+1][j],dp[i][j−1])。</p>
</li>
</ol>
<p>由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。</p>
<p>最终得到 dp[0][n−1] 即为字符串 s 的最长回文子序列的长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">//生成二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> dp[n][n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列（dp）">1143.最长公共子序列（dp）</h2>
<p>给定两个字符串 <code>text1</code> 和<code> text2</code>，返回这两个字符串的最长<strong>公共子序列</strong>的长度。如果不存在<strong>公共子序列</strong>，返回 0 。</p>
<p>一个字符串的<strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<pre><code>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。
</code></pre>
<p>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p>
<p><strong>状态转移方程为</strong>：</p>
<ol>
<li>当text1[i−1]==text2[j−1]: dp[i][j]=dp[i−1][j−1]+1;</li>
<li>当text1[i−1]!=text2[j−1]: dp[i][j]=max(dp[i−1][j],dp[i][j−1]);</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(<span class="type">char</span> * text1, <span class="type">char</span> * text2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(text1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(text2);</span><br><span class="line">    <span class="type">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=fmax(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1312-让字符串成为回文串的最少插入次数（dp）">1312.让字符串成为回文串的最少插入次数（dp）</h2>
<p>是前两个题的变种，有两种解法</p>
<ol>
<li>求字符串与逆序串的最长公共子序列s，然后用n-s即可</li>
<li>该题的状态转移方程如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == s[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i][j] = fmax(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="405-数字转换为十六进制数（位运算）">405. 数字转换为十六进制数（位运算）</h2>
<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p>
<p>注意:</p>
<ol>
<li>十六进制中所有字母(a-f)都必须是小写。</li>
<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。</li>
<li>给定的数确保在32位有符号整数范围内。</li>
<li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li>
</ol>
<p><strong>C语言动态分配</strong></p>
<p>malloc函数。其原型void *malloc(unsigned int num_bytes)；<br>
num_byte为要申请的空间大小，需要我们手动的去计算，如int *p = (int *)malloc(20 * sizeof(int)),如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。</p>
<p>calloc函数，其原型void *calloc(size_t n, size_t size)；<br>
其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p = (int *)calloc(20, sizeof(int)）,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//主要是通过与操作来实现</span><br><span class="line">char * toHex(int num)&#123;</span><br><span class="line">    char c[16]=&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;</span><br><span class="line">    char * ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*9);</span><br><span class="line">    for(int i=7;i&gt;=0;--i)&#123;</span><br><span class="line">        ans[i]=c[num&amp;0xF];//每位16进制</span><br><span class="line">        num=num&gt;&gt;4;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[8]=&#x27;\0&#x27;;</span><br><span class="line">    while(ans[0]==&#x27;0&#x27;&amp;&amp;*(ans+1)!=&#x27;\0&#x27;)&#123;//剔除前缀0</span><br><span class="line">        ans=ans+1;//指针右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿数量-（DFS）">200.岛屿数量 （DFS）</h2>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>题解</strong></p>
<p>一共三种方法，DFS,BFS和并查集，此处只给出DFS的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*dfs:将数组grid中(i,j)元素至0</span><br><span class="line">char ** grid：目标数组</span><br><span class="line">int i：需要至0的位置</span><br><span class="line">int j: 需要至0的位置</span><br><span class="line">int m：数组行数</span><br><span class="line">int n：数组列数</span><br><span class="line">返回值：无</span><br><span class="line">*/</span><br><span class="line">void dfs(char ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i+1, j, m, n);</span><br><span class="line">    dfs(grid, i-1, j, m, n);</span><br><span class="line">    dfs(grid, i, j+1, m, n);</span><br><span class="line">    dfs(grid, i, j-1, m, n);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">*numIslands：计算grid中存在相邻为1的个数</span><br><span class="line">char** grid：数组</span><br><span class="line">int gridSize:数组行数</span><br><span class="line">int* gridColSize:数组列数</span><br><span class="line">返回值：相邻为1的个数</span><br><span class="line">*/</span><br><span class="line">int numIslands(char** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                dfs(grid, i, j, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="695-岛屿的最大面积-（DFS）">695.岛屿的最大面积 （DFS）</h2>
<p>给你一个大小为 m x n 的二进制矩阵 grid 。</p>
<p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 1 的单元格的数目。</p>
<p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>
<p><strong>题解</strong></p>
<p>在200的基础上，在DFS中计算面积即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1+dfs(grid, i+1, j, m, n)+dfs(grid, i-1, j, m, n)+dfs(grid, i, j+1, m, n)+dfs(grid, i, j-1, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int max = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                count = dfs(grid, i, j, m, n);</span><br><span class="line">                max = fmax(max,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-（hash-滑动窗口）">3.无重复字符的最长子串 （hash+滑动窗口）</h2>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p>
<p><strong>滑动窗口解决</strong></p>
<p>需要借助hash结构存储重复元素</p>
<p>此处使用数组模拟hash表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(char * s)&#123;</span><br><span class="line">    int sLen = strlen(s); //获取字符串长度</span><br><span class="line">    int left=0, right = 0; //左右指针</span><br><span class="line">    int res=0, cnt=0; //结果和计数</span><br><span class="line">    int tmp[128] = &#123;0&#125;; //以128位数组记录字串中的字符是否已经出现</span><br><span class="line">    </span><br><span class="line">    while(right &lt; sLen) &#123;           //循环条件为右指针小于字符串长度</span><br><span class="line">        if(tmp[s[right]] == 0) &#123;  //当右指针指向的字符没出现在子串中时</span><br><span class="line">            tmp[ s[right] ]=1;       //使用tmp数组记录右指针指向的字符在ascii码中对应的位置</span><br><span class="line">            right++;                     //右指针右移</span><br><span class="line">            cnt++;                       //计数加1</span><br><span class="line">            res = res &gt; cnt ? res : cnt;   //记录结果</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;                            //当右指针指向的字符出现在子串中时</span><br><span class="line">            tmp[ s[left] ] = 0;     //左指针指向字符的ascii码不再出现在tmp数组中</span><br><span class="line">            left++;                    //左指针右移</span><br><span class="line">            cnt--;                      //计数减1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;          //返回最终无重复字串长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>javascript解法(使用set)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    // 哈希集合，记录每个字符是否出现过</span><br><span class="line">    const occ = new Set();</span><br><span class="line">    const n = s.length;</span><br><span class="line">    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br><span class="line">    let rk = -1, ans = 0;</span><br><span class="line">    for (let i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (i != 0) &#123;</span><br><span class="line">            // 左指针向右移动一格，移除一个字符</span><br><span class="line">            occ.delete(s.charAt(i - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) &#123;</span><br><span class="line">            // 不断地移动右指针</span><br><span class="line">            occ.add(s.charAt(rk + 1));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br><span class="line">        ans = Math.max(ans, rk - i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-最长回文子串-dp">5.最长回文子串 (dp)</h2>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>动态规划</strong></p>
<p>状态转移方程：<br>
P(i,j)=P(i+1,j−1)∧(Si==Sj​)</p>
<p>也就是说，只有s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j]才会是回文串。</p>
<p>动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：</p>
<ol>
<li>P(i,i)=true</li>
<li>P(i,i+1)=(Si==Si+1)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//C</span><br><span class="line">char * longestPalindrome(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n&lt;2)&#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxLen = 1;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    // dp[i][j] 表示 s[i..j] 是否是回文串</span><br><span class="line">    int dp[n][n];</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j=1 ; j &lt; n; j++) &#123;</span><br><span class="line">        // 左下角先填</span><br><span class="line">        for (int i = 0; i &lt; j; i++) &#123;</span><br><span class="line">            if (s[i] != s[j]) &#123;</span><br><span class="line">                dp[i][j] = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (j - i &lt; 3) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                maxLen = j - i + 1;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char *ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*(maxLen+1));</span><br><span class="line">    for(int i=0; i&lt;maxLen; i++)&#123;</span><br><span class="line">        ans[i]=s[begin+i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[maxLen]=&#x27;\0&#x27;;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-回文数">9.回文数</h2>
<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<pre><code>例如，121 是回文，而 123 不是。
</code></pre>
<p>将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>
但是，如果反转后的数字大于int.MAX，我们将遇到整数溢出问题。</p>
<p>为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p><strong>题解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        // 特殊情况：</span><br><span class="line">        // 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br><span class="line">        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br><span class="line">        // 则其第一位数字也应该是 0</span><br><span class="line">        // 只有 0 满足这一属性</span><br><span class="line">        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int revertedNumber = 0;</span><br><span class="line">        while (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * 10 + x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br><span class="line">        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br><span class="line">        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br><span class="line">        return x == revertedNumber || x == revertedNumber / 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="7-整数反转">7.整数反转</h2>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围，就返回 0。<br>
假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)&#123;</span><br><span class="line">     int rev = 0;</span><br><span class="line">        while (x != 0) &#123;</span><br><span class="line">            if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            int digit = x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">            rev = rev * 10 + digit;</span><br><span class="line">        &#125;</span><br><span class="line">    return rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和（快排-双指针）">15.三数之和（快排+双指针）</h2>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p><strong>注意</strong>：答案中不可以包含重复的三元组。</p>
<p><strong>使用快排+双指针</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void *a,const void *b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int*)a - *(int*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if(numsSize &lt; 3)</span><br><span class="line">        return NULL;</span><br><span class="line">    qsort(nums,numsSize,sizeof(int),cmp);</span><br><span class="line">    int **ans = (int **)malloc(sizeof(int *) * numsSize  *numsSize);</span><br><span class="line">    *returnColumnSizes = (int *)malloc(sizeof(int) * numsSize * numsSize);</span><br><span class="line">    int i,j,k,sum;</span><br><span class="line"></span><br><span class="line">    int indexLeft   = 0;</span><br><span class="line">    int indexMiddle = 0;</span><br><span class="line">    int indexRight  = 0;</span><br><span class="line">    //快排过后，使用三指针 遍历</span><br><span class="line">    //左边遍历到倒数第三位即可</span><br><span class="line">    for(indexLeft = 0; indexLeft&lt; numsSize - 2; indexLeft++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[indexLeft] &gt; 0) </span><br><span class="line">        &#123;</span><br><span class="line">            //因为是快排的结果，所以如果出现大零的</span><br><span class="line">            //后面的值都是大于0的</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果值相同 则不需要遍历</span><br><span class="line">        if(indexLeft &gt; 0 &amp;&amp; nums[indexLeft] == nums[indexLeft-1])</span><br><span class="line">            continue;</span><br><span class="line">        indexMiddle = indexLeft + 1;</span><br><span class="line">        indexRight  = numsSize - 1;</span><br><span class="line"></span><br><span class="line">        //双指遍历 找到所有的可能</span><br><span class="line">        while(indexMiddle &lt; indexRight)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = nums[indexLeft] + nums[indexMiddle] + nums[indexRight];</span><br><span class="line"></span><br><span class="line">            if(sum == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[*returnSize] = (int*)malloc(sizeof(int)*3);</span><br><span class="line">                (*returnColumnSizes)[*returnSize] = 3;</span><br><span class="line">                ans[*returnSize][0] = nums[indexLeft];</span><br><span class="line">                ans[*returnSize][1] = nums[indexMiddle];</span><br><span class="line">                ans[*returnSize][2] = nums[indexRight];</span><br><span class="line">                *returnSize += 1;</span><br><span class="line">                //过滤相等的值</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexMiddle] == nums[++indexMiddle]);</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexRight] == nums[--indexRight]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //左边递减</span><br><span class="line">                indexRight--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //右边递增</span><br><span class="line">                indexMiddle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-盛最多水的容器（双指针）">11.盛最多水的容器（双指针）</h2>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p><strong>使用双指针解决</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxArea(int* height, int heightSize)&#123;</span><br><span class="line">    int marea = 0;</span><br><span class="line">    int carea = 0;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = heightSize-1;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        carea = (right-left)*fmin(height[left],height[right]);</span><br><span class="line">        marea = fmax(carea,marea);</span><br><span class="line">        if(height[left]&lt;=height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return marea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号（栈）">20.有效的括号（栈）</h2>
<p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>用栈解决</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool isValid(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n%2!=0) return 0;</span><br><span class="line">    char *stack = (char *)malloc(sizeof(char)*n);</span><br><span class="line">    int top = -1;</span><br><span class="line">    for(int i = 0; i&lt;n ;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;||s[i]==&#x27;&#123;&#x27;||s[i]==&#x27;[&#x27;)&#123;</span><br><span class="line">            stack[++top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;(&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;&#125;&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;&#123;&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;]&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;[&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(top==-1) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第N个结点（快慢指针）">19.删除链表的倒数第N个结点（快慢指针）</h2>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p><strong>官方题解，使用哑结点dummy避免头结点的讨论</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    struct ListNode* dummy = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;//构造虚拟节点，避免头节点的讨论</span><br><span class="line"></span><br><span class="line">    struct ListNode* first = head;</span><br><span class="line">    struct ListNode* second = dummy;//定义快慢指针</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;//快指针先走</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (first) &#123;//慢指针跟上</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;//删除慢指针指向的下一个元素</span><br><span class="line">    struct ListNode* ans = dummy-&gt;next;</span><br><span class="line">    free(dummy);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>自己的想法</strong></p>
<p>利用两个指针，一个在前，一个在后，相差n；让p1先走n步。</p>
<ol>
<li>如果p1为空，说明n正好为链表长度，所以删除倒数第n个就是删除第一个；</li>
<li>如果p1不为空，p2从头开始和p1一起移动，此时二者相差n个，当p1的下一个为空，说明p1正好是最后一个，倒数第n就正好是p2的下一个，所以删除p2的下一个即可；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct ListNode *p1=head,*p2=head;</span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL)&#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p1==NULL) head=head-&gt;next;</span><br><span class="line">    else p2-&gt;next=p2-&gt;next-&gt;next;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="21-合并两个有序链表（迭代）">21.合并两个有序链表（迭代）</h2>
<p>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>迭代</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;</span><br><span class="line">    struct ListNode * preHead = malloc(sizeof(struct ListNode));</span><br><span class="line">    struct ListNode* prev = preHead;</span><br><span class="line">        while (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">            if (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br><span class="line">        prev-&gt;next = list1 == NULL ? list2 : list1;</span><br><span class="line"></span><br><span class="line">        return preHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="22-括号生成（回溯-模板）">22.括号生成（回溯 模板）</h2>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p>
<p>示例 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是不停选括号，要么选左括号，要么选右括号。<br>
并有这些约束的：</p>
<ol>
<li>
<p>只要(有剩，就可以选(。(((((这么选，都还不能判定为非法。</p>
</li>
<li>
<p>当剩下的)比(多时，才可以选)，否则，)不能选，选了就非法。因为：剩下的)比(少，即，使用的)比(多，不能成双成对。</p>
</li>
</ol>
<p>描述节点的状态有：当前构建的字符串，和左右括号所剩的数量。</p>
<p><strong>选择</strong></p>
<p>在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树。<br>
用 DFS 遍历这棵树，找出所有的解，这个过程叫回溯。</p>
<p><strong>约束条件：</strong></p>
<p>即，什么情况下可以选左括号，什么情况下可以选右括号。<br>
利用约束做“剪枝”，即，去掉不会产生解的选项，即，剪去不会通往合法解的分支。<br>
比如()，现在左右括号各剩一个，再选)就成了())，不能让这个错的选择成为选项（不落入递归）：</p>
<p>if (right &gt; left) { // 右括号剩的比较多，才能选右括号<br>
dfs(str + ‘)’, left, right - 1);<br>
}</p>
<p><strong>目标：</strong></p>
<p>构建出一个用尽 n 对括号的合法括号串。<br>
意味着，当构建的长度达到 2 * n，就可以结束递归（不用继续选了）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void generate(int left,int right,int size,char* str,int n, int* returnSize,char** result)</span><br><span class="line">//left代表左括号数量，right代表右括号数量，str代表储存几组有效组合，returnsize表示返回数量</span><br><span class="line">&#123;</span><br><span class="line">	if (left == n &amp;&amp; right == n) </span><br><span class="line">	&#123; // 满足题意的题解</span><br><span class="line">		result[(*returnSize)] = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">		strcpy(result[(*returnSize)++], str);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果左括号数量不大于 n，可以放一个左括号</span><br><span class="line">	if (left &lt; n) </span><br><span class="line">	&#123;</span><br><span class="line">		str[size] = &#x27;(&#x27;;</span><br><span class="line">		generate(left + 1, right, size + 1, str, n,  returnSize, result);</span><br><span class="line">	&#125;</span><br><span class="line">	// 如果右括号数量小于左括号的数量，可以放一个右括号</span><br><span class="line">	if (right &lt; left) </span><br><span class="line">	&#123;</span><br><span class="line">		str[size] = &#x27;)&#x27;;</span><br><span class="line">		generate(left , right+1, size + 1, str, n, returnSize, result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">char ** generateParenthesis(int n, int* returnSize)</span><br><span class="line">&#123;</span><br><span class="line">	char *str = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">	char **result = (char**)malloc(sizeof(char*) * 1430); </span><br><span class="line">// 卡特兰数: 1, 2, 5, 14, 42, 132, 429, 1430，题目中最多生成1430组</span><br><span class="line">	*returnSize = 0;</span><br><span class="line">	generate(0, 0, 0, str, n, returnSize, result);</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//卡特兰数的一个递推函数</span><br><span class="line">int catalan(n) &#123;</span><br><span class="line">  int i, j, h[n + 1];</span><br><span class="line">  h[0] = h[1] = 1;</span><br><span class="line">  for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    h[i] = 0;</span><br><span class="line">    for (j = 0; j &lt; i; j++)</span><br><span class="line">      h[i] = h[i] + h[j] * h[i - j - 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return h[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="28-找出字符串中第一个匹配项的下标（KMP）">28.找出字符串中第一个匹配项的下标（KMP）</h2>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<p><strong>KMP算法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int strStr(char* haystack, char* needle) &#123;</span><br><span class="line">    int n = strlen(haystack), m = strlen(needle);</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int next[m];</span><br><span class="line">    //求next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    for (int i = 1, j = 0; i &lt; m; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //求第一个匹配项下标</span><br><span class="line">    for (int i = 0, j = 0; i &lt; n; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == m) &#123;</span><br><span class="line">            return i - m + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组成（回溯）">17.电话号码的字母组成（回溯）</h2>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string temp;<span class="comment">//存储一个个字符串</span></span><br><span class="line">    vector&lt;string&gt; res;<span class="comment">//结果字符串列表</span></span><br><span class="line">    vector&lt;string&gt; map = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string digits,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//回溯</span></span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(pos == len)&#123;<span class="comment">//如果pos+1后的结果与len相等，说明上轮循环已经把所有长度的字符都压进去了，是一个结果字符串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);<span class="comment">//所以压该字符串进列表</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//该层不进行循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//转换为数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map[num].<span class="built_in">size</span>(); i++)&#123;<span class="comment">//把该数字所对应的所有字母一个个循环遍历</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(map[num][i]);<span class="comment">//压该字符</span></span><br><span class="line">            <span class="built_in">DFS</span>(digits,pos+<span class="number">1</span>);<span class="comment">//进入深层，去压下一位上的字符，直至pos到len</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();<span class="comment">//需要压出最后一个字符，压入一个新轮循环的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">DFS</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置（二分查找）">34.在排序数组中查找元素的第一个和最后一个位置（二分查找）</h2>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int findmid(int *nums, int low , int high , int target)&#123;</span><br><span class="line">    //递归实现二分查找</span><br><span class="line">    //if(low &gt; high) return -1; </span><br><span class="line">    //int mid = (low + high)/2;</span><br><span class="line">    //if(nums[mid]==target) return mid;</span><br><span class="line">    //else if(nums[mid]&gt;target) return findmid(nums,low,mid-1,target);</span><br><span class="line">    //else return findmid(nums,mid+1,high,target);</span><br><span class="line">    //迭代实现</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = (low + high)/2;</span><br><span class="line">        if(nums[mid]==target) return mid;</span><br><span class="line">        else if(nums[mid]&gt;target)high = mid -1;</span><br><span class="line">        else low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int* searchRange(int* nums, int numsSize, int target, int* returnSize)&#123;</span><br><span class="line">    *returnSize=2;</span><br><span class="line">    int *result = (int*)malloc(sizeof(int)*2);</span><br><span class="line">    if(numsSize == 0)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = findmid(nums,0,numsSize-1,target);</span><br><span class="line">    if(ans == -1)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int low=ans,high=ans;</span><br><span class="line">        while((low-1)&gt;=0&amp;&amp;nums[low-1]==target) low--;</span><br><span class="line">        while((high+1)&lt;numsSize&amp;&amp;nums[high+1]==target) high++;</span><br><span class="line">        result[0]=low;result[1]=high;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result[0]=-1;result[1]=-1;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子数组和（dp-贪心）">53.最大子数组和（dp||贪心）</h2>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//dp解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int pre = 0, maxAns = nums[0];</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        pre = fmax(pre + nums[i], nums[i]);</span><br><span class="line">        maxAns = fmax(maxAns, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//贪心解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int result = INT_MIN;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            result = fmax(tmp, result);</span><br><span class="line">            if(tmp &lt; 0) tmp = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-全排列（回溯）">46.全排列（回溯）</h2>
<p>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以按任意顺序返回答案。</p>
<p><strong>回溯</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void swap(int * nums,int indexA,int indexB)</span><br><span class="line">&#123;</span><br><span class="line">    int temp    = nums[indexA];</span><br><span class="line">    nums[indexA]= nums[indexB];</span><br><span class="line">    nums[indexB]= temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void prem(int* nums, int numsSize, int* returnSize, int** returnColumnSizes,int** returnNums,int offset)</span><br><span class="line">&#123;</span><br><span class="line">    if(offset == numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历到末尾了</span><br><span class="line">        //申请returnNums</span><br><span class="line">        returnNums[*returnSize] = (int *)malloc(sizeof(int ) * numsSize);</span><br><span class="line">        //拷贝内容到returnNums</span><br><span class="line">        memcpy(returnNums[*returnSize],nums,sizeof(int) * numsSize );</span><br><span class="line">        //记录当前拷贝内容的长度</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = numsSize;</span><br><span class="line">        *returnSize = *returnSize + 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //回溯算法的核心</span><br><span class="line">        int i;</span><br><span class="line">        for(i = offset; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">            prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,offset+1);</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    //不重复的数字的全排序</span><br><span class="line">    //组合次数为 n！= n *( n - 1) *( n - 2) ...... 2 * 1</span><br><span class="line">    //这样的方法适合回溯的方法</span><br><span class="line">    //取值范围1 &lt;= nums.length &lt;= 6  = 6 * 5 * 4 * 3 *2 * 1 = 720中可能</span><br><span class="line">    int **returnNums = (int **)malloc(sizeof(int *) * 721);</span><br><span class="line">    *returnColumnSizes= (int *)malloc(sizeof(int ) * 721);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,0);</span><br><span class="line">    return returnNums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏（贪心）">55.跳跃游戏（贪心）</h2>
<p>给定一个非负整数数组 nums ，你最初位于数组的<strong>第一个下标</strong>。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p><strong>题解</strong></p>
<p>对于每一个可以到达的位置 i，它使得 i+1, i+2,···,i+nums[i] 这些连续的位置都可以到达。</p>
<p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 i+nums[i] 更新 最远可以到达的位置。</p>
<p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool canJump(int* nums, int numsSize)&#123;</span><br><span class="line">    int mostf = 0;</span><br><span class="line">    for(int i=0;i&lt;numsSize;i++)&#123;</span><br><span class="line">        if(i&lt;=mostf)&#123;</span><br><span class="line">            mostf =fmax(mostf,i+nums[i]);</span><br><span class="line">            if(mostf&gt;=numsSize-1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍（dp）">198.打家劫舍（dp）</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong></p>
<p>对于第 i(i&gt;2) 间房屋，有两个选项：</p>
<p>偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋，偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和。</p>
<p>不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额。</p>
<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 i 间房屋能偷窃到的最高总金额。</p>
<p>用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p>
<pre><code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])
</code></pre>
<p>边界条件为：</p>
<ol>
<li>只有一间房屋，则偷窃该房屋：dp[0]=nums[0]</li>
<li>只有两间房屋，选择其中金额较高的房屋进行偷窃：dp[1]=max(nums[0],nums[1])</li>
</ol>
<p>最终的答案即为 dp[n−1]，其中 n 是数组的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int rob(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    if(numsSize==0) return 0;</span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line">    if(numsSize&gt;=2)&#123;</span><br><span class="line">        dp[1] = fmax(nums[0],nums[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 2 ; i &lt; numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = fmax(dp[i-1],dp[i-2]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[numsSize-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Z字形变化">6.Z字形变化</h2>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。<br>
比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：<br>
P * A * H * N<br>
A P L S I I G<br>
Y * I * R<br>
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“PAHNAPLSIIGYIR”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;              <span class="comment">// 给定行数为 1 时结果与原字符串一样</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(numRows)</span></span>;            <span class="comment">// 创建 res 保存每行结果</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;                              <span class="comment">// 行数标志</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">-1</span>;                          <span class="comment">// 往上走还是往下走的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;ch : s) &#123;                    <span class="comment">// 遍历 s</span></span><br><span class="line">            res[i] += ch;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;   <span class="comment">// 行首行尾变向</span></span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            i += flag;                          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;     <span class="comment">// 将每行接起来就是结果</span></span><br><span class="line">            res[<span class="number">0</span>] += res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机II（dp-贪心）">122.买卖股票的最佳时机II（dp||贪心）</h2>
<p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p>
<p>返回你能获得的最大利润 。</p>
<p><strong>题解</strong></p>
<p><strong>贪心</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        ans += fmax(0, prices[i] - prices[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dp</strong><br>
考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>
<p>定义状态 dp[i][0] 表示第 ii 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p>
<p>考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p>
<p>dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}</p>
<p>再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：</p>
<p>dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}</p>
<p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][1]=−prices[0]。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。</p>
<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1][0] 和 dp[i−1][1] 存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        int newDp0 = fmax(dp0, dp1 + prices[i]);</span><br><span class="line">        int newDp1 = fmax(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = newDp0;</span><br><span class="line">        dp1 = newDp1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列（dp）">300.最长递增子序列（dp）</h2>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p><strong>题解</strong></p>
<p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p>
<p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：</p>
<p>dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p>
<p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p>
<p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    int maxans = 1;</span><br><span class="line">    for(int i = 1; i&lt;numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = fmax(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxans = fmax(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="78-子集（回溯-迭代-递归）">78.子集（回溯 迭代 递归）</h2>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>
<p>记原序列中元素的总数为 n。原序列中的每个数字 a_i 的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n 的 0/1 序列，第 i 位表示a_i是否在子集中。</p>
<p>可以发现 0/1 序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0,2n−1]，mask 的二进制表示是一个 0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。</p>
<p><strong>迭代</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnSize = 1 &lt;&lt; numsSize;</span><br><span class="line">    int t[numsSize];</span><br><span class="line">    for (int mask = 0; mask &lt; (1 &lt;&lt; numsSize); ++mask) &#123;</span><br><span class="line">        int tSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">//&lt;&lt;表示向左移位，1 &lt;&lt; i 表示第i位为1，其他位为0的整型值，Mask &amp; ( 1 &lt;&lt; i )表示检验标志变量Mask的第i位是否为1</span><br><span class="line">                t[tSize++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * tSize);</span><br><span class="line">        memcpy(tmp, t, sizeof(int) * tSize);</span><br><span class="line">        (*returnColumnSizes)[mask] = tSize;</span><br><span class="line">        ans[mask] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 记录答案</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码中，dfs(cur,n) 参数表示当前位置是 cur，原序列总长度为 n。原序列的每个位置在答案序列中的状态有被选中和不被选中两种，我们用 t 数组存放已经被选出的数字。在进入 dfs(cur,n) 之前 [0,cur−1] 位置的状态是确定的，而 [cur,n−1] 内位置的状态是不确定的，dfs(cur,n) 需要确定 cur 位置的状态，然后求解子问题 dfs(cur+1,n)。对于 cur 位置，我们需要考虑 a[cur] 取或者不取，如果取，我们需要把 a[cur] 放入一个临时的答案数组中（即上面代码中的 t），再执行 dfs(cur+1,n)，执行结束后需要对 t 进行回溯；如果不取，则直接执行 dfs(cur+1,n)。在整个递归调用的过程中，cur 是从小到大递增的，当 cur 增加到 n 的时候，记录答案并终止递归。可以看出二进制枚举的时间复杂度是 O(2 ^ n)。</p>
<h2 id="62-不同路径（dp）">62.不同路径（dp）</h2>
<p>一个机器人位于一个 m x n 网格的左上角。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>题解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n)&#123;</span><br><span class="line">    int dp[m][n];</span><br><span class="line">    for(int i = 0 ; i&lt; m ; i++)&#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0 ; i&lt; n ; i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =1 ; i&lt;m ; i++)&#123;</span><br><span class="line">        for(int j = 1 ; j&lt;n ; j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="59-螺旋矩阵-II（模拟）">59. 螺旋矩阵 II（模拟）</h2>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 nxn 正方形矩阵 matrix 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;</span><br><span class="line">    int left = 0, right = n-1, top = 0, bottom = n-1;</span><br><span class="line">    int count = 1, target = n * n;</span><br><span class="line">    int** matrix = malloc(sizeof(int*) * n);</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        matrix[i] = malloc(sizeof(int) * n);</span><br><span class="line">        memset(matrix[i], 0, sizeof(int) * n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    while(count &lt;= target)&#123;</span><br><span class="line">            //从左到右填充，相当于缩小上边界</span><br><span class="line">            for(int j = left; j &lt;= right; j++) matrix[top][j] = count++;</span><br><span class="line">            //缩小上边界</span><br><span class="line">            top++;</span><br><span class="line">            //从上向下填充，相当于缩小右边界</span><br><span class="line">            for(int i = top; i &lt;=bottom; i++) matrix[i][right] = count++;</span><br><span class="line">            //缩小右边界</span><br><span class="line">            right--;</span><br><span class="line">            //从右向左填充，相当于缩小下边界</span><br><span class="line">            for(int j = right; j &gt;= left; j--) matrix[bottom][j] = count++;</span><br><span class="line">            //缩小下边界</span><br><span class="line">            bottom--;</span><br><span class="line">            //从下向上填充，相当于缩小左边界</span><br><span class="line">            for(int i = bottom; i &gt;= top; i--) matrix[i][left] = count++;</span><br><span class="line">            //缩小左边界</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    return matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="92-反转链表-II">92. 反转链表 II</h2>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void reverseLinkedList(struct ListNode *head) &#123;</span><br><span class="line">    // 也可以使用递归反转一个链表</span><br><span class="line">    struct ListNode *pre = NULL;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        struct ListNode *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;</span><br><span class="line">    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span><br><span class="line">    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = -1;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyNode;</span><br><span class="line">    for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *cur = pre-&gt;next;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换（dp）">322. 零钱兑换（dp）</h2>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>题解</strong><br>
我们定义一个dp数组，大小 amount+1 ,dp[i]表示整数金额 i 需要dp[i]个银币<br>
所以dp[i] = dp[i - coins[j]] + 1 -&gt; 表示当前金额 i 需要 i - coins[j]需要的银币加 1<br>
所以遍历整个coins 更新dp[i] 寻找最小的银币数<br>
在dp初始化时，我们将其附最大值，如果 dp[i - coins[j]] == 最大值，表示当前金额 i - coins[j] ，在coins中不存在 也保存最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void * a, const void * b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int *)a - *(int *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define MIN(a , b) ((a) &lt; (b) ? (a) : (b))</span><br><span class="line">int coinChange(int* coins, int coinsSize, int amount)&#123;</span><br><span class="line">    qsort(coins, coinsSize, sizeof(coins[0]), cmp);//升序</span><br><span class="line">    int dp[amount + 1];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 1; i &lt;= amount; i++)//遍历dp数组</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = amount + 1;//初始化最大值</span><br><span class="line">        for(int j = 0; j &lt; coinsSize; j++)//动态更新dp[i]</span><br><span class="line">        &#123;</span><br><span class="line">            if(coins[j] &gt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = MIN(dp[i] , dp[i - coins[j]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] == (amount+1) ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-滑动窗口-hash">76.最小覆盖子串(滑动窗口+hash)</h2>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<ol>
<li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li>
<li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">r</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏II（贪心）">45.跳跃游戏II（贪心）</h2>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<ol>
<li>0 &lt;= j &lt;= nums[i]</li>
<li>i + j &lt; n</li>
</ol>
<p>返回到达 nums[n - 1] 的最小跳跃次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int jump(int* nums, int numsSize)&#123;</span><br><span class="line">    int maxPos = 0, end = 0, step = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize - 1; ++i) &#123;</span><br><span class="line">        if (maxPos &gt;= i) &#123;</span><br><span class="line">            maxPos = fmax(maxPos, i + nums[i]);</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="31-下一个排列">31. 下一个排列</h2>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ol>
<li>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</li>
<li>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</li>
<li>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li>
</ol>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。必须原地修改，只允许使用额外常数空间。</p>
<p><strong>题解</strong><br>
对于长度为 n 的排列 a：</p>
<ol>
<li>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</li>
<li>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</li>
<li>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    int t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line">void reverse(int *nums, int left, int right) &#123;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        swap(nums + left, nums + right);</span><br><span class="line">        left++, right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nextPermutation(int *nums, int numsSize) &#123;</span><br><span class="line">    int i = numsSize - 2;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        int j = numsSize - 1;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums + i, nums + j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + 1, numsSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="61-旋转链表（闭合为环）">61. 旋转链表（闭合为环）</h2>
<p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p><strong>题解</strong><br>
<strong>闭合为环</strong><br>
思路及算法：</p>
<p>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第  (n−1)−(k mod n) 个节点（从 0 开始计数）。</p>
<p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p>
<p>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p>
<p>特别地，当链表长度不大于 1 ，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* rotateRight(struct ListNode* head, int k) &#123;</span><br><span class="line">    if (k == 0 || head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = 1;</span><br><span class="line">    struct ListNode* iter = head;</span><br><span class="line">    while (iter-&gt;next != NULL) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    int add = n - k % n;</span><br><span class="line">    if (add == n) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;next = head;</span><br><span class="line">    while (add--) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* ret = iter-&gt;next;</span><br><span class="line">    iter-&gt;next = NULL;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="77-组合（回溯）">77. 组合（回溯）</h2>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int* temp;</span><br><span class="line">int tempSize;</span><br><span class="line"></span><br><span class="line">int** ans;</span><br><span class="line">int ansSize;</span><br><span class="line"></span><br><span class="line">void dfs(int cur, int n, int k) &#123;</span><br><span class="line">    // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span><br><span class="line">    if (tempSize + (n - cur + 1) &lt; k) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录合法的答案</span><br><span class="line">    if (tempSize == k) &#123;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * k);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 考虑选择当前位置</span><br><span class="line">    temp[tempSize++] = cur;</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">    tempSize--;</span><br><span class="line">    // 考虑不选择当前位置</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** combine(int n, int k, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    temp = malloc(sizeof(int) * k);</span><br><span class="line">    ans = malloc(sizeof(int*) * 10001);</span><br><span class="line">    tempSize = ansSize = 0;</span><br><span class="line">    dfs(1, n, k);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * ansSize);</span><br><span class="line">    for (int i = 0; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="739-每日温度-单调栈">739. 每日温度(单调栈)</h2>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>示例 1:<br>
输入: temperatures = [73,74,75,71,69,72,76,73]<br>
输出: [1,1,4,2,1,1,0,0]</p>
<p><strong>题解</strong><br>
可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
<p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p>
<p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="116-填充每个节点的下一个右侧节点指针（链表）">116. 填充每个节点的下一个右侧节点指针（链表）</h2>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><strong>迭代 使用next指针 两种连接方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从根节点开始</span><br><span class="line">    struct Node* leftmost = root;</span><br><span class="line"></span><br><span class="line">    while (leftmost-&gt;left != NULL) &#123;</span><br><span class="line">        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span><br><span class="line">        struct Node* head = leftmost;</span><br><span class="line"></span><br><span class="line">        while (head != NULL) &#123;</span><br><span class="line">            // CONNECTION 1 连接同一个父节点的两个子节点</span><br><span class="line">            head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line"></span><br><span class="line">            // CONNECTION 2 在不同父亲的子节点之间建立连接</span><br><span class="line">            if (head-&gt;next != NULL) &#123;</span><br><span class="line">                head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 指针向后移动</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 去下一层的最左的节点</span><br><span class="line">        leftmost = leftmost-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归 使用层序遍历和队列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化队列同时将第一层节点加入队列中，即根节点</span><br><span class="line">    struct Node* Q[5000];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    Q[right++] = root;</span><br><span class="line"></span><br><span class="line">    // 外层的 while 循环迭代的是层数</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        // 记录当前队列大小</span><br><span class="line">        int size = right - left;</span><br><span class="line"></span><br><span class="line">        // 遍历这一层的所有节点</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            // 从队首取出元素</span><br><span class="line">            struct Node* node = Q[left++];</span><br><span class="line"></span><br><span class="line">            // 连接</span><br><span class="line">            if (i &lt; size - 1) &#123;</span><br><span class="line">                node-&gt;next = Q[left];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 拓展下一层节点</span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回根节点</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分（dp）">139. 单词拆分（dp）</h2>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const wordBreak = (s, wordDict) =&gt; &#123;</span><br><span class="line">  const wordSet = new Set(wordDict);</span><br><span class="line">  const len = s.length;</span><br><span class="line">  const dp = new Array(len + 1).fill(false);</span><br><span class="line">  dp[0] = true;</span><br><span class="line"></span><br><span class="line">  for (let i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;    // j去划分成两部分</span><br><span class="line">      const suffix = s.slice(j, i);       // 后缀部分 s[j: i-1]</span><br><span class="line">      if (wordSet.has(suffix) &amp;&amp; dp[j]) &#123; // 后缀部分是单词，且左侧子串[0,j-1]的dp[j]为真</span><br><span class="line">        dp[i] = true;</span><br><span class="line">        break;  // dp[i] = true了，i长度的子串已经可以拆成单词了，不需要j继续划分子串了</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="567-字符串的排列（双指针-滑动窗口）">567. 字符串的排列（双指针+滑动窗口）</h2>
<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>
<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>题解</strong><br>
初始时，仅统计 s1 ​中的字符，则 cnt 的值均不为正，且元素值之和为<br>
−n。</p>
<p>然后用两个指针 left 和 right 表示考察的区间 [left,right]。right 每向右移动一次，就统计一次进入区间的字符 x。</p>
<p>为保证 cnt 的值不为正，若此时 cnt[x]&gt;0，则向右移动左指针，减少离开区间的字符的 cnt 值直到 cnt[x]≤0。</p>
<p>注意到 [left,right] 的长度每增加 1，cnt 的元素值之和就增加 1。当<br>
[left,right] 的长度恰好为 n 时，就意味着 cnt 的元素值之和为 0。由于 cnt 的值不为正，元素值之和为 0 就意味着所有元素均为 0，这样我们就找到了一个目标子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool checkInclusion(char* s1, char* s2) &#123;</span><br><span class="line">    int n = strlen(s1), m = strlen(s2);</span><br><span class="line">    if (n &gt; m) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt[26];</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        --cnt[s1[i] - &#x27;a&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">    int left = 0;</span><br><span class="line">    for (int right = 0; right &lt; m; ++right) &#123;</span><br><span class="line">        int x = s2[right] - &#x27;a&#x27;;</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        while (cnt[x] &gt; 0) &#123;</span><br><span class="line">            --cnt[s2[left] - &#x27;a&#x27;];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right - left + 1 == n) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="128-最长连续序列-哈希表-js-set">128. 最长连续序列(哈希表 js:set)</h2>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong><br>
我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 +1 ,+2,⋯x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。</p>
<p>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p>
<p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p>
<p>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var longestConsecutive = function(nums) &#123;</span><br><span class="line">    let num_set = new Set();</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        num_set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    let longestStreak = 0;</span><br><span class="line">    for (const num of num_set) &#123;</span><br><span class="line">        if (!num_set.has(num - 1)) &#123;</span><br><span class="line">            let currentNum = num;</span><br><span class="line">            let currentStreak = 1;</span><br><span class="line"></span><br><span class="line">            while (num_set.has(currentNum + 1)) &#123;</span><br><span class="line">                currentNum += 1;</span><br><span class="line">                currentStreak += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="394-字符串解码">394. 字符串解码</h2>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure>
<p>数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。就是逆波兰式那种题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">const decodeString = (s) =&gt; &#123;</span><br><span class="line">    let numStack = [];        // 存倍数的栈</span><br><span class="line">    let strStack = [];        // 存 待拼接的str 的栈</span><br><span class="line">    let num = 0;              // 倍数的“搬运工”</span><br><span class="line">    let result = &#x27;&#x27;;          // 字符串的“搬运工”</span><br><span class="line">    for (const char of s) &#123;   // 逐字符扫描</span><br><span class="line">        if (!isNaN(char)) &#123;   // 遇到数字</span><br><span class="line">            num = num * 10 + Number(char); // 算出倍数</span><br><span class="line">        &#125; else if (char == &#x27;[&#x27;) &#123;  // 遇到 [</span><br><span class="line">            strStack.push(result); // result串入栈</span><br><span class="line">            result = &#x27;&#x27;;           // 入栈后清零</span><br><span class="line">            numStack.push(num);    // 倍数num进入栈等待</span><br><span class="line">            num = 0;               // 入栈后清零</span><br><span class="line">        &#125; else if (char == &#x27;]&#x27;) &#123;  // 遇到 ]，两个栈的栈顶出栈</span><br><span class="line">            let repeatTimes = numStack.pop(); // 获取拷贝次数</span><br><span class="line">            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串</span><br><span class="line">        &#125; else &#123;                   </span><br><span class="line">            result += char;        // 遇到字母，追加给result串</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="29-两数相除">29. 两数相除</h2>
<p>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p>
<p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p>
<p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−2^31,  2^31 − 1] 。本题中，如果商 严格大于 2^31 − 1 ，则返回 2^31 − 1 ；如果商 严格小于 -2^31 ，则返回 -2^31 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123; // 被除数 除数</span><br><span class="line">        if(divisor == -1 &amp;&amp; dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE; // 溢出</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if((dividend &gt; 0 &amp;&amp; divisor &lt; 0)||(dividend &lt; 0 &amp;&amp; divisor &gt; 0))</span><br><span class="line">            sign = -1;</span><br><span class="line">       // if(divisor == 1) return dividend;</span><br><span class="line">        // if(divisor == -1) return -dividend;</span><br><span class="line">        int a = dividend&gt;0 ? -dividend : dividend;</span><br><span class="line">        int b = divisor&gt;0 ? -divisor : divisor;</span><br><span class="line">        // 都改为负号是因为int 的范围是[2^31, 2^31-1]，如果a是-2^32，转为正数时将会溢出</span><br><span class="line">        //System.out.println(a + &quot; &quot; + b);</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int ans = div(a,b);</span><br><span class="line">        return sign == -1 ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int div(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int tb = b;</span><br><span class="line">        while(tb+tb &gt;= a &amp;&amp; tb+tb &lt; 0)&#123; // 溢出之后不再小于0</span><br><span class="line">            tb += tb;</span><br><span class="line">            count += count;</span><br><span class="line">            //System.out.println(tb + &quot; &quot; + count + &quot; &quot; + count*b);</span><br><span class="line">        &#125;</span><br><span class="line">        return count+div(a-tb,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-12-矩阵中的路径（回溯-visited使用-）">剑指 Offer 12. 矩阵中的路径（回溯[visited使用]）</h2>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>思路与算法</strong></p>
<p>设函数 check(i,j,k) 表示判断以网格的 (i,j) 位置出发，能否搜索到单词 word[k…]，其中 word[k…] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。函数 check(i,j,k) 的执行步骤如下：</p>
<p>如果 board[i][j] =s[k]，当前字符不匹配，直接返回 false。</p>
<p>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。</p>
<p>否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 word[k+1…]，则返回 true，否则返回 false。</p>
<p>这样，我们对每一个位置 (i,j) 都调用函数 check(i,j,0) 进行检查：只要有一处返回 true，就说明网格中能够找到相应的单词，否则说明不能找到。</p>
<p>为了防止重复遍历相同的位置，需要额外维护一个与 board 等大的 visited 数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var exist = function(board, word) &#123;</span><br><span class="line">    const h = board.length, w = board[0].length;</span><br><span class="line">    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];</span><br><span class="line">    const visited = new Array(h);</span><br><span class="line">    for (let i = 0; i &lt; visited.length; ++i) &#123;</span><br><span class="line">        visited[i] = new Array(w).fill(false);</span><br><span class="line">    &#125;</span><br><span class="line">    const check = (i, j, s, k) =&gt; &#123;</span><br><span class="line">        if (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (k == s.length - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        let result = false;</span><br><span class="line">        for (const [dx, dy] of directions) &#123;</span><br><span class="line">            let newi = i + dx, newj = j + dy;</span><br><span class="line">            if (newi &gt;= 0 &amp;&amp; newi &lt; h &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; w) &#123;</span><br><span class="line">                if (!visited[newi][newj]) &#123;</span><br><span class="line">                    const flag = check(newi, newj, s, k + 1);</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        result = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; h; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; w; j++) &#123;</span><br><span class="line">            const flag = check(i, j, word, 0);</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</h2>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void backtrace(char** rec , int * recSize, int* vis, char * s , int i , int n , char* perm)&#123;</span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        char* tmp = malloc(sizeof(char) * (n+1));</span><br><span class="line">        strcpy(tmp,perm);</span><br><span class="line">        rec[(*recSize)++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=0 ; j&lt;n ; j++)&#123;</span><br><span class="line">        if(vis[j] || (j&gt;0&amp;&amp;!vis[j-1]&amp;&amp;s[j-1]==s[j]))&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[j] = true;</span><br><span class="line">        perm[i] = s[j];</span><br><span class="line">        backtrace(rec, recSize, vis, s, i + 1, n, perm);</span><br><span class="line">        vis[j] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(char* a,char *b)&#123;</span><br><span class="line">    return *a-*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char** permutation(char* s, int* returnSize)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    int recMaxSize = 1;</span><br><span class="line">    for(int i =2 ; i&lt;=n ; i++)&#123;</span><br><span class="line">        recMaxSize*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    char **rec = malloc(sizeof(char*)*recMaxSize);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int vis[n];</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    char perm[n+1];</span><br><span class="line">    perm[n] = &#x27;\0&#x27;;</span><br><span class="line">    qsort(s,n,sizeof(char),cmp);</span><br><span class="line">    backtrace(rec, returnSize, vis, s, 0, n, perm);</span><br><span class="line">    return rec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-51-数组中的逆序对-归并排序">剑指 Offer 51. 数组中的逆序对(归并排序)</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong><br>
merge_sort() 归并排序与逆序对统计：</p>
<ol>
<li>
<p>终止条件： 当 l≥r 时，代表子数组长度为 1 ，此时终止划分；</p>
</li>
<li>
<p>递归划分： 计算数组中点 m ，递归划分左子数组 merge_sort(l, m) 和右子数组 merge_sort(m + 1, r);</p>
</li>
<li>
<p>合并与逆序对统计：</p>
<ol>
<li>暂存数组 nums 闭区间 [i,r] 内的元素至辅助数组 tmp ；</li>
<li>循环合并： 设置双指针 i , j 分别指向左 / 右子数组的首元素；
<ol>
<li>当 i=m+1 时： 代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j=j+1 ；</li>
<li>否则，当 j=r+1 时： 代表右子数组已合并完，因此添加左子数组当前元素 tmp[i] ，并执行 i=i+1 ；</li>
<li>否则，当 tmp[i]≤tmp[j] 时： 添加左子数组当前元素 tmp[i] ，并执行 i=i+1；</li>
<li>否则（即 tmp[i]&gt;tmp[j]）时： 添加右子数组当前元素 tmp[j] ，并执行 j=j+1 ；此时构成 m−i+1 个「逆序对」，统计添加至 res ；</li>
</ol>
</li>
</ol>
</li>
<li>
<p>返回值： 返回直至目前的逆序对总数 res ；</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int mergeSort(int l, int r , int* nums, int* tmp)&#123;</span><br><span class="line">     // 终止条件</span><br><span class="line">    if(l&gt;=r) return 0;</span><br><span class="line">     // 递归划分</span><br><span class="line">    int m = (l+r)/2;</span><br><span class="line">    int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp);</span><br><span class="line">     // 合并阶段</span><br><span class="line">    int i = l, j = m + 1;</span><br><span class="line">        for (int k = l; k &lt;= r; k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            if (i == m + 1)</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            else if (j == r + 1 || tmp[i] &lt;= tmp[j])</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            else &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += m - i + 1; // 统计逆序对</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int reversePairs(int* nums, int numsSize)&#123;</span><br><span class="line">    int * tmp = malloc(sizeof(int) * numsSize);</span><br><span class="line">    return mergeSort(0,numsSize-1,nums,tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    struct TreeNode* ancestor = root;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;left;</span><br><span class="line">        &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-II-二叉树的最近公共祖先">剑指 Offer 68 - II. 二叉树的最近公共祖先</h2>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    /* 当前节点为p、q、NULL都返回本身即可 */</span><br><span class="line">    if (root == q || root == p || !root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 递归处理左子树 */</span><br><span class="line">    struct TreeNode* left  = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    /* 递归处理右子树 */</span><br><span class="line">    struct TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    /* 处理当前根节点 */</span><br><span class="line">    /* 当前节点左右子树均不为NULL，则找到公共祖先 */</span><br><span class="line">    if (left != NULL &amp;&amp; right != NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left == NULL &amp;&amp; right != NULL) &#123;    /* 左子树未发现p、q、右子树发现p、q */</span><br><span class="line">        return right;</span><br><span class="line">    &#125; else if (left != NULL &amp;&amp; right == NULL) &#123; /* 右子树未发现p、q、左子树发现p、q */</span><br><span class="line">        return left;</span><br><span class="line">    &#125; else  &#123;   /* 左、右子树均未发现p、q */</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1019-链表中的下一个更大节点-单调栈">1019. 链表中的下一个更大节点(单调栈)</h2>
<p>给定一个长度为 n 的链表 head</p>
<p>对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。</p>
<p>返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextLargerNodes = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        ans.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>][<span class="number">0</span>] &lt; cur.<span class="property">val</span>) &#123;</span><br><span class="line">            ans[stack.<span class="title function_">pop</span>()[<span class="number">1</span>]] = cur.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>([cur.<span class="property">val</span>, idx]);</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1388-3n-块披萨-dp">1388. 3n 块披萨(dp)</h2>
<p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p>
<p>你挑选<strong>任意</strong>一块披萨。<br>
Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。<br>
Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。<br>
重复上述过程直到没有披萨剩下。<br>
每一块披萨的大小按顺时针方向由循环数组 slices 表示。</p>
<p>请你返回你可以获得的披萨大小总和的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong><br>
本题可以转化成如下问题：</p>
<ul>
<li>给一个长度为 3n 的环状序列，你可以在其中选择 n 个数，并且任意两个数不能相邻，求这 n 个数的最大值。</li>
</ul>
<p>用 dp[i][j] 表示在前 i 个数中选择了 j 个不相邻的数的最大和:</p>
<ol>
<li>当 i&lt;2 或 j=0 时:
<ul>
<li>当 j = 0 , dp = 0;</li>
<li>当 i = 0, j = 1, dp = slices[0];</li>
<li>当 i = 1, j = 1, dp = max(slices[0], slices[1]);</li>
<li>当 i &lt; 2, j &gt;= 2, dp = -∞;</li>
</ul>
</li>
<li>当 i≥2 且 j&gt;0 时:
<ul>
<li>dp[i][j]=max(dp[i−2][j−1]+slices[i],dp[i−1][j]);</li>
</ul>
</li>
</ol>
<p>环状序列相较于普通序列，相当于添加了一个限制：普通序列中的第一个和最后一个数不能同时选。这样一来，我们只需要对普通序列进行两遍动态即可得到答案，第一遍动态规划中我们删去普通序列中的第一个数，表示我们不会选第一个数；第二遍动态规划中我们删去普通序列中的最后一个数，表示我们不会选最后一个数。将这两遍动态规划得到的结果去较大值，即为在环状序列上的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = slices.<span class="built_in">size</span>(), n = (N + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MIN));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = slices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(slices[<span class="number">0</span>], slices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">2</span>][j - <span class="number">1</span>] + slices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N - <span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSizeSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(slices.begin() + <span class="number">1</span>, slices.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(slices.begin(), slices.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans1 = <span class="built_in">calculate</span>(v1);</span><br><span class="line">        <span class="type">int</span> ans2 = <span class="built_in">calculate</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2512-奖励最顶尖的-K-名学生-哈希">2512. 奖励最顶尖的 K 名学生(哈希)</h2>
<p>给你两个字符串数组 <code>positive_feedback</code> 和 <code>negative_feedback</code> ，分别包含表示正面的和负面的词汇。<strong>不会</strong>有单词同时是正面的和负面的。</p>
<p>一开始，每位学生分数为 0 。每个正面的单词会给学生的分数<strong>加</strong> 3 分，每个负面的词会给学生的分数<strong>减</strong>  1 分。</p>
<p>给你 n 个学生的评语，用一个下标从 0 开始的字符串数组 <code>report</code> 和一个下标从 0 开始的整数数组 <code>student_id </code>表示，其中 <code>student_id[i]</code> 表示这名学生的 ID ，这名学生的评语是 <code>report[i]</code> 。每名学生的 ID<strong>互不相同</strong>。</p>
<p>给你一个整数 k ，请你返回按照得分<strong>从高到低</strong>最顶尖的 k 名学生。如果有多名学生分数相同，ID 越小排名越前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：</span><br><span class="line">两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topStudents</span><span class="params">(vector&lt;string&gt;&amp; positive_feedback, vector&lt;string&gt;&amp; negative_feedback, vector&lt;string&gt;&amp; report, vector&lt;<span class="type">int</span>&gt;&amp; student_id, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;std::string, <span class="type">int</span>&gt; words;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : positive_feedback) &#123;</span><br><span class="line">            words[word] = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : negative_feedback) &#123;</span><br><span class="line">            words[word] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; report.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            stringstream ss; <span class="comment">//stream根据空格分词</span></span><br><span class="line">            string w;</span><br><span class="line">            <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">            ss &lt;&lt; report[i];</span><br><span class="line">            <span class="keyword">while</span> (ss &gt;&gt; w) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words.<span class="built_in">count</span>(w)) &#123;</span><br><span class="line">                    score += words[w];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            A.<span class="built_in">push_back</span>(&#123;-score, student_id[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; top_k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            top_k.<span class="built_in">push_back</span>(A[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="8026-构造乘积矩阵">8026. 构造乘积矩阵</h2>
<p>给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ：</p>
<p>对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。<br>
返回 grid 的乘积矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2],[3,4]]</span><br><span class="line">输出：[[24,12],[8,6]]</span><br><span class="line">解释：p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24</span><br><span class="line">p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12</span><br><span class="line">p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8</span><br><span class="line">p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6</span><br><span class="line">所以答案是 [[24,12],[8,6]] 。</span><br><span class="line"></span><br><span class="line">1 &lt;= n == grid.length &lt;= 105</span><br><span class="line">1 &lt;= m == grid[i].length &lt;= 105</span><br><span class="line">2 &lt;= n * m &lt;= 105</span><br><span class="line">1 &lt;= grid[i][j] &lt;= 109</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; constructProductMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        const int MOD = 12345;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt;(m));</span><br><span class="line"></span><br><span class="line">        long long suf = 1; // 后缀乘积</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = m - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                p[i][j] = suf; // p[i][j] 先初始化成后缀乘积</span><br><span class="line">                suf = suf * grid[i][j] % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long long pre = 1; // 前缀乘积</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                p[i][j] = p[i][j] * pre % MOD; // 然后再乘上前缀乘积</span><br><span class="line">                pre = pre * grid[i][j] % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2530-执行-K-次操作后的最大分数-优先队列">2530. 执行 K 次操作后的最大分数 (优先队列)</h2>
<p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。</p>
<p>在一步 操作 中：</p>
<p>选出一个满足 0 &lt;= i &lt; nums.length 的下标 i ，<br>
将你的 分数 增加 nums[i] ，并且<br>
将 nums[i] 替换为 ceil(nums[i] / 3) 。<br>
返回在 恰好 执行 k 次操作后，你可能获得的最大分数。</p>
<p>向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,10,10,10,10], k = 5</span><br><span class="line">输出：50</span><br><span class="line">解释：对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxKelements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">0</span>; _ &lt; k; ++_) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans += x;</span><br><span class="line">            q.<span class="built_in">push</span>((x + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; size; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 父节点 (k - 1) / 2，左子节点 k，右子节点 k + 1</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; size &amp;&amp; nums[k] &lt; nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; nums[(k - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, k, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        down(nums, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    nums[size] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt; <span class="number">0</span> &amp;&amp; nums[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; nums[i]; i = (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        swap(nums, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    swap(nums, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">    down(nums, size - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nums[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">maxKelements</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Init(nums, numsSize);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = Pop(nums, numsSize);</span><br><span class="line">        ans += x;</span><br><span class="line">        Push(nums, numsSize - <span class="number">1</span>, (x + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2316-统计无向图中无法互相到达点对数-并查集-or-DFS">2316. 统计无向图中无法互相到达点对数(并查集 or DFS)</h2>
<p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p>
<p>请你返回 无法互相到达 的不同 点对数目 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]</span><br><span class="line">输出：14</span><br><span class="line">解释：总共有 14 个点对互相无法到达：</span><br><span class="line">[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]</span><br><span class="line">所以我们返回 14 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int dfs(int x ,vector&lt;bool&gt;&amp; visited,vector&lt;vector&lt;int&gt;&gt;&amp; graph)&#123;</span><br><span class="line">        visited[x] = true;</span><br><span class="line">        long long count = 1;</span><br><span class="line">        for(int y : graph[x])&#123;</span><br><span class="line">            if (!visited[y]) &#123;</span><br><span class="line">                count += dfs(y,visited,graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(n);</span><br><span class="line">        for (const auto &amp;edge : edges) &#123;</span><br><span class="line">            int  x = edge[0], y = edge[1];</span><br><span class="line">            graph[x].emplace_back(y);</span><br><span class="line">            graph[y].emplace_back(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;bool&gt; visited(n,false);</span><br><span class="line"></span><br><span class="line">        long long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(!visited[i])&#123;</span><br><span class="line">                long long count = dfs(i,visited,graph);</span><br><span class="line">                res += count * (n - count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parents;</span><br><span class="line">    vector&lt;int&gt; sizes;</span><br><span class="line">public:</span><br><span class="line">    UnionFind(int n) : parents(n), sizes(n, 1) &#123;</span><br><span class="line">        iota(parents.begin(), parents.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    int Find(int x) &#123;</span><br><span class="line">        if (parents[x] == x) &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        return parents[x] = Find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    void Union(int x, int y) &#123;</span><br><span class="line">        int rx = Find(x), ry = Find(y);</span><br><span class="line">        if (rx != ry) &#123;</span><br><span class="line">            if (sizes[rx] &gt; sizes[ry]) &#123;</span><br><span class="line">                parents[ry] = rx;</span><br><span class="line">                sizes[rx] += sizes[ry];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parents[rx] = ry;</span><br><span class="line">                sizes[ry] += sizes[rx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int GetSize(int x) &#123;</span><br><span class="line">        return sizes[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        UnionFind uf(n);</span><br><span class="line">        for (const auto &amp;edge : edges) &#123;</span><br><span class="line">            uf.Union(edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res += n - uf.GetSize(uf.Find(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="146-LRU-缓存-哈希表-双向链表">146. LRU 缓存(哈希表+双向链表)</h2>
<p>请你设计并实现一个满足  <strong>LRU (最近最少使用)</strong> 缓存 约束的数据结构。<br>
实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以<strong>正整数</strong>作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以<code>O(1)</code>的平均时间复杂度运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="421-数组中两个数的最大异或值-字典树-前缀树">421. 数组中两个数的最大异或值(字典树/前缀树)</h2>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">struct Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    Trie* left = nullptr;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    Trie* right = nullptr;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie* root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    static constexpr int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void add(int num) &#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int check(int num) &#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://V1per3.github.io">V1per3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://v1per3.github.io/post/31ba8457.html">https://v1per3.github.io/post/31ba8457.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://V1per3.github.io" target="_blank">V1per3</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/post1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/1f3a274b.html"><img class="prev-cover" src="/img/cover11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">webpack入门</div></div></a></div><div class="next-post pull-right"><a href="/post/20bbe8e4.html"><img class="next-cover" src="/img/about.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2022总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/5a05dd41.html" title="百囚徒问题"><img class="cover" src="/img/prisoner.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-06</div><div class="title">百囚徒问题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">V1per3</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/V1per3"><i class="fas fa-user-plus"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/V1per3" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cswuwei777@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1687683994&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">总得有个自己的窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">516.最长回文子序列（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">1143.最长公共子序列（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1312-%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0%EF%BC%88dp%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">1312.让字符串成为回文串的最少插入次数（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">405. 数字转换为十六进制数（位运算）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%EF%BC%88DFS%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">200.岛屿数量 （DFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-%EF%BC%88DFS%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">695.岛屿的最大面积 （DFS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-%EF%BC%88hash-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">3.无重复字符的最长子串 （hash+滑动窗口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-dp"><span class="toc-number">8.</span> <span class="toc-text">5.最长回文子串 (dp)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">9.回文数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-number">10.</span> <span class="toc-text">7.整数反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E5%BF%AB%E6%8E%92-%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">15.三数之和（快排+双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">11.盛最多水的容器（双指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E6%A0%88%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">20.有效的括号（栈）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">19.删除链表的倒数第N个结点（快慢指针）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">21.合并两个有序链表（迭代）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88%E5%9B%9E%E6%BA%AF-%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">22.括号生成（回溯 模板）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%88KMP%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">28.找出字符串中第一个匹配项的下标（KMP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E6%88%90%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">17.电话号码的字母组成（回溯）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">34.在排序数组中查找元素的第一个和最后一个位置（二分查找）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%EF%BC%88dp-%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">53.最大子数组和（dp||贪心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">46.全排列（回溯）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">55.跳跃游戏（贪心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88dp%EF%BC%89"><span class="toc-number">23.</span> <span class="toc-text">198.打家劫舍（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E5%8C%96"><span class="toc-number">24.</span> <span class="toc-text">6.Z字形变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88dp-%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-number">25.</span> <span class="toc-text">122.买卖股票的最佳时机II（dp||贪心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88dp%EF%BC%89"><span class="toc-number">26.</span> <span class="toc-text">300.最长递增子序列（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86%EF%BC%88%E5%9B%9E%E6%BA%AF-%E8%BF%AD%E4%BB%A3-%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">27.</span> <span class="toc-text">78.子集（回溯 迭代 递归）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88dp%EF%BC%89"><span class="toc-number">28.</span> <span class="toc-text">62.不同路径（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89"><span class="toc-number">29.</span> <span class="toc-text">59. 螺旋矩阵 II（模拟）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-number">30.</span> <span class="toc-text">92. 反转链表 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88dp%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">322. 零钱兑换（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-hash"><span class="toc-number">32.</span> <span class="toc-text">76.最小覆盖子串(滑动窗口+hash)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89"><span class="toc-number">33.</span> <span class="toc-text">45.跳跃游戏II（贪心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">34.</span> <span class="toc-text">31. 下一个排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E9%97%AD%E5%90%88%E4%B8%BA%E7%8E%AF%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">61. 旋转链表（闭合为环）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88%EF%BC%88%E5%9B%9E%E6%BA%AF%EF%BC%89"><span class="toc-number">36.</span> <span class="toc-text">77. 组合（回溯）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">37.</span> <span class="toc-text">739. 每日温度(单调栈)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%EF%BC%88%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">116. 填充每个节点的下一个右侧节点指针（链表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%EF%BC%88dp%EF%BC%89"><span class="toc-number">39.</span> <span class="toc-text">139. 单词拆分（dp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E5%8F%8C%E6%8C%87%E9%92%88-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89"><span class="toc-number">40.</span> <span class="toc-text">567. 字符串的排列（双指针+滑动窗口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-%E5%93%88%E5%B8%8C%E8%A1%A8-js-set"><span class="toc-number">41.</span> <span class="toc-text">128. 最长连续序列(哈希表 js:set)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">42.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">43.</span> <span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88%E5%9B%9E%E6%BA%AF-visited%E4%BD%BF%E7%94%A8-%EF%BC%89"><span class="toc-number">44.</span> <span class="toc-text">剑指 Offer 12. 矩阵中的路径（回溯[visited使用]）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">45.</span> <span class="toc-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">46.</span> <span class="toc-text">剑指 Offer 51. 数组中的逆序对(归并排序)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">47.</span> <span class="toc-text">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">48.</span> <span class="toc-text">剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">49.</span> <span class="toc-text">1019. 链表中的下一个更大节点(单调栈)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1388-3n-%E5%9D%97%E6%8A%AB%E8%90%A8-dp"><span class="toc-number">50.</span> <span class="toc-text">1388. 3n 块披萨(dp)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2512-%E5%A5%96%E5%8A%B1%E6%9C%80%E9%A1%B6%E5%B0%96%E7%9A%84-K-%E5%90%8D%E5%AD%A6%E7%94%9F-%E5%93%88%E5%B8%8C"><span class="toc-number">51.</span> <span class="toc-text">2512. 奖励最顶尖的 K 名学生(哈希)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8026-%E6%9E%84%E9%80%A0%E4%B9%98%E7%A7%AF%E7%9F%A9%E9%98%B5"><span class="toc-number">52.</span> <span class="toc-text">8026. 构造乘积矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2530-%E6%89%A7%E8%A1%8C-K-%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">53.</span> <span class="toc-text">2530. 执行 K 次操作后的最大分数 (优先队列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2316-%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E5%88%B0%E8%BE%BE%E7%82%B9%E5%AF%B9%E6%95%B0-%E5%B9%B6%E6%9F%A5%E9%9B%86-or-DFS"><span class="toc-number">54.</span> <span class="toc-text">2316. 统计无向图中无法互相到达点对数(并查集 or DFS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU-%E7%BC%93%E5%AD%98-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">55.</span> <span class="toc-text">146. LRU 缓存(哈希表+双向链表)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#421-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC-%E5%AD%97%E5%85%B8%E6%A0%91-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">56.</span> <span class="toc-text">421. 数组中两个数的最大异或值(字典树&#x2F;前缀树)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/c154d63.html" title="CMU15-445 bustub Project1：Buffer Pool Manager"><img src="/img/CMU15445.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU15-445 bustub Project1：Buffer Pool Manager"/></a><div class="content"><a class="title" href="/post/c154d63.html" title="CMU15-445 bustub Project1：Buffer Pool Manager">CMU15-445 bustub Project1：Buffer Pool Manager</a><time datetime="2023-11-29T07:50:40.148Z" title="发表于 2023-11-29 15:50:40">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/470938e7.html" title="CMU15-445 bustub Project0：Trie 树实现"><img src="/img/CMU15445.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU15-445 bustub Project0：Trie 树实现"/></a><div class="content"><a class="title" href="/post/470938e7.html" title="CMU15-445 bustub Project0：Trie 树实现">CMU15-445 bustub Project0：Trie 树实现</a><time datetime="2023-11-29T07:49:35.301Z" title="发表于 2023-11-29 15:49:35">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/fff3dd6.html" title="分布式系统经典文献索引与语言实践"><img src="/img/yasua.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式系统经典文献索引与语言实践"/></a><div class="content"><a class="title" href="/post/fff3dd6.html" title="分布式系统经典文献索引与语言实践">分布式系统经典文献索引与语言实践</a><time datetime="2023-10-11T01:32:20.281Z" title="发表于 2023-10-11 09:32:20">2023-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/53d98f9e.html" title="2023上半年总结"><img src="/img/backg1.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023上半年总结"/></a><div class="content"><a class="title" href="/post/53d98f9e.html" title="2023上半年总结">2023上半年总结</a><time datetime="2023-06-21T05:12:51.377Z" title="发表于 2023-06-21 13:12:51">2023-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/262580a2.html" title="基于shuffle-attention的语音情感识别研究"><img src="/img/backg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于shuffle-attention的语音情感识别研究"/></a><div class="content"><a class="title" href="/post/262580a2.html" title="基于shuffle-attention的语音情感识别研究">基于shuffle-attention的语音情感识别研究</a><time datetime="2023-06-21T04:44:22.406Z" title="发表于 2023-06-21 12:44:22">2023-06-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/post1.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By V1per3</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>