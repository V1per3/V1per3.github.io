<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>6.5840/6.824 Lab3 Raft | V1per3</title><meta name="keywords" content="6.5840/6.824"><meta name="author" content="V1per3"><meta name="copyright" content="V1per3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab 链接：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;labs&#x2F;lab-raft.html Raft 原论文：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;papers&#x2F;raft-extended.pdf Raft这个lab的难度相比较与前两个提高了很多，由于我之前接触过这个lab，所以上手还是很快的，lab3主要有4个子任务，我也会分任务进行记载。">
<meta property="og:type" content="article">
<meta property="og:title" content="6.5840&#x2F;6.824 Lab3 Raft">
<meta property="og:url" content="https://v1per3.github.io/post/271158e5.html">
<meta property="og:site_name" content="V1per3">
<meta property="og:description" content="Lab 链接：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;labs&#x2F;lab-raft.html Raft 原论文：https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;papers&#x2F;raft-extended.pdf Raft这个lab的难度相比较与前两个提高了很多，由于我之前接触过这个lab，所以上手还是很快的，lab3主要有4个子任务，我也会分任务进行记载。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://v1per3.github.io/img/6824.png">
<meta property="article:published_time" content="2024-03-20T03:42:42.245Z">
<meta property="article:modified_time" content="2024-03-26T07:51:10.282Z">
<meta property="article:author" content="V1per3">
<meta property="article:tag" content="6.5840&#x2F;6.824">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://v1per3.github.io/img/6824.png"><link rel="shortcut icon" href="/img/fav.jpg"><link rel="canonical" href="https://v1per3.github.io/post/271158e5"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6.5840/6.824 Lab3 Raft',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-26 15:51:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6824.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">V1per3</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6.5840/6.824 Lab3 Raft</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-20T03:42:42.245Z" title="发表于 2024-03-20 11:42:42">2024-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-26T07:51:10.282Z" title="更新于 2024-03-26 15:51:10">2024-03-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/6-5840-6-824/">6.5840/6.824</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Lab 链接：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a><br>
Raft 原论文：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></p>
<p>Raft这个lab的难度相比较与前两个提高了很多，由于我之前接触过这个lab，所以上手还是很快的，lab3主要有4个子任务，我也会分任务进行记载。</p>
<p>Raft 是一种分布式一致性协议，旨在解决分布式系统中数据一致性和容错性的问题。为此，Raft 会首先在系统内自动选出一个 Leader 节点，并由这个 Leader 节点负责维护系统内所有节点上的操作日志的一致性。Leader 节点将负责接收用户的请求，将用户请求中携带的操作日志 replicate 到系统内的各个节点上，并告诉系统内各个节点将操作日志中的操作序列应用到各个节点中的状态机上。</p>
<p>更详细的细节会在后续实现当中说明。</p>
<hr>
<h1>3A Leader election</h1>
<p>Lab 3A要求我们实现Leader选取。在Raft中，Server分为三种状态：<code>Leader 、Follower 、 Candidate</code>。初始情况下都为 Follower 。三种状态的转变流程如图所示：<br>
<img src="/img/raft.png" alt="Raft状态转换图"></p>
<p>我们需要做的就是借助rpc通信实现这个过程</p>
<p>对于具体的结构设计，raft论文已经给我们指出了，如下所示：<br>
<img src="/img/raftstrc.png" alt="raftstrc"></p>
<p>阅读论文的第5节，我们可以知道，Leader选取的过程如下：</p>
<ul>
<li>初始情况下，所有节点均为Follower，当心跳检测超时时，Follower会转换为Candidate状态，并开始选举</li>
<li>每一个收到投票请求的Server，判断rpc中参数是否符合上图figure2的要求，如果符合，则投票，否则拒绝投票</li>
<li>如果Server得到了超过半数的投票，则Server成为Leader，并向其他Server发送心跳，保持Leader状态</li>
<li>若超时时间内无新的Leader产生, 再进行下一轮投票, 为了避免出现论文中所说的选举几轮都无Leader产生的情况, 应当给不同Server的投票超时设定随机值</li>
</ul>
<p>当然，在实现过程中还有许多细节，下面在代码逻辑中详细给出</p>
<h2 id="3A-代码逻辑">3A 代码逻辑</h2>
<p>对于Raft结构体、RequestVote以及AppendEntrys的结构，我们参照Figure2实现即可，除此之外对于Raft结构体，我还添加了下列元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   state           int</span><br><span class="line">electionTimeout time.Duration</span><br><span class="line">timeStamp       time.Time</span><br><span class="line">validVoteCount  int</span><br></pre></td></tr></table></figure>
<p><code>state</code>即服务器状态；<code>electionTimeout</code>为选举超时时间，即为每个Server设定一个不同的重新发起选取Leader的超时时间；<code>timeStamp</code>为当前时间，以此与<code>electionTimeout</code>比较来确定是否超时；<code>validVoteCount</code>为当前有效投票数</p>
<hr>
<p>Lab已告诉我们在ticker中检测是否需要发起选举我们利用time.Since()来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) ticker() &#123;</span><br><span class="line">	for rf.killed() == false &#123;</span><br><span class="line"></span><br><span class="line">		// Your code here (3A)</span><br><span class="line">		// Check if a leader election should be started.</span><br><span class="line"></span><br><span class="line">		// pause for a random amount of time between 50 and 350</span><br><span class="line">		// milliseconds.</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		if rf.state != Leader &amp;&amp; time.Since(rf.timeStamp) &gt; rf.electionTimeout &#123;</span><br><span class="line">			go rf.election()</span><br><span class="line">		&#125;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">		ms := 50 + (rand.Int63() % 300)</span><br><span class="line">		time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果超时，就发起一个协程进行选举。在选举函数中，我们需要更新Server的自身状态，并且异步的向其他server发起投票请求，即<code>RequetVote RPC</code>。下面函数中的collectVote是对sendRequetVote的封装，以更简单的实现异步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) election() &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">	rf.state = Candidate</span><br><span class="line">	rf.currentTerm++          // increment current term</span><br><span class="line">	rf.votedFor = rf.me       // vote for self</span><br><span class="line">	rf.validVoteCount = 1     // count the vote for self</span><br><span class="line">	rf.timeStamp = time.Now() // update timeStamp</span><br><span class="line"></span><br><span class="line">	args := &amp;RequestVoteArgs&#123;</span><br><span class="line">		Term:         rf.currentTerm,</span><br><span class="line">		CandidateId:  rf.me,</span><br><span class="line">		LastLogIndex: len(rf.log) - 1,</span><br><span class="line">		LastLogTerm:  rf.log[len(rf.log)-1].Term,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	// send RequestVote RPCs to all other servers concurrently.</span><br><span class="line">	for server, _ := range rf.peers &#123;</span><br><span class="line">		if server != rf.me &#123;</span><br><span class="line">			go rf.collectVote(server, args)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>collectVote</code>发起投票请求，并且处理投票结果。<br>
<code>collectVote</code>调用<code>sendRequestVote</code>发送投票请求</p>
<ul>
<li>如果RPC调用失败, 直接返回</li>
<li>如果server回复了更大的term, 表示当前这一轮的投票已经废弃, 按照回复更新term、自身角色和投票数据，返回false</li>
<li>如果发现当前投票已经结束了(即票数过半), 返回</li>
<li>否则按照投票结果对自身票数自增，自增后如果票数过半, 检查状态后转换自身角色为Leader，并开始发送心跳<br>
<strong>特别注意</strong>，在转化角色前必须先检测自己是否为Follower，因为collectVote也是与RPC心跳的handler并发的, 可能新的Leader已经产生, 并通过心跳改变了自己的role为Follower, 如果不检查的话, 将导致多个Leader的存在</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) collectVote(server int, args *RequestVoteArgs) &#123;</span><br><span class="line">	reply := RequestVoteReply&#123;&#125;</span><br><span class="line">	ok := rf.sendRequestVote(server, args, &amp;reply)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	if args.Term != rf.currentTerm &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.currentTerm = reply.Term</span><br><span class="line">		rf.votedFor = -1</span><br><span class="line">		rf.state = Follower // convert to follower if term is greater than current term.</span><br><span class="line">	&#125;</span><br><span class="line">	if !reply.VoteGranted &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.validVoteCount++</span><br><span class="line">	if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">		if rf.state == Follower &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		rf.state = Leader     // become leader.</span><br><span class="line">		go rf.sendHeartbeat() // start sending heartbeat.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>投票的接收方即RequestVote函数则严格按照Figure 2进行设计:</p>
<ul>
<li>如果args.Term &lt; rf.currentTerm, 直接拒绝投票, 并告知更新的投票</li>
<li>如果args.Term &gt; rf.currentTerm, <strong>更新rf.votedFor = -1, 之前轮次的投票作废</strong>，令 rf.currentTerm = args.Term ，解决孤立节点Term过大的情况</li>
<li>如果满足下面两个情况之一, 投票, 然后更新currentTerm, votedFor,role, timeStamp</li>
<li>
<ul>
<li>args.LastLogTerm &gt; rf.log[len(rf.log)-1].Term</li>
</ul>
</li>
<li>
<ul>
<li>args.LastLogTerm == rf.log[len(rf.log)-1].Term &amp;&amp; args.LastLogIndex &gt;= len(rf.log)-1, 并且未投票或者投票对象是自己</li>
</ul>
</li>
<li>其他情况不投票<br>
除此之外，记得更新时间戳</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// example RequestVote RPC handler.</span><br><span class="line">func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">	// Your code here (3A, 3B).</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	if args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		reply.VoteGranted = false</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		// new term</span><br><span class="line">		rf.votedFor = -1</span><br><span class="line">		rf.currentTerm = args.Term // solve the problem about Orphaned node</span><br><span class="line">		rf.state = Follower</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if rf.votedFor == -1 || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">		if args.LastLogTerm &gt; rf.log[len(rf.log)-1].Term ||</span><br><span class="line">			(args.LastLogTerm == rf.log[len(rf.log)-1].Term &amp;&amp; args.LastLogIndex &gt;= len(rf.log)-1) &#123;</span><br><span class="line">			rf.votedFor = args.CandidateId</span><br><span class="line">			rf.currentTerm = args.Term</span><br><span class="line">			rf.state = Follower</span><br><span class="line">			rf.timeStamp = time.Now()</span><br><span class="line"></span><br><span class="line">			reply.Term = rf.currentTerm</span><br><span class="line">			reply.VoteGranted = true</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reply.Term = rf.currentTerm</span><br><span class="line">	reply.VoteGranted = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>leader产生后就需要立即发送心跳rpc，不断调用sendAppendEntries函数，发送空的Entries<br>
需要注意的是，在处理接受到的返回信息时，如果args.Term != rf.currentTerm，说明函数调用间隙字段被修改了，需要直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) sendHeartbeat() &#123;</span><br><span class="line">	for rf.killed() == false &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		if rf.state != Leader &#123; // stop sending heartbeat if not leader.</span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		for server := range rf.peers &#123;</span><br><span class="line">			args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">				Term:         rf.currentTerm,</span><br><span class="line">				LeaderId:     rf.me,</span><br><span class="line">				PrevLogIndex: 0,</span><br><span class="line">				PrevLogTerm:  0,</span><br><span class="line">				Entries:      nil,</span><br><span class="line">				LeaderCommit: rf.commitIndex,</span><br><span class="line">			&#125;</span><br><span class="line">			if server != rf.me &#123;</span><br><span class="line">				go rf.handleHeartbeat(server, args)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Duration(heartBeatTimeout))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rf *Raft) handleHeartbeat(server int, args *AppendEntriesArgs) &#123;</span><br><span class="line">	reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">	ok := rf.sendAppendEntries(server, args, reply)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	if args.Term != rf.currentTerm &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.currentTerm = reply.Term // update currentTerm.</span><br><span class="line">		rf.votedFor = -1</span><br><span class="line">		rf.state = Follower // become follower.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于AppendEntries函数，同样严格按照Figure 2实现即可</p>
<ul>
<li>如果term &lt; currentTerm表示这是一个旧leader的消息, 告知其更新的term并返回false</li>
<li>如果args.Term &gt; currentTerm, 更新currentTerm, 并转换为follower状态,同时要记得令rf.votedFor = -1，终止其他不应该继续的投票</li>
<li>如果自己的日志中prevLogIndex处不存在有效的日志, 或者与prevLogTerm不匹配, 返回false</li>
<li>如果现存的日志与请求的信息冲突, 删除冲突的日志(这一部分不涉及)</li>
<li>添加日志(这一部分不涉及)</li>
<li>如果leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)<br>
同时, 收到AppendEntries需要更新对应的时间戳timeStamp</li>
</ul>
<hr>
<p><img src="/img/raft3Ares.png" alt=""></p>
<hr>
<h1>3B Log</h1>
<p>3B 主要是实现日志复制以及其引出的选举限制</p>
<p>日志复制核心是通过<code>AppendEntries RPC</code>中的PrevLogIndex、PrevLogTerm来校验Follower的日志是否与Leader一致，如果不一致，则需要通过AppenEntriesRPc来达到一致。前两者的值由nextIndex决定。具体细节边讲代码边讲</p>
<p>心跳Rpc和正常的AppendEntries的区别仅在于是否携带Logs，因此我们在2A的代码的基础上改变心跳Rpc的代码即可</p>
<h2 id="3B代码逻辑">3B代码逻辑</h2>
<p>在<code>sendHeartbeat()</code>函数中，我们需要为每个server单独构建<code>AppendEntriesArgs</code>，有以下要点：</p>
<ul>
<li>PrevLogIndex = rf.nextIndex[i] - 1 即follower最后一个有效日志</li>
<li>PrevLogTerm = rf.log[rf.nextIndex[i]-1].Term 即follower最后一个有效日志的任期<br>
这两者用于Follower判断自己的日志是否合法</li>
<li>如果len(rf.log)-1 &gt;= rf.nextIndex[i]，则表明有新的log需要发送，需要携带Logs，否则就发送一个空log作为心跳rpc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for server := range rf.peers &#123;</span><br><span class="line">			if server == rf.me &#123; // skip self</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">				Term:         rf.currentTerm,</span><br><span class="line">				LeaderId:     rf.me,</span><br><span class="line">				PrevLogIndex: rf.nextIndex[server] - 1,</span><br><span class="line">				PrevLogTerm:  rf.log[rf.nextIndex[server]-1].Term,</span><br><span class="line">				LeaderCommit: rf.commitIndex,</span><br><span class="line">			&#125;</span><br><span class="line">			if len(rf.log)-1 &gt;= rf.nextIndex[server] &#123; // send log entries.</span><br><span class="line">				args.Entries = rf.log[rf.nextIndex[server]:] // send remaining logs.</span><br><span class="line">			&#125; else &#123; // send heartbeat.</span><br><span class="line">				args.Entries = make([]LogEntry, 0) // send empty log entries.</span><br><span class="line">			&#125;</span><br><span class="line">			go rf.handleAppendEntries(server, args)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>在对AppendEntries返回的信息的处理中，<code>handleAppendEntries(server, args)</code>，在success时，我们需要更新rf.nextIndex[server]和rf.matchIndex[server]，判断是否可以commit，更改commitIndex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if reply.Success &#123;</span><br><span class="line">		rf.matchIndex[server] = args.PrevLogIndex + len(args.Entries) // update matchIndex.</span><br><span class="line">		rf.nextIndex[server] = rf.matchIndex[server] + 1              // update nextIndex.</span><br><span class="line"></span><br><span class="line">		for N := len(rf.log) - 1; N &gt; rf.commitIndex; N-- &#123; // update commitIndex</span><br><span class="line">			count := 1</span><br><span class="line">			for peer := range rf.peers &#123;</span><br><span class="line">				if peer != rf.me &amp;&amp; rf.matchIndex[peer] &gt;= N &amp;&amp; rf.log[N].Term == rf.currentTerm &#123; // check if majority of matchIndex is greater than or equal to N.</span><br><span class="line">					count++ // count the number of servers that have log entry at index N.</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if count &gt; len(rf.peers)/2 &#123; // if majority of servers have log entry at index N.</span><br><span class="line">				rf.commitIndex = N // update commitIndex.</span><br><span class="line">				break              // break the loop.</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rf.condApply.Signal()</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>handleAppendEntries(server, args)</code>还有一个要点，在follower的日志和leader的不同时，需要leader调整nextIndex重试，这里使用6.5840有提到的快速回滚的方法，在AppendEntriesReply中添加三个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XTerm: Follower中与Leader冲突的Log对应的Term, 如果Follower在对应位置没有Log将其设置为-1</span><br><span class="line">XIndex: Follower中，对应Term为XTerm的第一条Log条目的索引</span><br><span class="line">XLen: 空白的Log槽位数, 如果Follower在对应位置没有Log，那么XTerm设置为-1,在实际代码中，我们将其设定为Fowller的log长度</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if reply.Term == rf.currentTerm &amp;&amp; rf.state == Leader &#123; // if the follower&#x27;s log is inconsistent with the leader&#x27;s log.</span><br><span class="line">		// quick rollback</span><br><span class="line">		if reply.XTerm == -1 &#123;</span><br><span class="line">			rf.nextIndex[server] = reply.XLen</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		index := rf.nextIndex[server] - 1</span><br><span class="line">		for index &gt; 0 &amp;&amp; rf.log[index].Term &gt; reply.XTerm &#123;</span><br><span class="line">			index--</span><br><span class="line">		&#125;</span><br><span class="line">		if rf.log[index].Term == reply.XTerm &#123;</span><br><span class="line">			rf.nextIndex[server] = index + 1 // update nextIndex.</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			rf.nextIndex[server] = reply.XIndex</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>AppendEntries()</code>中，Follower收到回复后, 按如下规则做出反应:</p>
<ul>
<li>如果XTerm != -1, 表示PrevLogIndex这个位置发生了冲突, Follower检查自身是否有Term为XTerm的日志项</li>
<li>
<ul>
<li>如果有, 则将nextIndex[i]设置为自己Term为XTerm的最后一个日志项的下一位, 这样的情况出现在Follower有着更多旧Term的日志项(Leader也有这样Term的日志项), 这种回退会一次性覆盖掉多余的旧Term的日志项</li>
</ul>
</li>
<li>
<ul>
<li>如果没有, 则将nextIndex[i]设置为XIndex, 这样的情况出现在Follower有着Leader所没有的Term的旧日志项, 这种回退会一次性覆盖掉没有出现在Leader中的Term的日志项</li>
</ul>
</li>
<li>如果XTerm == -1, 表示Follower中的日志不存在PrevLogIndex处的日志项, 这样的情况出现在Follower的log数组长度更短的情况下, 此时将nextIndex[i]减去XLen</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if args.PrevLogIndex &gt;= len(rf.log) &#123;</span><br><span class="line">		// Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span><br><span class="line">		reply.XTerm = -1</span><br><span class="line">		reply.XLen = len(rf.log)</span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		reply.Success = false</span><br><span class="line">		return</span><br><span class="line">	&#125; else if rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">		reply.XTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">		i := args.PrevLogIndex</span><br><span class="line">		for rf.log[i].Term == reply.XTerm &#123;</span><br><span class="line">			i -= 1</span><br><span class="line">		&#125;</span><br><span class="line">		reply.XIndex = i + 1</span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		reply.Success = false</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>之后Follower需要依据PrevLogIndex删除非法的logs，并添加新的log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if len(args.Entries) != 0 &amp;&amp; len(rf.log) &gt; args.PrevLogIndex+1 &#123;</span><br><span class="line">		rf.log = rf.log[:args.PrevLogIndex+1]</span><br><span class="line">	&#125;</span><br><span class="line">	rf.log = append(rf.log, args.Entries...)</span><br></pre></td></tr></table></figure>
<p>最后实现一个将commit应用到状态机的协程,可以使用条件变量或者time.Sleep实现，lab中hints提示了不能不断执行，逻辑还是比较简单的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) applyMsgToStatemachine() &#123;</span><br><span class="line">	for rf.killed() == false &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		for rf.commitIndex &lt;= rf.lastApplied &#123;</span><br><span class="line">			rf.condApply.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		for rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">			rf.lastApplied++</span><br><span class="line">			msg := &amp;ApplyMsg&#123;</span><br><span class="line">				CommandValid: true,</span><br><span class="line">				Command:      rf.log[rf.lastApplied].Command,</span><br><span class="line">				CommandIndex: rf.lastApplied,</span><br><span class="line">			&#125;</span><br><span class="line">			rf.applych &lt;- *msg</span><br><span class="line">		&#125;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">		// time.Sleep(10 * time.Millisecond) // sleep for 10 milliseconds.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>易错点</strong>：每次选出新的leader后需要重新初始化nextIndex[]和matchIndex[]：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">		if rf.state == Follower &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		rf.state = Leader // become leader.</span><br><span class="line">		for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">			rf.nextIndex[i] = len(rf.log)</span><br><span class="line">			rf.matchIndex[i] = 0</span><br><span class="line">		&#125;</span><br><span class="line">		go rf.sendHeartbeat() // start sending heartbeat.</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>在实现了快速回滚的情况下，测试的结果时间还是比较长，潜在的问题可能是在更新commitIndex处使用了一个循环，导致时间复杂度过高，目前还没想到好的优化方案，后面再说<br>
<img src="/img/raft3Bres.png" alt=""></p>
<hr>
<h1>3C Persistence</h1>
<p>3C的任务是实现可持久化，如果基于 Raft 的服务器重新启动，它应该从中断处恢复服务。这要求 Raft 保持在重启后仍然存在的持久状态。</p>
<p>论文中提到需要我们持久化的数据只有三个：<code>votedFor、currentTerm、Log</code>。</p>
<ul>
<li>votedFor:</li>
<li>
<ul>
<li>votedFor记录了一个节点在某个Term内的投票记录, 因此如果不将这个数据持久化, 可能会导致如下情况:</li>
</ul>
</li>
<li>
<ul>
<li>在一个Term内某个节点向某个Candidate投票, 随后故障。故障重启后, 又收到了另一个RequestVote RPC, 由于其没有将votedFor持久化, 因此其不知道自己已经投过票, 结果是再次投票, 这将导致同一个Term可能出现2个Leader</li>
</ul>
</li>
<li>currentTerm:</li>
<li>
<ul>
<li>currentTerm的作用也是实现一个任期内最多只有一个Leader, 因为如果一个几点重启后不知道现在的Term时多少, 其无法再进行投票时将currentTerm递增到正确的值, 也可能导致有多个Leader在同一个Term中出现</li>
</ul>
</li>
<li>Log:</li>
<li>
<ul>
<li>利用Log来恢复自身的状态</li>
</ul>
</li>
</ul>
<p>而其他的数据如commitIndex、lastApplied、nextIndex、matchIndex都可以通过rpc信息重建</p>
<h2 id="3C代码逻辑">3C代码逻辑</h2>
<p>完善代码框架中的<code>persist()</code>和<code>readPersist()</code>，照着注释写即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) persist() &#123;</span><br><span class="line">	w := new(bytes.Buffer)</span><br><span class="line">	e := labgob.NewEncoder(w)</span><br><span class="line">	e.Encode(rf.currentTerm)</span><br><span class="line">	e.Encode(rf.votedFor)</span><br><span class="line">	e.Encode(rf.log)</span><br><span class="line">	raftstate := w.Bytes()</span><br><span class="line">	rf.persister.Save(raftstate, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// restore previously persisted state.</span><br><span class="line">func (rf *Raft) readPersist(data []byte) &#123;</span><br><span class="line">	if data == nil || len(data) &lt; 1 &#123; // bootstrap without any state?</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	r := bytes.NewBuffer(data)</span><br><span class="line">	d := labgob.NewDecoder(r)</span><br><span class="line">	var currentTerm int</span><br><span class="line">	var votedFor int</span><br><span class="line">	var log []LogEntry</span><br><span class="line">	if d.Decode(&amp;currentTerm) != nil || d.Decode(&amp;votedFor) != nil || d.Decode(&amp;log) != nil &#123;</span><br><span class="line">		DPrintf(&quot;readPersist failed\n&quot;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rf.currentTerm = currentTerm</span><br><span class="line">		rf.votedFor = votedFor</span><br><span class="line">		rf.log = log</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其他函数中，只要修改了currentTerm、votedFor、log，我们就进行持久化。在make函数中，由于崩溃恢复时readPersist修改了log，我们需要在执行readPersist后对nextIndex进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func Make ... &#123;</span><br><span class="line">	...</span><br><span class="line">	// initialize from state persisted before a crash</span><br><span class="line">	rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">		rf.nextIndex[i] = len(rf.log)</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试了很多次，结果和lab相差不大，是否就可以不管2B的结果了？<br>
<img src="/img/raft3Cres.png" alt=""></p>
<hr>
<h1>3D Log Compaction</h1>
<p>3D的任务是实现日志压缩，即Snapshot快照的实现。快照是Raft要求上层的应用程序做的, 因为Raft本身并不理解应用程序的状态和各种命令；Raft需要选取一个Log作为快照的分界点, 在这个分界点要求应用程序做快照, 并删除这个分界点之前的Log；在持久化快照的同时也持久化这个分界点之后的Log。</p>
<p>以一个K/V数据库为例, Log就是Put或者Get, 当这个应用运行了相当长的时间后, 其积累的Log将变得很长, 但K/V数据库实际上键值对并不多, 因为Log包含了大量的对同一个键的赋值或取值操作。因此， 应当设计一个阈值，例如1M， 将应用程序的状态做一个快照，然后丢弃这个快照之前的Log。</p>
<h2 id="3D代码设计">3D代码设计</h2>
<p>参考原论文中的figure13，实现snapshot的代码。首先我们需要在Raft结构体中加入下面几个成员，保存snapshot的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Raft struct &#123;</span><br><span class="line">	...</span><br><span class="line">	snapShot          []byte // snapshot of the state machine for fast recovery</span><br><span class="line">	lastIncludedIndex int    // index of the last entry in the snapshot for fast recovery</span><br><span class="line">	lastIncludedTerm  int    // term of the last entry in the snapshot for fast recovery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较关键的一个问题，每次对log进行截断时，commitIndex和nextIndex等索引该如何更新呢？<br>
我们可以称基于现有log日志数组的真实长度的真实索引为realIndex，而整个Raft服务中不断自增的Log索引为全局索引globalIndex，他们和lastIncludedIndex之间有着以下关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">realIndex = globalIndex - rf.lastIncludedIndex</span><br><span class="line">globalIndex = rf.lastIncludedIndex + realIndex</span><br></pre></td></tr></table></figure>
<p>访问rf.log我们使用realIndex，其他情况均使用globalIndex。这样就可以很好的解决对于索引的操作，并且注意，我的代码中索引都是从1开始的，0是占位符</p>
<hr>
<p>Snapshot()函数负责在接受到应用层的快照请求后，进行快照的生成，并更新Raft结构体中的snapshot和lastIncludedIndex等成员。</p>
<p>当index &gt; commitIndex 或者 lastIncludedIndex 时需要拒绝该请求，否则就可以保存snapshot并更改相应状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) Snapshot(index int, snapshot []byte) &#123;</span><br><span class="line">	// Your code here (3D).</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	if rf.commitIndex &lt; index || index &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.snapShot = snapshot</span><br><span class="line">	rf.lastIncludedTerm = rf.log[rf.RealLogIndex(index)].Term</span><br><span class="line">	rf.log = rf.log[rf.RealLogIndex(index):] // log[0] store log[index]</span><br><span class="line">	rf.lastIncludedIndex = index</span><br><span class="line"></span><br><span class="line">	if rf.lastApplied &lt; index &#123;</span><br><span class="line">		rf.lastApplied = index</span><br><span class="line">	&#125;</span><br><span class="line">	rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要更改代码中涉及索引的部分，以及对于3C中的可持久化的部分也需要更改，具体就不赘述了</p>
<p>特别在make初始化时，我们需要读取快照和可持久化，因此我们也需要更改nextIndex，此时就需要注意其索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// initialize from state persisted before a crash</span><br><span class="line">rf.readSnapshot(persister.ReadSnapshot())</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">	rf.nextIndex[i] = rf.GlobalLogIdx(len(rf.log)) // index start by 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>3D部分的重点是InstallSnapshot RPC的实现</p>
<p>假设有一个Follower的日志数组长度很短, 短于Leader做出快照的分界点, 那么这中间缺失的Log将无法通过心跳AppendEntries RPC发给Follower, 因此这个确实的Log将永久无法被补上。因此我们需要实现一个InstallSnapshot RPC，用于在Leader和Follower之间传输快照，以补全缺失的Log。Leader稍后再通过AppendEntries RPC发送快照后的Log。</p>
<p>参考原论文Figure 13的设计：<br>
<img src="/img/InstallSnapshotRpc.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type InstallSnapshotArgs struct &#123;</span><br><span class="line">	Term              int         // leader’s term</span><br><span class="line">	LeaderId          int         // so follower can redirect clients</span><br><span class="line">	LastIncludedIndex int         // snapshot replaces log[index:]</span><br><span class="line">	LastIncludedTerm  int         // term of lastIncludedIndex</span><br><span class="line">	Data              []byte      // raw bytes of the snapshot chunk</span><br><span class="line">	LastIncludedCmd   interface&#123;&#125; // inorder to occupy position at 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type InstallSnapshotReply struct &#123;</span><br><span class="line">	Term int // currentTerm, for leader to update itself</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LastIncludedCmd用于对0索引日志的占位使用，截断后的日志，使用LastIncludedIndex位置的日志项对0号日志进行占位</p>
<ul>
<li>在sendHeartbeat()心跳函数中，如果args.PrevLogIndex &lt; rf.lastIncludedIndex，说明Follower的日志过短，则发送InstallSnapshot RPC</li>
<li>在handleAppendEntries()处理RPC回复的函数中，如果发现已经回退到lastIncludedIndex还不能满足要求, 就需要发送InstallSnapshot RPC</li>
</ul>
<p>发送InstallSnapshot RPC的handleInstallSnapshot函数实现如下：注意发送Rpc时不要持有锁，并且发送成功后需要将nextIndex设置为GlobalLogIdx(1), 因为0索引处是占位, 其余的部分已经不需要再发送了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) handleInstallSnapshot(server int) &#123;</span><br><span class="line">	reply := &amp;InstallSnapshotReply&#123;&#125;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">	if rf.state != Leader &#123;</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">		Term:              rf.currentTerm,</span><br><span class="line">		LeaderId:          rf.me,</span><br><span class="line">		LastIncludedIndex: rf.lastIncludedIndex,</span><br><span class="line">		LastIncludedTerm:  rf.lastIncludedTerm,</span><br><span class="line">		Data:              rf.snapShot,</span><br><span class="line">		LastIncludedCmd:   rf.log[0].Command,</span><br><span class="line">	&#125;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	ok := rf.sendInstallSnapshot(server, args, reply)</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.state = Follower</span><br><span class="line">		rf.currentTerm = reply.Term</span><br><span class="line">		rf.votedFor = -1</span><br><span class="line">		rf.timeStamp = time.Now()</span><br><span class="line">		rf.persist()</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	rf.nextIndex[server] = rf.GlobalLogIdx(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于InstallSnapshot Rpc的响应，特别需要注意的是要检查lastApplied和commitIndex 是否小于LastIncludedIndex, 如果是, 更新为LastIncludedIndex；同时要记得更新定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		rf.timeStamp = time.Now()</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line">	// Reply immediately if term &lt; currentTerm</span><br><span class="line">	if args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">		reply.Term = rf.currentTerm</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">		rf.currentTerm = args.Term</span><br><span class="line">		rf.votedFor = -1</span><br><span class="line">	&#125;</span><br><span class="line">	rf.state = Follower</span><br><span class="line"></span><br><span class="line">	// If existing log entry has same index and term as snapshot’s last included entry, retain log entries following it and reply</span><br><span class="line">	hasEntry := false</span><br><span class="line">	realIdx := 0</span><br><span class="line">	for ; realIdx &lt; len(rf.log); realIdx++ &#123;</span><br><span class="line">		if rf.GlobalLogIdx(realIdx) == args.LastIncludedIndex &amp;&amp; rf.log[realIdx].Term == args.LastIncludedTerm &#123;</span><br><span class="line">			hasEntry = true</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msg := &amp;ApplyMsg&#123;</span><br><span class="line">		SnapshotValid: true,</span><br><span class="line">		Snapshot:      args.Data,</span><br><span class="line">		SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">		SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if hasEntry &#123;</span><br><span class="line">		rf.log = rf.log[realIdx:]</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		rf.log = make([]LogEntry, 0)</span><br><span class="line">		rf.log = append(rf.log, LogEntry&#123;Term: rf.lastIncludedTerm, Command: args.LastIncludedCmd&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Discard the entire log</span><br><span class="line">	// Reset state machine using snapshot contents (and load snapshot’s cluster configuration)</span><br><span class="line">	rf.snapShot = args.Data</span><br><span class="line">	rf.lastIncludedIndex = args.LastIncludedIndex</span><br><span class="line">	rf.lastIncludedTerm = args.LastIncludedTerm</span><br><span class="line"></span><br><span class="line">	if rf.commitIndex &lt; args.LastIncludedIndex &#123;</span><br><span class="line">		rf.commitIndex = args.LastIncludedIndex</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if rf.lastApplied &lt; args.LastIncludedIndex &#123;</span><br><span class="line">		rf.lastApplied = args.LastIncludedIndex</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reply.Term = rf.currentTerm</span><br><span class="line">	rf.applych &lt;- *msg</span><br><span class="line">	rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试时，由于有许多地方需要更改，所以要不断的dubug，最好就是写好日志输出信息慢慢找，详细的就不赘述了。有一点就是在apply msg到状态机时，rf.applyCh &lt;- *msg不能够加锁，否则由于该通道长时间阻塞而产生死锁现象。<br>
还有就是在产生新leader时需要对nextIndex和matchIndex进行如下初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">	rf.nextIndex[i] = rf.VirtualLogIdx(len(rf.log))</span><br><span class="line">	rf.matchIndex[i] = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的测试结果如下，大量测试后显示效果比lab中的还有好一些</p>
<p><img src="/img/raft3Dres.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://V1per3.github.io">V1per3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://v1per3.github.io/post/271158e5.html">https://v1per3.github.io/post/271158e5.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://V1per3.github.io" target="_blank">V1per3</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/6-5840-6-824/">6.5840/6.824</a></div><div class="post_share"><div class="social-share" data-image="/img/6824.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/3b16a234.html"><img class="prev-cover" src="/img/6824.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">6.5840/6.824 Lab4 KVRaft</div></div></a></div><div class="next-post pull-right"><a href="/post/4f335a90.html"><img class="next-cover" src="/img/6824.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">6.5840/6.824 Lab2 Key/Value Server</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/d5c40702.html" title="6.5840&#x2F;6.824 Lab1 MapReduce"><img class="cover" src="/img/6824.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="title">6.5840&#x2F;6.824 Lab1 MapReduce</div></div></a></div><div><a href="/post/3b16a234.html" title="6.5840&#x2F;6.824 Lab4 KVRaft"><img class="cover" src="/img/6824.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">6.5840&#x2F;6.824 Lab4 KVRaft</div></div></a></div><div><a href="/post/4f335a90.html" title="6.5840&#x2F;6.824 Lab2 Key&#x2F;Value Server"><img class="cover" src="/img/6824.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="title">6.5840&#x2F;6.824 Lab2 Key&#x2F;Value Server</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">V1per3</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/V1per3"><i class="fas fa-user-plus"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/V1per3" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cswuwei777@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1687683994&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">总得有个自己的窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">3A Leader election</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3A-%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.</span> <span class="toc-text">3A 代码逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">3B Log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3B%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.</span> <span class="toc-text">3B代码逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">3C Persistence</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3C%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text">3C代码逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">3D Log Compaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3D%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">3D代码设计</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/3b16a234.html" title="6.5840/6.824 Lab4 KVRaft"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab4 KVRaft"/></a><div class="content"><a class="title" href="/post/3b16a234.html" title="6.5840/6.824 Lab4 KVRaft">6.5840/6.824 Lab4 KVRaft</a><time datetime="2024-03-28T04:10:03.791Z" title="发表于 2024-03-28 12:10:03">2024-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/271158e5.html" title="6.5840/6.824 Lab3 Raft"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab3 Raft"/></a><div class="content"><a class="title" href="/post/271158e5.html" title="6.5840/6.824 Lab3 Raft">6.5840/6.824 Lab3 Raft</a><time datetime="2024-03-20T03:42:42.245Z" title="发表于 2024-03-20 11:42:42">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4f335a90.html" title="6.5840/6.824 Lab2 Key/Value Server"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab2 Key/Value Server"/></a><div class="content"><a class="title" href="/post/4f335a90.html" title="6.5840/6.824 Lab2 Key/Value Server">6.5840/6.824 Lab2 Key/Value Server</a><time datetime="2024-03-05T15:00:41.698Z" title="发表于 2024-03-05 23:00:41">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d5c40702.html" title="6.5840/6.824 Lab1 MapReduce"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab1 MapReduce"/></a><div class="content"><a class="title" href="/post/d5c40702.html" title="6.5840/6.824 Lab1 MapReduce">6.5840/6.824 Lab1 MapReduce</a><time datetime="2024-03-03T10:44:52.625Z" title="发表于 2024-03-03 18:44:52">2024-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6b93e080.html" title="CMU15-445 bustub Project4：Concurrency Control"><img src="/img/CMU15445.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU15-445 bustub Project4：Concurrency Control"/></a><div class="content"><a class="title" href="/post/6b93e080.html" title="CMU15-445 bustub Project4：Concurrency Control">CMU15-445 bustub Project4：Concurrency Control</a><time datetime="2024-01-26T06:37:05.249Z" title="发表于 2024-01-26 14:37:05">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/6824.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By V1per3</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>