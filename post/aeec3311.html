<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构 线性表 | V1per3</title><meta name="keywords" content="数据结构"><meta name="author" content="V1per3"><meta name="copyright" content="V1per3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线性表的定义与基本操作线性表的定义 线性表是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表。 若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,…,ai,ai+1,…an) 表达式中a1是唯一第一个数据元素，又称为表头元素；an是唯一的最后一个数据元素，又称为表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构 线性表">
<meta property="og:url" content="http://example.com/post/aeec3311.html">
<meta property="og:site_name" content="V1per3">
<meta property="og:description" content="线性表的定义与基本操作线性表的定义 线性表是具有相同数据类型的n(n&gt;&#x3D;0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线性表是一个空表。 若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,…,ai,ai+1,…an) 表达式中a1是唯一第一个数据元素，又称为表头元素；an是唯一的最后一个数据元素，又称为表尾元素。 除第一个元素外，每个元素有且仅有一个直接前驱">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/sujgxxb1.png">
<meta property="article:published_time" content="2022-07-09T08:51:11.738Z">
<meta property="article:modified_time" content="2022-07-10T04:23:15.254Z">
<meta property="article:author" content="V1per3">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/sujgxxb1.png"><link rel="shortcut icon" href="/img/fav.jpg"><link rel="canonical" href="http://example.com/post/aeec3311"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构 线性表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-10 12:23:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/sujgxxb1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">V1per3</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构 线性表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-09T08:51:11.738Z" title="发表于 2022-07-09 16:51:11">2022-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-10T04:23:15.254Z" title="更新于 2022-07-10 12:23:15">2022-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="线性表的定义与基本操作"><a href="#线性表的定义与基本操作" class="headerlink" title="线性表的定义与基本操作"></a>线性表的定义与基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><ol>
<li>线性表是具有<strong>相同</strong>数据类型的n(n&gt;&#x3D;0)个数据元素的<strong>有限序列</strong>，其中n为表长，当n&#x3D;0时线性表是一个空表。</li>
<li>若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,…,ai,ai+1,…an)</li>
<li>表达式中a1是唯一<strong>第一个</strong>数据元素，又称为表头元素；an是唯一的<strong>最后一个</strong>数据元素，又称为表尾元素。</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后驱。<br><strong>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆</strong></li>
</ol>
<h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L): 初始化表。构造一个空的线性表。</span><br><span class="line">Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定元素e。</span><br><span class="line">ListDelete(&amp;L,i,&amp;e): 删除操作。删除表中L中第i个位置的元素，并用e返回删除的元素。</span><br><span class="line">PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</span><br><span class="line">DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure>
<p><strong>注意：基本操作的具体实现取决于采用哪种存储结构（见下图）,存储结构不同，算法的实现也不同.”&amp;”表示C++语言中的引用调用,在c语言中采用指针也可以达到相同的效果.后续文章中两种方式都会使用.</strong></p>
<p><img src="/img/sujgxxb1.png"></p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p>
<p>假定线性表的元素类型为ElemType,则线性表的顺序存储类型描述为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 10  //定义顺序表的最大长度，在声明数组时使用</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];//顺序表的数据元素</span><br><span class="line">    int length;//顺序表的当前长度</span><br><span class="line">&#125;Sqlist;//顺序表的类型定义</span><br></pre></td></tr></table></figure>
<p>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定好，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序奔溃甚至引起其他未知异常。</p>
<p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦存储空间占满，就另外开辟一块更大的存储区间，将原来的元素复制过去，从而达到扩充存储数组空间的目的，而不需要一次性分配很大的空间。<br>C语言的初始动态分配语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>
<p>C++语言的初始化动态分配语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data=new ElemType[InitSize];</span><br></pre></td></tr></table></figure>
<p><strong>注意：动态存储并不是链式存储，它同样属于顺序存储，物理结构没有变化，还是和逻辑结构一样保持相邻，只是分配的空间不再是编译器决定，而是运行时分配。</strong></p>
<h3 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h3><p>随机访问：可通过首地址和元素序号在单位时间O(1)内找到指定的元素。</p>
<p>存储密度高：存储密度高是因为每个结点存储空间指用来存储数据元素，没有别的额外开销。</p>
<p>物理位置相邻：物理位置和逻辑位置一样，保持相邻，因此插入和删除元素需要移动大量元素，比较耗时。这是物理结构相邻的所有数据结构的通病，虽然访问快，但是如果有频繁的增删移动操作，就会效率很低。</p>
<h3 id="顺序表上的基本操作"><a href="#顺序表上的基本操作" class="headerlink" title="顺序表上的基本操作"></a>顺序表上的基本操作</h3><p>仅展示查、增、删三种操作，其余的在线性表中较为简单，在后续更复杂的链表中展示。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>在顺序表L的第i（1&lt;&#x3D;i&lt;&#x3D;L.length+1）位插入新元素e。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length + 1)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    if (L.length &gt;= MaxSize)   //判断是否超出存储空间</span><br><span class="line">        return false;</span><br><span class="line">    for (int j = L.length; j &gt;= i; j--)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j - 1];</span><br><span class="line">    L.data[i - 1] = e;   //在第i位插入元素e</span><br><span class="line">    L.length++;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况：在表尾插入（即i&#x3D;n+1）,原本的元素不移动，时间复杂度为O(1)。</p>
<p>最坏情况：在表头插入（即i&#x3D;1），所有元素需要后移一位，元素后移语句执行n次，时间复杂度为O(n)。</p>
<p>平均情况：假设Pi(Pi&#x3D;1&#x2F;(n+1))是在第i个位置上插入一个结点的概率，则在长度为n的顺序表中插入一个结点时，所需要移动结点的平均次数为n&#x2F;2，时间复杂度为O(n)。</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除顺序表L中第i（1&lt;&#x3D;i&lt;&#x3D;L.length）个位置的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    e = L.data[i - 1];     //保存要删除的数据到e</span><br><span class="line">    for (int j = i-1; j &lt;= L.length; ++j)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j + 1];</span><br><span class="line">    L.length--;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度与插入一样（平均时间复杂度上，插入始终每一步比删除多一次操作，即插入操作，但是不会引起量级变化，所以平均时间复杂度依旧为O(N)）</p>
<h4 id="按值查找（顺序查找）操作"><a href="#按值查找（顺序查找）操作" class="headerlink" title="按值查找（顺序查找）操作"></a>按值查找（顺序查找）操作</h4><p>在顺序表中查找第一个元素值等于e的元素的位置，未查找到返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L,const ElemType &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; L.length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if (L.data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况：在表头找到（即i&#x3D;1）,时间复杂度为O(1)。</p>
<p>最坏情况：在表尾插入（即i&#x3D;n），时间复杂度为O(n)。</p>
<p>平均情况：时间复杂度为O(n)。</p>
<h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p>逻辑上相邻的元素在物理位置上不一定相邻。<br>优点：</p>
<ol>
<li>没有了顺序存储所具有的弱点（也就是说：插入和删除不需要移动元素，而只需要修改指针。）</li>
<li>同时，由于不借助数组实现，在定义链表时，无需指定它的长度。</li>
</ol>
<p>缺点：<br>也失去了顺序存储的优点</p>
<ol>
<li>非随机存取（不能直接找到某个特定序号的结点，需要从表头开始遍历）</li>
<li>存储密度降低（除了存储本身信息外链表还要存储指针）</li>
</ol>
<h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><p>线性表的链式存储又称为单链表，它是指通过一组任意的存储单位来存储线性表中的元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素的自身信息外，还需要存放一个指向其后继的指针。</p>
<p>由于逻辑上相邻的元素在物理位置上不一定相邻，那么我们如何确定下一个元素的存储位置呢？<br><strong>解决办法，增加一个变量。用来存储一个指示其后继位置的指针。</strong><br>我们把这两部分的信息组成数据元素a的存储映像，称为<strong>结点</strong>。它包含两个域，其中存储数据元素信息的域称为<strong>数据域</strong>，存储直接后继存储位置的域称为<strong>指针域</strong>。</p>
<p>单链表中结点定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123; //定义单链表节点类型</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct LNode *next;//指针域</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>
<p><strong>头指针</strong><br>整个链表的存储<strong>必须从头指针开始</strong><br>头指针指示链表中第一个结点的存储位置<br>同时，由于最后一个数据元素没有直接后继，则单链表中最后一个一个结点的指针为NULL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//头指针定义1</span><br><span class="line">LinkList L;</span><br><span class="line">//头指针定义2</span><br><span class="line">LNode *L;</span><br></pre></td></tr></table></figure>
<p><strong>头结点</strong><br>在单链表的第一个结点之前附设一个结点，称为头结点。<br>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度之类的附加信息。<br>头结点的指向第一个结点的指针（即第一个元素结点的存储位置）<br>此时，单链表的头指针指向头结点。<br><img src="/img/sujgxxb2.png"></p>
<p><strong>空表</strong><br>含头结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L-&gt;next==NULL时为空表</span><br></pre></td></tr></table></figure>
<p>不含头结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L==NULL时为空表；</span><br></pre></td></tr></table></figure>
<h3 id="单链表上具体操作的实现和时间复杂度"><a href="#单链表上具体操作的实现和时间复杂度" class="headerlink" title="单链表上具体操作的实现和时间复杂度"></a>单链表上具体操作的实现和时间复杂度</h3><h4 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h4><p>构造一个空表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int InitList_Link(LinkList *L)&#123;</span><br><span class="line">    *L=(LinkList)malloc(sizeof(LNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(1)</span><br></pre></td></tr></table></figure>
<h4 id="根据数组创建单链表"><a href="#根据数组创建单链表" class="headerlink" title="根据数组创建单链表"></a>根据数组创建单链表</h4><h5 id="含头结点的单链表"><a href="#含头结点的单链表" class="headerlink" title="含头结点的单链表"></a>含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点指向第一个结点</span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        r=s;//r移动到链表尾端</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="不含头结点的单链表"><a href="#不含头结点的单链表" class="headerlink" title="不含头结点的单链表"></a>不含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line">    *L=NULL;</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            *L=s;//头指针指向插入结点</span><br><span class="line">            s-&gt;next=NULL;//倒序插入，最后一个结点的指针域赋值为NULL</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            s-&gt;next=*(L);//新插入的结点指向第一个结点</span><br><span class="line">            *(L)=s;//头指针指向新的插入节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    (*L)=NULL;</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            (*L)=s;//头指针指向第一个结点</span><br><span class="line">            r=s;//尾指针移动到最后一个结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">            r=s;//r移动到链表尾端</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>含头结点优点：</p>
<ol>
<li>使得链表第一个结点的操作和其他位置一样，无需特殊处理。</li>
</ol>
<p>含头结点缺点：</p>
<ol>
<li>头结点的数据域一般不存储数据，该空间被浪费。</li>
</ol>
<p>时间复杂度：</p>
<ol>
<li>每个结点插入的时间为O(1),设表长为n，所有方式的时间复杂度均为O(n)</li>
</ol>
<h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Length_Link(LinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        L=L-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：设表长为n,时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><p>在表L中的第i个位置上插入指定元素e。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert_Link(LinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete_Link(LinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h4 id="按位查找操作"><a href="#按位查找操作" class="headerlink" title="按位查找操作"></a>按位查找操作</h4><p>获取表L中第i个位置的元素的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int GetElem_List(LinkList L,int i,ElemType *e)&#123;</span><br><span class="line">    LNode *p=L; //p指向头结点</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (p&amp;&amp;j&lt;i)&#123;//找到第i个位置</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(p)||i&lt;1)  return FALSE; //i不在有效范围内</span><br><span class="line">    *e=p-&gt;data; //把第i个结点的值用e返回</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h4 id="按值查找操作"><a href="#按值查找操作" class="headerlink" title="按值查找操作"></a>按值查找操作</h4><p>在表L中查找具有给定关键字值的元素,返回序号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_List(LinkList L,ElemType e,int *i)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历链表</span><br><span class="line">        L=L-&gt;next;//向后移动</span><br><span class="line">        j++;//序号加一</span><br><span class="line">        if (L-&gt;data.id==e.id)&#123;//这里我们只用id来判断元素的值是否相等，假设id唯一</span><br><span class="line">            *i=j;//如果相等，用i返回序号</span><br><span class="line">            return TRUE;//查找成功</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h4 id="销毁表"><a href="#销毁表" class="headerlink" title="销毁表"></a>销毁表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(LinkList *L)&#123;</span><br><span class="line">    while((*L)-&gt;next!=NULL) &#123;//遍历链表</span><br><span class="line">    	LNode *p=(*L)-&gt;next;//p指示头结点的下一个，要被删除的结点</span><br><span class="line">    	(*L)-&gt;next=p-&gt;next;//让头结点指向p的下一个，把p从链表断开</span><br><span class="line">    	free(p);//删除p</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表结点中只有一个指向其后继结点的指针，使得单链表只能从头结点依次顺序地向后遍历。<br>要访问某个结点的前驱结点，只能从头开始遍历。<br>也就是说：访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)</p>
<p><strong>为了克服单链表的上述缺点，引入了双链表。</strong><br><strong>双链表中有两个指针prior和next，分别指向其前驱结点和后继结点</strong></p>
<h4 id="双链表的定义"><a href="#双链表的定义" class="headerlink" title="双链表的定义"></a>双链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DNode&#123;</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct DNode *prior;//前驱指针</span><br><span class="line">    struct DNode *next;//后继指针</span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure>
<p><img src="/img/sujgxxb3.png"></p>
<h4 id="双链表上具体操作的实现和时间复杂度"><a href="#双链表上具体操作的实现和时间复杂度" class="headerlink" title="双链表上具体操作的实现和时间复杂度"></a>双链表上具体操作的实现和时间复杂度</h4><p>使用含头结点的双链表</p>
<h5 id="初始化表-1"><a href="#初始化表-1" class="headerlink" title="初始化表"></a>初始化表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitList_DLink(DLinkList *L)&#123;</span><br><span class="line">    *L=(DLinkList)malloc(sizeof(DNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;prior=NULL;//头结点的prior永远指向NULL</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(1)</span><br></pre></td></tr></table></figure>
<h5 id="根据数组创建双链表"><a href="#根据数组创建双链表" class="headerlink" title="根据数组创建双链表"></a>根据数组创建双链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*头插法创建双链表*/</span><br><span class="line">int create_HeadInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于D头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点的后继指向第一个结点</span><br><span class="line">        if((*L)-&gt;next!=NULL) (*L)-&gt;next-&gt;prior=s;//第一个结点的前驱指向该结点</span><br><span class="line">        s-&gt;prior=(*L);//让该结点的前驱指向头结点   </span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该D结点（该结点成为第一个结点）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*尾插法创建双链表*/</span><br><span class="line">int create_TailInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        s-&gt;prior=r;//该结点的前驱指向r指向的结点</span><br><span class="line">        r=s;//r移动到链表尾端o</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每个结点插入的时间为O(1),设表长为n,所有方式的时间复杂度均为O(n)</span><br></pre></td></tr></table></figure>
<h5 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h5><p>在表L中的第i个位置上插入指定元素e。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_DLink(DLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    if (p-&gt;next!=NULL) p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前D驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<h5 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">int ListDelete_DLink(DLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    if(q-&gt;next!=NULL)q-&gt;next-&gt;prior=p;</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure>
<p>其他操作与单链表一样，不展示</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>特点：表中最后一个结点的指针域指向头结点，整个链表形成一个环。<br>既然是环的话，那就不难想象，从表中任意一个结点出发都可以找到表中其他结点。</p>
<h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表与单链表唯一的区别就是多了一个由尾结点指向头结点的指针。<br>所以循环链表的操作与单链表基本一致<br>唯一的差别就是<strong>循环的条件不是p或p-&gt;next是否为空，而是它们是否等于头指针</strong><br>($p&#x3D;&#x3D;L或p-&gt;next&#x3D;&#x3D;L$)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int Length_CLink(CLinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    CNode *s=L;</span><br><span class="line">    while (s-&gt;next!=L)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        s=s-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>循环双链表与循环单链表唯一的区别就是多了一个指向前驱的指针。<br>所以循环双链表的操作与循环单链表也基本一致<br>就是<strong>对结点操作时，需要多操作一步，让p-&gt;prior指向前驱结点。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_CDLink(CDLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(p==(*L)||(i-j)&gt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(CDLinkList)malloc(sizeof(CDNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*删除*/</span><br><span class="line">int ListDelete_CDLink(CDLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((p-&gt;next)==(*L)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    q-&gt;next-&gt;prior=p;//让删除结点的下一个结点的前驱指向p；</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>众所周知，指针是c语言的灵魂，指针使得链表的实现简单明了起来。但是问题来了，在c语言还没有的时代，又想描述链表，怎么办呢？<br>这就有了静态链表</p>
<h4 id="静态链表的设计"><a href="#静态链表的设计" class="headerlink" title="静态链表的设计"></a>静态链表的设计</h4><p>首先，我们来解决一个最重要的问题，没有指针，怎么表示下一个元素的位置呢？</p>
<p>当时的人们想出来的办法便是，用数组的下标来代替指针。我们把这个数组的下标叫做游标。</p>
<p>第二个问题，当我们要往数组里插入元素时，如何确定数组里哪些分量未被使用，要插到哪个位置上呢？当我们删除一个元素的时候，要把这个删除后已经不存放数据的数组分量链接到哪里去，然后再次被使用呢？</p>
<p>解决办法是将所有未被使用过的以及被删除的分量用一个游标链成一个备用链表。<br>每当进行插入的使用便从备用链表上取得第一个结点作为待插入的新结点。<br>反之，在删除时将从链表中删除下来结点链接到备用链表上。</p>
<p>有没有觉得上面的描述特别熟悉，这实际上就是C语言里面malloc函数和free函数做的事情，在静态链表中，我们得自己实现，不过操作起来也不复杂。</p>
<p>最后一个问题，我们现在已经知道了我们把静态链表分为两部分，一部分存放数据，一部分不存放数据，我们称之为备用链表。那么我们如何标识这两部分呢？</p>
<p>解决办法，我们这里把数组下标为0位置的游标用来存放备用链表的第一个元素（也就是数组中第一个不存放数据的元素）的下标<br>我们这里把数组下标为1的位置游标用来存放第一个数据不为空的元素的下标<br>这里还有个细节就是我们把游标为0设为这两部分的结束。</p>
<h4 id="静态链表的定义"><a href="#静态链表的定义" class="headerlink" title="静态链表的定义"></a>静态链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ElemType char//这里我们使用的例子，采取字符</span><br><span class="line">#define MaxSize 10  //链表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;//存储的数据元素</span><br><span class="line">    int next;//游标，用来指示下一个数组分量的下标</span><br><span class="line">&#125;SLinkList[MaxSize];//静态链表</span><br></pre></td></tr></table></figure>
<h4 id="静态链表的操作"><a href="#静态链表的操作" class="headerlink" title="静态链表的操作"></a>静态链表的操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitSpace_SL(SLinkList space)&#123; </span><br><span class="line">  int i;</span><br><span class="line">  for (i = 2; i &lt; MaxSize-1; i++)&#123;</span><br><span class="line">      space[i].data=&#x27; &#x27;;</span><br><span class="line">      space[i].next=i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  space[0].next=2;</span><br><span class="line">  space[0].data=&#x27; &#x27;;</span><br><span class="line">  space[1].next=0;</span><br><span class="line">  space[1].data=&#x27; &#x27;;</span><br><span class="line">  space[MaxSize-1].next=0;</span><br><span class="line">  space[MaxSize-1].data=&#x27; &#x27;;</span><br><span class="line">  return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="求表长-1"><a href="#求表长-1" class="headerlink" title="求表长"></a>求表长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int ListLength(SLinkList space)&#123;</span><br><span class="line">    int length=0;//空表长度为0</span><br><span class="line">    int i=space[1].next;//指向第一个有数据的位置</span><br><span class="line">    while (i!=0)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        i=space[i].next;//相当于指针的p=p-&gt;next</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的操作便是遍历表：<br>这里的i&#x3D;space[i].next;相当于指针的p&#x3D;p-&gt;next</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>尽管我们现在有了单链表，也不再会使用静态链表了，但是它的思想还是挺神奇的。<br>总的来说，它和单链表很像，插入删除不需要移动元素，所有我们称之为静态链表。<br>但是它不仅有单链表不能随机存取的缺点，也没有解决连续分配（数组）带来的表长难以确定的问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">V1per3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/aeec3311.html">http://example.com/post/aeec3311.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">V1per3</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/sujgxxb1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/9a9a747.html"><img class="prev-cover" src="/img/extrabbs.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">extra-bbs开发项目</div></div></a></div><div class="next-post pull-right"><a href="/post/146816a0.html"><img class="next-cover" src="/img/sujgxl.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构 绪论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/146816a0.html" title="数据结构 绪论"><img class="cover" src="/img/sujgxl.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-09</div><div class="title">数据结构 绪论</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">V1per3</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/V1per3"><i class="fas fa-user-plus"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/V1per3" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cswuwei777@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">better than better</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">线性表的定义与基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">线性表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">线性表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">顺序表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">顺序表上的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.1.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">按值查找（顺序查找）操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">单链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8A%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">单链表上具体操作的实现和时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">初始化表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">根据数组创建单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">含头结点的单链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%AB%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">不含头结点的单链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E8%A1%A8%E9%95%BF"><span class="toc-number">3.2.3.</span> <span class="toc-text">求表长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.2.5.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.6.</span> <span class="toc-text">按位查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.7.</span> <span class="toc-text">按值查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E8%A1%A8"><span class="toc-number">3.2.8.</span> <span class="toc-text">销毁表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">双链表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E4%B8%8A%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.2.</span> <span class="toc-text">双链表上具体操作的实现和时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8-1"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">初始化表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">根据数组创建双链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-2"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-2"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">删除操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">循环单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">循环双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.5.1.</span> <span class="toc-text">静态链表的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.2.</span> <span class="toc-text">静态链表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.3.</span> <span class="toc-text">静态链表的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E8%A1%A8%E9%95%BF-1"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">求表长</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/9a9a747.html" title="extra-bbs开发项目"><img src="/img/extrabbs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="extra-bbs开发项目"/></a><div class="content"><a class="title" href="/post/9a9a747.html" title="extra-bbs开发项目">extra-bbs开发项目</a><time datetime="2022-07-14T04:47:30.956Z" title="发表于 2022-07-14 12:47:30">2022-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/aeec3311.html" title="数据结构 线性表"><img src="/img/sujgxxb1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构 线性表"/></a><div class="content"><a class="title" href="/post/aeec3311.html" title="数据结构 线性表">数据结构 线性表</a><time datetime="2022-07-09T08:51:11.738Z" title="发表于 2022-07-09 16:51:11">2022-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/146816a0.html" title="数据结构 绪论"><img src="/img/sujgxl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构 绪论"/></a><div class="content"><a class="title" href="/post/146816a0.html" title="数据结构 绪论">数据结构 绪论</a><time datetime="2022-07-09T08:23:52.322Z" title="发表于 2022-07-09 16:23:52">2022-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/5a05dd41.html" title="百囚徒问题"><img src="/img/prisoner.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="百囚徒问题"/></a><div class="content"><a class="title" href="/post/5a05dd41.html" title="百囚徒问题">百囚徒问题</a><time datetime="2022-07-06T01:47:57.616Z" title="发表于 2022-07-06 09:47:57">2022-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3acd2553.html" title="vuex基础知识"><img src="/img/categories.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vuex基础知识"/></a><div class="content"><a class="title" href="/post/3acd2553.html" title="vuex基础知识">vuex基础知识</a><time datetime="2022-07-05T07:21:30.721Z" title="发表于 2022-07-05 15:21:30">2022-07-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/sujgxxb1.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By V1per3</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>