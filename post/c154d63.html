<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CMU15-445 bustub Project1：Buffer Pool Manager | V1per3</title><meta name="keywords" content="CMU15-445"><meta name="author" content="V1per3"><meta name="copyright" content="V1per3"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Project1 算是进入正式的项目了，做下来感觉整体难度还是挺高的(本人在实现的过程中还没有考虑细粒锁还是花费了大量的时间，有时间还可以优化一下)，因为此博客一般就只作为我自己的笔记，再加上2022fall早已结束，所以过程中就贴上源代码。 关于本门课程，由于本人英语听力水平实在有限，所以看的是B站一个中科院老师对于该课程的解读: https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;B">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15-445 bustub Project1：Buffer Pool Manager">
<meta property="og:url" content="https://v1per3.github.io/post/c154d63.html">
<meta property="og:site_name" content="V1per3">
<meta property="og:description" content="Project1 算是进入正式的项目了，做下来感觉整体难度还是挺高的(本人在实现的过程中还没有考虑细粒锁还是花费了大量的时间，有时间还可以优化一下)，因为此博客一般就只作为我自己的笔记，再加上2022fall早已结束，所以过程中就贴上源代码。 关于本门课程，由于本人英语听力水平实在有限，所以看的是B站一个中科院老师对于该课程的解读: https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;B">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://v1per3.github.io/img/CMU15445.png">
<meta property="article:published_time" content="2023-11-29T07:50:40.148Z">
<meta property="article:modified_time" content="2023-12-02T07:02:16.572Z">
<meta property="article:author" content="V1per3">
<meta property="article:tag" content="CMU15-445">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://v1per3.github.io/img/CMU15445.png"><link rel="shortcut icon" href="/img/fav.jpg"><link rel="canonical" href="https://v1per3.github.io/post/c154d63"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMU15-445 bustub Project1：Buffer Pool Manager',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-02 15:02:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/CMU15445.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">V1per3</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CMU15-445 bustub Project1：Buffer Pool Manager</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-29T07:50:40.148Z" title="发表于 2023-11-29 15:50:40">2023-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-02T07:02:16.572Z" title="更新于 2023-12-02 15:02:16">2023-12-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CMU15-445/">CMU15-445</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Project1 算是进入正式的项目了，做下来感觉整体难度还是挺高的(本人在实现的过程中还没有考虑细粒锁还是花费了大量的时间，有时间还可以优化一下)，因为此博客一般就只作为我自己的笔记，再加上2022fall早已结束，所以过程中就贴上源代码。</p>
<p>关于本门课程，由于本人英语听力水平实在有限，所以看的是B站一个中科院老师对于该课程的解读: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1bQ4y1Y7iT">https://www.bilibili.com/video/BV1bQ4y1Y7iT</a></p>
<p>好，接下来进入<strong>正题</strong>：</p>
<p>project1 一共有三个任务：</p>
<ul>
<li><strong>可扩展哈希表（Extendible Hash Table）</strong></li>
<li><strong>LRU-K 置换策略（LRU-K Replacement Policy）</strong></li>
<li><strong>缓冲池管理（Buffer Pool Manager）</strong></li>
</ul>
<p>其中缓冲池的实现会用到前两个</p>
<h2 id="可扩展哈希表（Extendible-Hash-Table）">可扩展哈希表（Extendible Hash Table）</h2>
<p>首先是我们为什么要引入可扩展哈希表？传统的静态哈希表在储存空间不足时进行扩展会非常麻烦，同时发生碰撞后的处理往往也会导致查找时间的增长。对于动态哈希表例如拉链法实现的哈希表，当某个哈希值对应的元素特别多时，查找的时间复杂度由O(1)退化为遍历的O(n)。<br>
举个极端的例子，如果哈希函数是不管输入是什么都映射为 0，那么就和在第 0 位存储一个链表无异。如何设计散布更加均匀的哈希函数是优化的另一个方向，一种方法是当检测到某个桶中的元素过多时对表进行扩展。扩展最简单的做法是直接将哈希表的长度（桶数）翻倍，再将哈希函数的值域由 [0,n) 改为 [0,2n)，然后对所有存储的元素重新算一次哈希值分布到不同的桶中。</p>
<p>这种方法的缺点很明显：如果哈希表中已经存储了大量的元素，因为要对所有元素重算哈希值，扩展的过程会有巨大的计算量，导致一次突发的大延迟。实际上，进行扩展时，可能仅仅是某一个桶出现了拉链很长的状况，其它桶的余量还很充足。于是，出现了可扩展哈希表（Extendible Hash Table）的方案，其将哈希得到的下标与桶改为非一对一映射，并引入全局深度（Global Depth）和局部深度（Local Depth）的概念，实现扩展时只需对达到容量的那一个桶进行分裂，解决了以上问题。</p>
<p>可扩展哈希表的具体原理就不在此赘述了，可以参考下之前B站链接老师的讲解或者下面这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MelroseLbt/article/details/129329316">https://blog.csdn.net/MelroseLbt/article/details/129329316</a> (这篇博客里有一定的地方没讲清楚，有迷糊可以看一下15445的作业，做一下就懂了)</p>
<h3 id="Bucket类">Bucket类</h3>
<p>首先我们要实现ExtendibleHashTable 类的内联类 Bucket 类的结构，Bucket就是可扩展哈希表中的桶，Bucket 使用 std::list 存储元素键值对，我们主要实现三个函数 Find，Remove 和 Insert：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Bucket &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Bucket(size_t size, int depth = 0);</span><br><span class="line"></span><br><span class="line">  /** @brief Check if a bucket is full. */</span><br><span class="line">  inline auto IsFull() const -&gt; bool &#123; return list_.size() == size_; &#125;</span><br><span class="line"></span><br><span class="line">  /** @brief Get the local depth of the bucket. */</span><br><span class="line">  inline auto GetDepth() const -&gt; int &#123; return depth_; &#125;</span><br><span class="line"></span><br><span class="line">  /** @brief Increment the local depth of a bucket. */</span><br><span class="line">  inline void IncrementDepth() &#123; depth_++; &#125;</span><br><span class="line"></span><br><span class="line">  inline auto GetItems() -&gt; std::list&lt;std::pair&lt;K, V&gt;&gt; &amp; &#123; return list_; &#125;</span><br><span class="line"></span><br><span class="line">  /* @brief Find the value associated with the given key in the bucket.</span><br><span class="line">   */</span><br><span class="line">  auto Find(const K &amp;key, V &amp;value) -&gt; bool;</span><br><span class="line"></span><br><span class="line">  /* @brief Given the key, remove the corresponding key-value pair in the bucket.</span><br><span class="line">   */</span><br><span class="line">  auto Remove(const K &amp;key) -&gt; bool;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * @brief Insert the given key-value pair into the bucket.</span><br><span class="line">   *      1. If a key already exists, the value should be updated.</span><br><span class="line">   *      2. If the bucket is full, do nothing and return false.</span><br><span class="line">   */</span><br><span class="line">  auto Insert(const K &amp;key, const V &amp;value) -&gt; bool;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  size_t size_;</span><br><span class="line">  int depth_;  // local_depth</span><br><span class="line">  std::list&lt;std::pair&lt;K, V&gt;&gt; list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>没有什么难点，照着注释敲就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Find(const K &amp;key, V &amp;value) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      value = it-&gt;second;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Remove(const K &amp;key) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      list_.erase(it);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Insert(const K &amp;key, const V &amp;value) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      it-&gt;second = value;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!IsFull()) &#123;</span><br><span class="line">    list_.emplace_back(key, value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ExtendibleHashTable类">ExtendibleHashTable类</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int global_depth_;    // The global depth of the directory</span><br><span class="line">size_t bucket_size_;  // The size of a bucket</span><br><span class="line">int num_buckets_;     // The number of buckets in the hash table</span><br><span class="line">mutable std::mutex latch_;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  // The directory of the hash table</span><br></pre></td></tr></table></figure>
<p>以上是ExtendibleHashTable类的成员变量，注意dir_是桶的指针数组，因为可扩展哈希表中会有多个指针指向同一个桶，所以用 shared_ptr</p>
<p>获取键对应的哈希值下标函数，源代码已经给出了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::IndexOf(const K &amp;key) -&gt; size_t &#123;</span><br><span class="line">  int mask = (1 &lt;&lt; global_depth_) - 1;  </span><br><span class="line">  // eg: gd = 2 , 1 &lt;&lt; 2 = 100 , 100 -1 = 011 , this is we want</span><br><span class="line">  return std::hash&lt;K&gt;()(key) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们自己先实现一个创建桶的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::NewBucket(int local_depth) -&gt; std::shared_ptr&lt;Bucket&gt; &#123;</span><br><span class="line">  return std::make_shared&lt;Bucket&gt;(bucket_size_, local_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类中，我们也主要实现Find，Remove 和 Insert这三个函数</p>
<p>对于Find函数，利用哈希函数得到键所对应的下标值找到对应的桶然后让桶查找即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Find(const K &amp;key, V &amp;value) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line">  return dir_[index]-&gt;Find(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Remove 时不用考虑空桶的合并收缩，因此也是找到桶然后让桶 Remove 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Remove(const K &amp;key) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line">  return dir_[index]-&gt;Remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是Insert函数，Insert函数的逻辑如下：</p>
<ul>
<li>首先判断表中是否已经有了该键，有则更新其值</li>
<li>如果没有，则要判断该键所对应的桶是否满了，如果没满直接插入即可，否则：</li>
<li>
<ul>
<li>先判断local_depth是否等于global_depth_，如果相等则需要将目录dir_扩容成原来的两倍，并且将后半部分扩容部分的指针依次指向前半部分所指的shared_ptr</li>
</ul>
</li>
<li>
<ul>
<li>创建两个新桶，将旧桶里的元素分发到这两个新桶中</li>
</ul>
</li>
<li>
<ul>
<li>调整dir_中的指针指向这两个新桶</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">void ExtendibleHashTable&lt;K, V&gt;::Insert(const K &amp;key, const V &amp;value) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line"></span><br><span class="line">  // If a key already exists, the value should be updated.</span><br><span class="line">  V val;  // no use,just for calling Bucket::Find()</span><br><span class="line">  if (dir_[index]-&gt;Find(key, val)) &#123;</span><br><span class="line">    dir_[index]-&gt;Insert(key, value);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If the bucket is full</span><br><span class="line">  while (dir_[index]-&gt;IsFull()) &#123;</span><br><span class="line">    int local_depth = dir_[index]-&gt;GetDepth();</span><br><span class="line">    // local_depth == global_depth_ , double dir size</span><br><span class="line">    if (local_depth == global_depth_) &#123;</span><br><span class="line">      size_t dir_size = dir_.size();</span><br><span class="line">      dir_.reserve(2 * dir_size);</span><br><span class="line">      std::copy_n(dir_.begin(), dir_size,</span><br><span class="line">                  std::back_inserter(dir_));  // Copy the shared_ptr directly from the first half to the second half</span><br><span class="line">      ++global_depth_;  // that&#x27;s why we need to updata index = IndexOf(key) in the end of the while loop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // make two new buckets</span><br><span class="line">    auto b0 = NewBucket(local_depth + 1);</span><br><span class="line">    auto b1 = NewBucket(local_depth + 1);</span><br><span class="line">    ++num_buckets_;  // only add 1 , because the old Bucket will be replaced by the new Bucket</span><br><span class="line">    int local_mask = 1 &lt;&lt; local_depth;</span><br><span class="line">    /*Since the elements belong to the same bucket, the original index (k) must be</span><br><span class="line">    the same. Therefore, we only need to compare the &#x27;local_depth&#x27; at that position</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // redistribute items from old bucket</span><br><span class="line">    for (auto &amp;[k, v] : dir_[index]-&gt;GetItems()) &#123;</span><br><span class="line">      size_t item_hash = std::hash&lt;K&gt;()(k);  // ExtendibleHashTable::indexOf() use std::hash&lt;K&gt;()</span><br><span class="line">      if (static_cast&lt;bool&gt;(item_hash &amp; local_mask)) &#123;</span><br><span class="line">        b1-&gt;Insert(k, v);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        b0-&gt;Insert(k, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // adjust dir_ points to the old bucket</span><br><span class="line">    for (size_t i = (std::hash&lt;K&gt;()(key) &amp; (local_mask - 1)); i &lt; dir_.size(); i += local_mask) &#123;</span><br><span class="line">      if (static_cast&lt;bool&gt;(i &amp; local_mask)) &#123;</span><br><span class="line">        dir_[i] = b1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dir_[i] = b0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // updata index of the incoming item after split</span><br><span class="line">    index = IndexOf(key);</span><br><span class="line">  &#125;</span><br><span class="line">  dir_[index]-&gt;Insert(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-2">测试</h3>
<p>之前贴的博客，博主写了几个测试样例，可以加进去测一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make extendible_hash_table_test -j2</span><br><span class="line">./test/extendible_hash_table_test</span><br></pre></td></tr></table></figure>
<h2 id="LRU-K-置换策略（LRU-K-Replacement-Policy）">LRU-K 置换策略（LRU-K Replacement Policy）</h2>
<p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。可以在做该项目之前先完成力扣的146. LRU 缓存，该题中采用双向链表和哈希表来完成该机制。</p>
<p>但是传统的LRU算法存在一定的缺陷：缓存污染问题。例如 Cache 容量是 3，存有较常访问的 [A，B，C]，此时有一个访问序列 D，E，F 到来，就会把 ABC 全踢掉，即使 DEF 以后可能再也不会出现。</p>
<p>为了解决这个缺陷，LRU-K算法应运而生。LRU-K算法在LRU算法的基础上，增加了缓存项在缓存中存在的时间，即K值，在该实验中我们用缓存页的访问次数代替存在时间，即hit_count。我们使用两个队列来实现LRU-K算法，一个队列history_list_储存hit_count &lt; k 的页面，另一个队列cache_list_储存hit_count &gt;= k 的页面。在遇到需要淘汰页面时，首先利用FIFO策略淘汰history_list_队首的页面，如果history_list_队列没有可淘汰的页面，则利用LRU策略淘汰cache_list_中的页面。为了达到O(1)的时间效率，我们需要用unordered_map来存储页和他在队列中的迭代器的映射关系。同时，在淘汰页面的过程中我们要注意evictable_，是否可淘汰的问题。</p>
<p>综上，我们构造LRUKReplacer的类成员如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// add this struct to record the status of the frame</span><br><span class="line">  struct FrameEntry &#123;</span><br><span class="line">    size_t hit_count_&#123;0&#125;;</span><br><span class="line">    bool evictable_&#123;false&#125;;</span><br><span class="line">    std::list&lt;frame_id_t&gt;::iterator pos_;</span><br><span class="line">  &#125;;</span><br><span class="line">std::list&lt;frame_id_t&gt; history_list_;  // hit_count_ &lt; k , replace use FIFO</span><br><span class="line">  std::list&lt;frame_id_t&gt; cache_list_;    // hit_count_ &gt;= k , only when historyList is empty replace use LRU</span><br><span class="line">  std::unordered_map&lt;frame_id_t, FrameEntry&gt; entries_;</span><br><span class="line"></span><br><span class="line">  size_t curr_size_&#123;0&#125;;   // cache size</span><br><span class="line">  size_t replacer_size_;  // frame_id need to be smaller than replacer_size_</span><br><span class="line">  size_t k_;</span><br><span class="line">  std::mutex latch_;</span><br></pre></td></tr></table></figure>
<p>注意在这里，evictable_初始化为false，笔者则是这里初始化为true，在task3 buffer pool出现了bug，并且不易于理清逻辑。</p>
<p>curr_size_实际上是指可以被替换的页的数量</p>
<h3 id="LRUKReplacer-实现">LRUKReplacer 实现</h3>
<p>该类中我们主要需要实现四个成员函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// @brief Find the frame with largest backward k-distance and evict that frame. Only frames </span><br><span class="line">// that are marked as &#x27;evictable_&#x27; are candidates for eviction.</span><br><span class="line">auto Evict(frame_id_t *frame_id) -&gt; bool;</span><br><span class="line"></span><br><span class="line">// @brief Record the event that the given frame id is accessed at current timestamp.</span><br><span class="line">// Create a new entry for access history if frame id has not been seen before.</span><br><span class="line">void RecordAccess(frame_id_t frame_id);</span><br><span class="line"></span><br><span class="line">// @brief Toggle whether a frame is evictable_ or non-evictable_. This function also</span><br><span class="line">// controls replacer&#x27;s size. Note that size is equal to number of evictable_ entries.</span><br><span class="line">void SetEvictable(frame_id_t frame_id, bool set_evictable_);</span><br><span class="line"></span><br><span class="line">// @brief Remove an evictable_ frame from replacer, along with its access history.</span><br><span class="line">// This function should also decrement replacer&#x27;s size if removal is successful.</span><br><span class="line">void Remove(frame_id_t frame_id);</span><br></pre></td></tr></table></figure>
<p><strong>Evict()</strong><br>
比较简单</p>
<ul>
<li>首先判断curr_size_是否为0，如果为0，则直接返回false，否则：</li>
<li>
<ul>
<li>从队尾开始遍历history_list_，没找到就从队尾开始遍历cache_list_<br>
两个队列中第一个可驱逐的就是满足条件的，之所以能这样做是因为在RecordAccess()中保证了这一点。<br>
然后就是注意反向迭代器的删除：history_list_.erase(std::next(rit).base());</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">auto LRUKReplacer::Evict(frame_id_t *frame_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (curr_size_ == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!history_list_.empty()) &#123;</span><br><span class="line">    for (auto rit = history_list_.rbegin(); rit != history_list_.rend(); ++rit) &#123;  // fisrt in first out</span><br><span class="line">      if (entries_[*rit].evictable_) &#123;</span><br><span class="line">        *frame_id = *rit;</span><br><span class="line">        history_list_.erase(std::next(rit).base());  // erase的入参只接受正向迭代器</span><br><span class="line">        entries_.erase(*frame_id);</span><br><span class="line">        --curr_size_;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!cache_list_.empty()) &#123;</span><br><span class="line">    for (auto rit = cache_list_.rbegin(); rit != cache_list_.rend();</span><br><span class="line">         ++rit) &#123;  // in RecordAccess() ,we have insure the first frame is the latest one</span><br><span class="line">      if (entries_[*rit].evictable_) &#123;</span><br><span class="line">        *frame_id = *rit;</span><br><span class="line">        cache_list_.erase(std::next(rit).base());</span><br><span class="line">        entries_.erase(*frame_id);</span><br><span class="line">        --curr_size_;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RecordAccess()</strong></p>
<ul>
<li>首先判断frame_id是否越界，如果越界，则抛出异常</li>
<li>然后更改++hit_count_，由于unordered_map的性质，如果entries_中没有该页，他会自动初始化一个</li>
<li>然后判断hit_count_的值，判断是否需要移入到cache_list_中，如果已经在cache_list_中也需要将其移动到队首以保证LRU策略</li>
</ul>
<p>注意到就算有新页进来curr_size_也不能加一，因为新页默认是不可驱逐的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::RecordAccess(frame_id_t frame_id) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  // for new frames , default hit count is 0</span><br><span class="line"></span><br><span class="line">  size_t count = ++entries_[frame_id].hit_count_;  // 新页在此添加进entries</span><br><span class="line">  if (count == 1) &#123;                                // new frame</span><br><span class="line">    // LOG_INFO(&quot;%d NEW FRAME&quot;,frame_id);</span><br><span class="line">    // ++curr_size_; // bug1,不应该++，因为默认的evictable_是false</span><br><span class="line">    history_list_.emplace_front(frame_id);</span><br><span class="line">    entries_[frame_id].pos_ = history_list_.begin();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (count == k_) &#123;  // reach k-hit , move from history_list_ to the front of cache_list_</span><br><span class="line">      // LOG_INFO(&quot;No.%d FRAME MOVE FROM HIST TO CACHE&quot; , frame_id);</span><br><span class="line">      history_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">      cache_list_.emplace_front(frame_id);</span><br><span class="line">      entries_[frame_id].pos_ = cache_list_.begin();</span><br><span class="line">    &#125; else if (count &gt; k_) &#123;  // move to the front of cache_list_ , insure the LRU</span><br><span class="line">      cache_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">      cache_list_.emplace_front(frame_id);</span><br><span class="line">      entries_[frame_id].pos_ = cache_list_.begin();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // count &lt; k , keep in history_list_ , do not move because the FIFO</span><br><span class="line">  // LOG_INFO(&quot;RECORD: %d&quot; , frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SetEvictable()</strong><br>
该函数用于调整evictable_属性，比较简单，唯一要注意的就是对于curr_size_值的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable_) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_.find(frame_id) == entries_.end()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (set_evictable_ &amp;&amp; !entries_[frame_id].evictable_) &#123;</span><br><span class="line">    curr_size_++;</span><br><span class="line">  &#125; else if (!set_evictable_ &amp;&amp; entries_[frame_id].evictable_) &#123;</span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  entries_[frame_id].evictable_ = set_evictable_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Remove()</strong><br>
逻辑比较简单，看代码即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::Remove(frame_id_t frame_id) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_.find(frame_id) == entries_.end()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!entries_[frame_id].evictable_) &#123;</span><br><span class="line">    throw std::logic_error(std::string(&quot;Can&#x27;t remove an inevictable_ frame: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_[frame_id].hit_count_ &lt; k_) &#123;</span><br><span class="line">    history_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cache_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">  &#125;</span><br><span class="line">  --curr_size_;</span><br><span class="line">  entries_.erase(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓冲池管理（Buffer-Pool-Manager）">缓冲池管理（Buffer Pool Manager）</h2>
<p>Buffer Pool Manager 简单来说就是充当数据库上层设施和磁盘文件间的缓冲区，类似于 Cache 在 CPU 和内存间的作用。bustub 中有 Page 和 Frame 的概念，Page 是承载 4K 大小数据的类，可以通过 DiskManager 从磁盘文件中读写，带有 page_id 编号，is_dirty 标识等信息。Frame 不是一个具体的类，而可以理解为 Buffer Pool Manager（以下简称 BPM）中容纳 Page 的槽位，具体来说，BPM 中有一个 Page 数组，frame_id 就是某个 Page 在该数组中的下标。</p>
<p>外界只知道 page_id，向 BPM 查询时，BPM 要确定该 Page 是否存在以及其位置，所以要维护一个 page_id 到 frame_id 的映射，这里就使用我们刚完成的 ExtendibleHashTable。为区分空闲和占用的 Page，维护一个 free_list_，保存空闲的 frame_id。初始状态，所有 Page 都是空闲的。当上层需要取一个 Page 时，如果 Page 已存在于 BP 中，则直接返回；否则需要从磁盘读取到 BP 中。此时优先取空闲的 Page，否则只能从所有已经占用的 Page 中用我们刚完成的 LRUKReplacer 决定踢出某个 Page。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Creates a new BufferPoolManagerInstance.</span><br><span class="line"> * @param pool_size the size of the buffer pool</span><br><span class="line"> * @param disk_manager the disk manager</span><br><span class="line"> * @param replacer_k the lookback constant k for the LRU-K replacer</span><br><span class="line"> * @param log_manager the log manager (for testing only: nullptr = disable logging). Please ignore this for P1.</span><br><span class="line"> */</span><br><span class="line">BufferPoolManagerInstance(size_t pool_size, DiskManager *disk_manager, size_t replacer_k = LRUK_REPLACER_K,</span><br><span class="line">                          LogManager *log_manager = nullptr);</span><br><span class="line"></span><br><span class="line">/** Number of pages in the buffer pool. */</span><br><span class="line">const size_t pool_size_;</span><br><span class="line">/** The next page id to be allocated  */</span><br><span class="line">std::atomic&lt;page_id_t&gt; next_page_id_ = 0;</span><br><span class="line">/** Bucket size for the extendible hash table */</span><br><span class="line">const size_t bucket_size_ = 4;</span><br><span class="line"></span><br><span class="line">/** Array of buffer pool pages. */</span><br><span class="line">Page *pages_;  // frame_id在这个数组中起到index的作用,可以就理解为内存中的页框(Page Frame,或页帧)</span><br><span class="line">/** Pointer to the disk manager. */</span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">/** Pointer to the log manager. Please ignore this for P1. */</span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">/** Page table for keeping track of buffer pool pages. */</span><br><span class="line">ExtendibleHashTable&lt;page_id_t, frame_id_t&gt; *page_table_;</span><br><span class="line">/** Replacer to find unpinned pages for replacement. */</span><br><span class="line">LRUKReplacer *replacer_;</span><br><span class="line">/** List of free frames that don&#x27;t have any pages on them. */</span><br><span class="line">std::list&lt;frame_id_t&gt; free_list_;</span><br><span class="line">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure>
<h3 id="3-BufferPoolManagerInstance-类实现">3. BufferPoolManagerInstance 类实现</h3>
<p>在该类中主要要实现以下几个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// @brief Create a new page in the buffer pool. Set page_id to the new page&#x27;s id, or nullptr if all frames</span><br><span class="line">// are currently in use and not evictable (in another word, pinned).</span><br><span class="line">auto NewPgImp(page_id_t *page_id) -&gt; Page * override;</span><br><span class="line"></span><br><span class="line">// @brief Fetch the requested page from the buffer pool. Return nullptr if page_id needs to be fetched from the disk</span><br><span class="line">// but all frames are currently in use and not evictable (in another word, pinned).</span><br><span class="line">auto FetchPgImp(page_id_t page_id) -&gt; Page * override;</span><br><span class="line"></span><br><span class="line">// @brief Unpin the target page from the buffer pool. If page_id is not in the buffer pool or its pin count is already 0, return false.</span><br><span class="line">auto UnpinPgImp(page_id_t page_id, bool is_dirty) -&gt; bool override;</span><br><span class="line"></span><br><span class="line">// @brief Flush the target page to disk.</span><br><span class="line">// Use the DiskManager::WritePage() method to flush a page to disk, REGARDLESS of the dirty flag.</span><br><span class="line">// Unset the dirty flag of the page after flushing.</span><br><span class="line">auto FlushPgImp(page_id_t page_id) -&gt; bool override;</span><br><span class="line"></span><br><span class="line">// @brief Flush all the pages in the buffer pool to disk</span><br><span class="line">void FlushAllPgsImp() override;</span><br><span class="line"></span><br><span class="line">// @brief Delete a page from the buffer pool. If page_id is not in the buffer pool, do nothing and return true. If the</span><br><span class="line">// page is pinned and cannot be deleted, return false immediately.</span><br><span class="line">auto DeletePgImp(page_id_t page_id) -&gt; bool override;</span><br></pre></td></tr></table></figure>
<p><strong>NewPgImp()</strong><br>
逻辑很简单，获取一个空闲页或者利用LRU-K淘汰一个页，然后利用这个页号来新建。<br>
注意在初始化的过程中replacer_-&gt;RecordAccess(frame_id);必须在replacer_-&gt;SetEvictable(frame_id, false);之前，因为在SetEvictable中的if(entries.find(frame_id) == entries.end())判断时，此时还没有entries条目，所以会直接返回故会出bug。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::NewPgImp(page_id_t *page_id) -&gt; Page * &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!GetAvailableFrame(&amp;frame_id)) &#123;</span><br><span class="line">    // LOG_INFO(&quot;false: %d#&quot;,frame_id);</span><br><span class="line">    page_id = nullptr;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  // LOG_INFO(&quot;true: %d#&quot;,frame_id);</span><br><span class="line">  page_id_t new_page_id = AllocatePage();</span><br><span class="line">  // reset page 重置内存、元数据；更新 buffer pool</span><br><span class="line">  pages_[frame_id].page_id_ = new_page_id;</span><br><span class="line">  pages_[frame_id].ResetMemory();</span><br><span class="line">  pages_[frame_id].pin_count_ = 0;</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line"></span><br><span class="line">  page_table_-&gt;Insert(new_page_id, frame_id);</span><br><span class="line">  // &quot;Pin&quot; the frame by calling replacer.SetEvictable(frame_id, false)</span><br><span class="line">  /* RecordAccess必须在SetEvictable之前</span><br><span class="line">    因为在SetEvictable中的if(entries.find(frame_id) == entries.end())</span><br><span class="line">  ，此时还没有entries条目，所以会直接返回故会报错 */</span><br><span class="line">  replacer_-&gt;RecordAccess(frame_id);</span><br><span class="line">  replacer_-&gt;SetEvictable(frame_id, false);</span><br><span class="line">  pages_[frame_id].pin_count_++;</span><br><span class="line">  // record the access history</span><br><span class="line"></span><br><span class="line">  *page_id = new_page_id;</span><br><span class="line">  return &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数中的GetAvailableFrame(&amp;frame_id)是我添加的一个函数，用于在free_list_中获取空闲页框或者利用LRU-K淘汰一个页：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// add a function to GetAvailableFrame</span><br><span class="line">auto BufferPoolManagerInstance::GetAvailableFrame(frame_id_t *avilFrameId) -&gt; bool &#123;</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!free_list_.empty()) &#123;</span><br><span class="line">    // LOG_INFO(&quot;free_list_: %d#&quot;,frame_id);</span><br><span class="line">    frame_id = free_list_.front();</span><br><span class="line">    free_list_.pop_front();</span><br><span class="line">    *avilFrameId = frame_id;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // no free frame , find a replacement</span><br><span class="line">  if (replacer_-&gt;Evict(&amp;frame_id)) &#123;</span><br><span class="line">    // LOG_INFO(&quot;replacement: %d#&quot;,frame_id);</span><br><span class="line">    if (pages_[frame_id].IsDirty()) &#123;</span><br><span class="line">      disk_manager_-&gt;WritePage(pages_[frame_id].GetPageId(), pages_[frame_id].GetData());</span><br><span class="line">      pages_[frame_id].is_dirty_ = false;</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_-&gt;Remove(pages_[frame_id].GetPageId());</span><br><span class="line">    *avilFrameId = frame_id;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FetchPgImp()</strong><br>
与NewPgImp类似，如果没有这个页就从磁盘读取并在BPM中加入该页，改变LRU-k中的访问记录和evictable_</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::FetchPgImp(page_id_t page_id) -&gt; Page * &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    if (!GetAvailableFrame(&amp;frame_id)) &#123;</span><br><span class="line">      return nullptr;  // cache中没有 同时也没有frame可以获取</span><br><span class="line">    &#125;</span><br><span class="line">    pages_[frame_id].page_id_ = page_id;</span><br><span class="line">    pages_[frame_id].ResetMemory();</span><br><span class="line">    pages_[frame_id].pin_count_ = 0;</span><br><span class="line">    pages_[frame_id].is_dirty_ = false;</span><br><span class="line">    disk_manager_-&gt;ReadPage(page_id, pages_[frame_id].data_);</span><br><span class="line">    page_table_-&gt;Insert(page_id, frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  replacer_-&gt;RecordAccess(frame_id);</span><br><span class="line">  replacer_-&gt;SetEvictable(frame_id, false);</span><br><span class="line">  pages_[frame_id].pin_count_++;</span><br><span class="line">  return &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UnpinPgImp()</strong><br>
看代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  // If page_id is not in the buffer pool or its pin count is already 0, return false</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pages_[frame_id].pin_count_ &lt;= 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (--pages_[frame_id].pin_count_ == 0) &#123;</span><br><span class="line">    replacer_-&gt;SetEvictable(frame_id, true);</span><br><span class="line">  &#125;</span><br><span class="line">  if (is_dirty) &#123;</span><br><span class="line">    pages_[frame_id].is_dirty_ = is_dirty;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的逻辑也很简单，看代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::FlushPgImp(page_id_t page_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  disk_manager_-&gt;WritePage(page_id, pages_[frame_id].data_);</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BufferPoolManagerInstance::FlushAllPgsImp() &#123;</span><br><span class="line">  for (size_t i = 0; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    if (pages_[i].GetPageId() == INVALID_PAGE_ID) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    FlushPgImp(pages_[i].GetPageId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto BufferPoolManagerInstance::DeletePgImp(page_id_t page_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pages_[frame_id].GetPinCount() &gt; 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  // 在页表中删除</span><br><span class="line">  page_table_-&gt;Remove(page_id);</span><br><span class="line">  // 在replace_移除对frame_id的跟踪</span><br><span class="line">  replacer_-&gt;Remove(frame_id);</span><br><span class="line">  // 在free_list_中插入</span><br><span class="line">  free_list_.emplace_back(frame_id);</span><br><span class="line">  // 重置BPM中的页框</span><br><span class="line">  pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  pages_[frame_id].ResetMemory();</span><br><span class="line">  pages_[frame_id].pin_count_ = 0;</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line"></span><br><span class="line">  DeallocatePage(page_id);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://V1per3.github.io">V1per3</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://v1per3.github.io/post/c154d63.html">https://v1per3.github.io/post/c154d63.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://V1per3.github.io" target="_blank">V1per3</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CMU15-445/">CMU15-445</a></div><div class="post_share"><div class="social-share" data-image="/img/CMU15445.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/bcba2380.html"><img class="prev-cover" src="/img/CMU15445.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CMU15-445 bustub Project2：B+ Tree</div></div></a></div><div class="next-post pull-right"><a href="/post/470938e7.html"><img class="next-cover" src="/img/CMU15445.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CMU15-445 bustub Project0：Trie 树实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/470938e7.html" title="CMU15-445 bustub Project0：Trie 树实现"><img class="cover" src="/img/CMU15445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-29</div><div class="title">CMU15-445 bustub Project0：Trie 树实现</div></div></a></div><div><a href="/post/bcba2380.html" title="CMU15-445 bustub Project2：B+ Tree"><img class="cover" src="/img/CMU15445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-13</div><div class="title">CMU15-445 bustub Project2：B+ Tree</div></div></a></div><div><a href="/post/b4f7d51b.html" title="CMU15-445 bustub Project3：Query Execution"><img class="cover" src="/img/CMU15445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-03</div><div class="title">CMU15-445 bustub Project3：Query Execution</div></div></a></div><div><a href="/post/6b93e080.html" title="CMU15-445 bustub Project4：Concurrency Control"><img class="cover" src="/img/CMU15445.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-26</div><div class="title">CMU15-445 bustub Project4：Concurrency Control</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">V1per3</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/V1per3"><i class="fas fa-user-plus"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/V1per3" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:cswuwei777@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1687683994&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">总得有个自己的窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Extendible-Hash-Table%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">可扩展哈希表（Extendible Hash Table）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bucket%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">Bucket类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtendibleHashTable%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">ExtendibleHashTable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">1.3.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-K-%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%EF%BC%88LRU-K-Replacement-Policy%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">LRU-K 置换策略（LRU-K Replacement Policy）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LRUKReplacer-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">LRUKReplacer 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E7%AE%A1%E7%90%86%EF%BC%88Buffer-Pool-Manager%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">缓冲池管理（Buffer Pool Manager）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BufferPoolManagerInstance-%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3. BufferPoolManagerInstance 类实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/3b16a234.html" title="6.5840/6.824 Lab4 KVRaft"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab4 KVRaft"/></a><div class="content"><a class="title" href="/post/3b16a234.html" title="6.5840/6.824 Lab4 KVRaft">6.5840/6.824 Lab4 KVRaft</a><time datetime="2024-03-28T04:10:03.791Z" title="发表于 2024-03-28 12:10:03">2024-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/271158e5.html" title="6.5840/6.824 Lab3 Raft"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab3 Raft"/></a><div class="content"><a class="title" href="/post/271158e5.html" title="6.5840/6.824 Lab3 Raft">6.5840/6.824 Lab3 Raft</a><time datetime="2024-03-20T03:42:42.245Z" title="发表于 2024-03-20 11:42:42">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4f335a90.html" title="6.5840/6.824 Lab2 Key/Value Server"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab2 Key/Value Server"/></a><div class="content"><a class="title" href="/post/4f335a90.html" title="6.5840/6.824 Lab2 Key/Value Server">6.5840/6.824 Lab2 Key/Value Server</a><time datetime="2024-03-05T15:00:41.698Z" title="发表于 2024-03-05 23:00:41">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d5c40702.html" title="6.5840/6.824 Lab1 MapReduce"><img src="/img/6824.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="6.5840/6.824 Lab1 MapReduce"/></a><div class="content"><a class="title" href="/post/d5c40702.html" title="6.5840/6.824 Lab1 MapReduce">6.5840/6.824 Lab1 MapReduce</a><time datetime="2024-03-03T10:44:52.625Z" title="发表于 2024-03-03 18:44:52">2024-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6b93e080.html" title="CMU15-445 bustub Project4：Concurrency Control"><img src="/img/CMU15445.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU15-445 bustub Project4：Concurrency Control"/></a><div class="content"><a class="title" href="/post/6b93e080.html" title="CMU15-445 bustub Project4：Concurrency Control">CMU15-445 bustub Project4：Concurrency Control</a><time datetime="2024-01-26T06:37:05.249Z" title="发表于 2024-01-26 14:37:05">2024-01-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/CMU15445.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By V1per3</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script></div></body></html>