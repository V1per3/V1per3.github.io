<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http的8种请求方法</title>
      <link href="/post/1e0e1e64.html"/>
      <url>/post/1e0e1e64.html</url>
      
        <content type="html"><![CDATA[<h2 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h2><p><strong>8种：GET、HEAD、POST、PUT、DELETE、OPTIONS、TRACE、PATCH</strong><br>根据RFC2616第九章说明，http方法的定义有两点：safe and Idempotent，即安全性和幂等性，可以结合这两点对以上方法进行说明。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>特点：安全、幂等。<br>说明：从服务器端获取数据，请求body在地址栏上。<br>作用：获取资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>特点：安全、幂等。<br>说明：与get方法类似，但不返回message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）。<br>作用：restful框架中较少使用。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>特点：非安全、非幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据要重新新创建。<br>作用：用于创建子资源。创建、更新、删除、查询资源均可使用。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据更新（全部更新）。<br>作用：用于创建、更新资源。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个删除数据的请求。<br>作用：删除资源。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>特点：安全、幂等。<br>作用：用于url验证，验证接口服务是否正常。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>特点：安全、幂等。<br>说明：维基百科“回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现。”<br>作用：restful框架中较少使用。</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>与PUT类似，发送一个修改数据的请求，区别在于PATCH代表部分更新；<br>后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；<br>作用：用于创建、更新资源。局部更新，比如：user对象，只更改了name属性，那么他的其他属性值是不会变的，如果用post，那么其他属性值会被设置为null（全局更新）</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</span><br><span class="line">比如:GET http://www.bank.com/account/123456,不会改变资源的状态，不论调用一次还是N次都没有副作用。</span><br><span class="line">请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</span><br><span class="line">GET http://www.news.com/latestnews这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</span><br><span class="line"></span><br><span class="line">HTTP DELETE方法用于删除资源，有副作用,但它应该满足幂等性。比如: DELETE http://www.forum.com/article/4231,</span><br><span class="line">调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子;因此，调用者可以多次调用或刷新页面而不必担心引起错误。</span><br><span class="line"></span><br><span class="line">重点来了：比较容易混淆的是HTTP的 POST和PUT。POST和PUT的区别容易被简单地误认为&quot;POST表示创建资源，PUT表示更新资源”;</span><br><span class="line">而实际上,二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的:</span><br><span class="line">POST所对应的URI并非创建的资源本身，而是资源的接收者。</span><br><span class="line">比如: POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。</span><br><span class="line">两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI; 所以，POST方法不具备幂等性。</span><br><span class="line">而PUT所对应的URI是要创建或更新的资源本身。</span><br><span class="line">比如: PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。</span><br><span class="line">对同一URI进行多次PUT的副作用和一次PUT是相同的;因比，PUT方法具有幕等性。</span><br><span class="line"></span><br><span class="line">在介绍了几种操作的语义和幂等性之后,我们来看看如何通过Web API的形式实现前面所提到的取款功能。</span><br><span class="line">很简单，POST /tickets来实现create_ticket;用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent _withdraw。</span><br><span class="line">值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_ id/ticket_id,而amount应该放在请求的body中。</span><br><span class="line">这种模式可以应用于很多场合，比如:论坛网站中防止意外的重复发帖。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extra-bbs开发项目</title>
      <link href="/post/9a9a747.html"/>
      <url>/post/9a9a747.html</url>
      
        <content type="html"><![CDATA[<h3 id="项目总述"><a href="#项目总述" class="headerlink" title="项目总述"></a>项目总述</h3><p>一个社区论坛形式的项目，有点类似贴吧，知乎。分为web应用前端live，后端sever以及后台管理系统admin。<br><img src="img/extrabbs.png" alt="extra_bbs"></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>前端技术栈</p></blockquote><p><code>vue</code> <code>vuex</code> <code>vue-router</code></p><p>其中也涉及到一些依赖，比如sweetalert等等<br>repository: <a href="https://github.com/V1per3/Extra-BBS-live">https://github.com/V1per3/Extra-BBS-live</a></p><h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>技术栈</p></blockquote><p><code>node</code> + <code>koa2</code> + <code>koa-router</code> + <code>ES6</code> + <code>mysql</code> + <code>mongodb</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-server">https://github.com/V1per3/Extra-BBS-server</a></p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">└── PPAP.server</span><br><span class="line">    ├── config <span class="comment"># 配置文件</span></span><br><span class="line">    │   └── index.js  </span><br><span class="line">    ├── controller <span class="comment"># 操作层 验证视图层用户输入，调用业务层方法，json接口返回数据</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── model <span class="comment"># 数据模型层 执行数据操作</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── router <span class="comment"># 路由层 控制路由</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── service <span class="comment"># 业务层 操作数据层，对业务逻辑进行处理，将结果返回控制层</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── sql <span class="comment"># 数据表sql</span></span><br><span class="line">    │   └── init.sql</span><br><span class="line">    ├── util <span class="comment"># 工具函数</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── app.js <span class="comment"># 入口文件</span></span><br><span class="line">    ├── package.json </span><br><span class="line">    ├── README.md</span><br><span class="line">    └── yarn.lock</span><br></pre></td></tr></table></figure><h4 id="构建步骤-1"><a href="#构建步骤-1" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><h3 id="后台管理系统"><a href="#后台管理系统" class="headerlink" title="后台管理系统"></a>后台管理系统</h3><blockquote><p>技术栈</p></blockquote><p><code>react</code> + <code>ant-design UI</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-admin">https://github.com/V1per3/Extra-BBS-admin</a></p><h4 id="构建步骤-2"><a href="#构建步骤-2" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 线性表</title>
      <link href="/post/aeec3311.html"/>
      <url>/post/aeec3311.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性表的定义与基本操作"><a href="#线性表的定义与基本操作" class="headerlink" title="线性表的定义与基本操作"></a>线性表的定义与基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><ol><li>线性表是具有<strong>相同</strong>数据类型的n(n&gt;=0)个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时线性表是一个空表。</li><li>若用L命名线性表，则其一般表示为L=(a1,a2,…,ai,ai+1,…an)</li><li>表达式中a1是唯一<strong>第一个</strong>数据元素，又称为表头元素；an是唯一的<strong>最后一个</strong>数据元素，又称为表尾元素。</li><li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后驱。<br><strong>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆</strong><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L): 初始化表。构造一个空的线性表。</span><br><span class="line">Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定元素e。</span><br><span class="line">ListDelete(&amp;L,i,&amp;e): 删除操作。删除表中L中第i个位置的元素，并用e返回删除的元素。</span><br><span class="line">PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</span><br><span class="line">DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><strong>注意：基本操作的具体实现取决于采用哪种存储结构（见下图）,存储结构不同，算法的实现也不同.”&amp;”表示C++语言中的引用调用,在c语言中采用指针也可以达到相同的效果.后续文章中两种方式都会使用.</strong></li></ol><p><img src="/img/sujgxxb1.png" alt=""></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p><p>假定线性表的元素类型为ElemType,则线性表的顺序存储类型描述为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 10  //定义顺序表的最大长度，在声明数组时使用</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];//顺序表的数据元素</span><br><span class="line">    int length;//顺序表的当前长度</span><br><span class="line">&#125;Sqlist;//顺序表的类型定义</span><br></pre></td></tr></table></figure><br>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定好，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序奔溃甚至引起其他未知异常。</p><p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦存储空间占满，就另外开辟一块更大的存储区间，将原来的元素复制过去，从而达到扩充存储数组空间的目的，而不需要一次性分配很大的空间。<br>C语言的初始动态分配语句为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure><br>C++语言的初始化动态分配语句为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data=new ElemType[InitSize];</span><br></pre></td></tr></table></figure><br><strong>注意：动态存储并不是链式存储，它同样属于顺序存储，物理结构没有变化，还是和逻辑结构一样保持相邻，只是分配的空间不再是编译器决定，而是运行时分配。</strong></p><h3 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h3><p>随机访问：可通过首地址和元素序号在单位时间O(1)内找到指定的元素。</p><p>存储密度高：存储密度高是因为每个结点存储空间指用来存储数据元素，没有别的额外开销。</p><p>物理位置相邻：物理位置和逻辑位置一样，保持相邻，因此插入和删除元素需要移动大量元素，比较耗时。这是物理结构相邻的所有数据结构的通病，虽然访问快，但是如果有频繁的增删移动操作，就会效率很低。</p><h3 id="顺序表上的基本操作"><a href="#顺序表上的基本操作" class="headerlink" title="顺序表上的基本操作"></a>顺序表上的基本操作</h3><p>仅展示查、增、删三种操作，其余的在线性表中较为简单，在后续更复杂的链表中展示。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>在顺序表L的第i（1&lt;=i&lt;=L.length+1）位插入新元素e。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length + 1)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    if (L.length &gt;= MaxSize)   //判断是否超出存储空间</span><br><span class="line">        return false;</span><br><span class="line">    for (int j = L.length; j &gt;= i; j--)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j - 1];</span><br><span class="line">    L.data[i - 1] = e;   //在第i位插入元素e</span><br><span class="line">    L.length++;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最好情况：在表尾插入（即i=n+1）,原本的元素不移动，时间复杂度为O(1)。</p><p>最坏情况：在表头插入（即i=1），所有元素需要后移一位，元素后移语句执行n次，时间复杂度为O(n)。</p><p>平均情况：假设Pi(Pi=1/(n+1))是在第i个位置上插入一个结点的概率，则在长度为n的顺序表中插入一个结点时，所需要移动结点的平均次数为n/2，时间复杂度为O(n)。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    e = L.data[i - 1];     //保存要删除的数据到e</span><br><span class="line">    for (int j = i-1; j &lt;= L.length; ++j)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j + 1];</span><br><span class="line">    L.length--;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度与插入一样（平均时间复杂度上，插入始终每一步比删除多一次操作，即插入操作，但是不会引起量级变化，所以平均时间复杂度依旧为O(N)）</p><h4 id="按值查找（顺序查找）操作"><a href="#按值查找（顺序查找）操作" class="headerlink" title="按值查找（顺序查找）操作"></a>按值查找（顺序查找）操作</h4><p>在顺序表中查找第一个元素值等于e的元素的位置，未查找到返回-1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L,const ElemType &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; L.length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if (L.data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最好情况：在表头找到（即i=1）,时间复杂度为O(1)。</p><p>最坏情况：在表尾插入（即i=n），时间复杂度为O(n)。</p><p>平均情况：时间复杂度为O(n)。</p><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p>逻辑上相邻的元素在物理位置上不一定相邻。<br>优点：</p><ol><li>没有了顺序存储所具有的弱点（也就是说：插入和删除不需要移动元素，而只需要修改指针。）</li><li>同时，由于不借助数组实现，在定义链表时，无需指定它的长度。</li></ol><p>缺点：<br>也失去了顺序存储的优点</p><ol><li>非随机存取（不能直接找到某个特定序号的结点，需要从表头开始遍历）</li><li>存储密度降低（除了存储本身信息外链表还要存储指针）<h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3>线性表的链式存储又称为单链表，它是指通过一组任意的存储单位来存储线性表中的元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素的自身信息外，还需要存放一个指向其后继的指针。</li></ol><p>由于逻辑上相邻的元素在物理位置上不一定相邻，那么我们如何确定下一个元素的存储位置呢？<br><strong>解决办法，增加一个变量。用来存储一个指示其后继位置的指针。</strong><br>我们把这两部分的信息组成数据元素a的存储映像，称为<strong>结点</strong>。它包含两个域，其中存储数据元素信息的域称为<strong>数据域</strong>，存储直接后继存储位置的域称为<strong>指针域</strong>。</p><p>单链表中结点定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123; //定义单链表节点类型</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct LNode *next;//指针域</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><br><strong>头指针</strong><br>整个链表的存储<strong>必须从头指针开始</strong><br>头指针指示链表中第一个结点的存储位置<br>同时，由于最后一个数据元素没有直接后继，则单链表中最后一个一个结点的指针为NULL<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//头指针定义1</span><br><span class="line">LinkList L;</span><br><span class="line">//头指针定义2</span><br><span class="line">LNode *L;</span><br></pre></td></tr></table></figure><br><strong>头结点</strong><br>在单链表的第一个结点之前附设一个结点，称为头结点。<br>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度之类的附加信息。<br>头结点的指向第一个结点的指针（即第一个元素结点的存储位置）<br>此时，单链表的头指针指向头结点。<br><img src="/img/sujgxxb2.png" alt=""></p><p><strong>空表</strong><br>含头结点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L-&gt;next==NULL时为空表</span><br></pre></td></tr></table></figure><br>不含头结点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L==NULL时为空表；</span><br></pre></td></tr></table></figure></p><h3 id="单链表上具体操作的实现和时间复杂度"><a href="#单链表上具体操作的实现和时间复杂度" class="headerlink" title="单链表上具体操作的实现和时间复杂度"></a>单链表上具体操作的实现和时间复杂度</h3><h4 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h4><p>构造一个空表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int InitList_Link(LinkList *L)&#123;</span><br><span class="line">    *L=(LinkList)malloc(sizeof(LNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(1)</span><br></pre></td></tr></table></figure></p><h4 id="根据数组创建单链表"><a href="#根据数组创建单链表" class="headerlink" title="根据数组创建单链表"></a>根据数组创建单链表</h4><h5 id="含头结点的单链表"><a href="#含头结点的单链表" class="headerlink" title="含头结点的单链表"></a>含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点指向第一个结点</span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        r=s;//r移动到链表尾端</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不含头结点的单链表"><a href="#不含头结点的单链表" class="headerlink" title="不含头结点的单链表"></a>不含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line">    *L=NULL;</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            *L=s;//头指针指向插入结点</span><br><span class="line">            s-&gt;next=NULL;//倒序插入，最后一个结点的指针域赋值为NULL</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            s-&gt;next=*(L);//新插入的结点指向第一个结点</span><br><span class="line">            *(L)=s;//头指针指向新的插入节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    (*L)=NULL;</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            (*L)=s;//头指针指向第一个结点</span><br><span class="line">            r=s;//尾指针移动到最后一个结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">            r=s;//r移动到链表尾端</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>含头结点优点：</p><ol><li>使得链表第一个结点的操作和其他位置一样，无需特殊处理。</li></ol><p>含头结点缺点：</p><ol><li>头结点的数据域一般不存储数据，该空间被浪费。</li></ol><p>时间复杂度：</p><ol><li>每个结点插入的时间为O(1),设表长为n，所有方式的时间复杂度均为O(n)</li></ol><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Length_Link(LinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        L=L-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：设表长为n,时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><p>在表L中的第i个位置上插入指定元素e。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert_Link(LinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure></p><h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除表中L中第i个位置的元素，并用e返回删除的元素。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete_Link(LinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure></p><h4 id="按位查找操作"><a href="#按位查找操作" class="headerlink" title="按位查找操作"></a>按位查找操作</h4><p>获取表L中第i个位置的元素的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int GetElem_List(LinkList L,int i,ElemType *e)&#123;</span><br><span class="line">    LNode *p=L; //p指向头结点</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (p&amp;&amp;j&lt;i)&#123;//找到第i个位置</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(p)||i&lt;1)  return FALSE; //i不在有效范围内</span><br><span class="line">    *e=p-&gt;data; //把第i个结点的值用e返回</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure></p><h4 id="按值查找操作"><a href="#按值查找操作" class="headerlink" title="按值查找操作"></a>按值查找操作</h4><p>在表L中查找具有给定关键字值的元素,返回序号<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_List(LinkList L,ElemType e,int *i)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历链表</span><br><span class="line">        L=L-&gt;next;//向后移动</span><br><span class="line">        j++;//序号加一</span><br><span class="line">        if (L-&gt;data.id==e.id)&#123;//这里我们只用id来判断元素的值是否相等，假设id唯一</span><br><span class="line">            *i=j;//如果相等，用i返回序号</span><br><span class="line">            return TRUE;//查找成功</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure></p><h4 id="销毁表"><a href="#销毁表" class="headerlink" title="销毁表"></a>销毁表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(LinkList *L)&#123;</span><br><span class="line">    while((*L)-&gt;next!=NULL) &#123;//遍历链表</span><br><span class="line">    LNode *p=(*L)-&gt;next;//p指示头结点的下一个，要被删除的结点</span><br><span class="line">    (*L)-&gt;next=p-&gt;next;//让头结点指向p的下一个，把p从链表断开</span><br><span class="line">    free(p);//删除p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表结点中只有一个指向其后继结点的指针，使得单链表只能从头结点依次顺序地向后遍历。<br>要访问某个结点的前驱结点，只能从头开始遍历。<br>也就是说：访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)</p><p><strong>为了克服单链表的上述缺点，引入了双链表。</strong><br><strong>双链表中有两个指针prior和next，分别指向其前驱结点和后继结点</strong></p><h4 id="双链表的定义"><a href="#双链表的定义" class="headerlink" title="双链表的定义"></a>双链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DNode&#123;</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct DNode *prior;//前驱指针</span><br><span class="line">    struct DNode *next;//后继指针</span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure><p><img src="/img/sujgxxb3.png" alt=""></p><h4 id="双链表上具体操作的实现和时间复杂度"><a href="#双链表上具体操作的实现和时间复杂度" class="headerlink" title="双链表上具体操作的实现和时间复杂度"></a>双链表上具体操作的实现和时间复杂度</h4><p>使用含头结点的双链表</p><h5 id="初始化表-1"><a href="#初始化表-1" class="headerlink" title="初始化表"></a>初始化表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitList_DLink(DLinkList *L)&#123;</span><br><span class="line">    *L=(DLinkList)malloc(sizeof(DNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;prior=NULL;//头结点的prior永远指向NULL</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(1)</span><br></pre></td></tr></table></figure><h5 id="根据数组创建双链表"><a href="#根据数组创建双链表" class="headerlink" title="根据数组创建双链表"></a>根据数组创建双链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*头插法创建双链表*/</span><br><span class="line">int create_HeadInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于D头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点的后继指向第一个结点</span><br><span class="line">        if((*L)-&gt;next!=NULL) (*L)-&gt;next-&gt;prior=s;//第一个结点的前驱指向该结点</span><br><span class="line">        s-&gt;prior=(*L);//让该结点的前驱指向头结点   </span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该D结点（该结点成为第一个结点）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*尾插法创建双链表*/</span><br><span class="line">int create_TailInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        s-&gt;prior=r;//该结点的前驱指向r指向的结点</span><br><span class="line">        r=s;//r移动到链表尾端o</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每个结点插入的时间为O(1),设表长为n,所有方式的时间复杂度均为O(n)</span><br></pre></td></tr></table></figure><h5 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h5><p>在表L中的第i个位置上插入指定元素e。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_DLink(DLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    if (p-&gt;next!=NULL) p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前D驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure></p><h5 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除表中L中第i个位置的元素，并用e返回删除的元素。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">int ListDelete_DLink(DLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    if(q-&gt;next!=NULL)q-&gt;next-&gt;prior=p;</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><br>其他操作与单链表一样，不展示</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>特点：表中最后一个结点的指针域指向头结点，整个链表形成一个环。<br>既然是环的话，那就不难想象，从表中任意一个结点出发都可以找到表中其他结点。</p><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表与单链表唯一的区别就是多了一个由尾结点指向头结点的指针。<br>所以循环链表的操作与单链表基本一致<br>唯一的差别就是<strong>循环的条件不是p或p-&gt;next是否为空，而是它们是否等于头指针</strong><br>($p==L或p-&gt;next==L$)。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int Length_CLink(CLinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    CNode *s=L;</span><br><span class="line">    while (s-&gt;next!=L)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        s=s-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>循环双链表与循环单链表唯一的区别就是多了一个指向前驱的指针。<br>所以循环双链表的操作与循环单链表也基本一致<br>就是<strong>对结点操作时，需要多操作一步，让p-&gt;prior指向前驱结点。</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_CDLink(CDLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(p==(*L)||(i-j)&gt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(CDLinkList)malloc(sizeof(CDNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*删除*/</span><br><span class="line">int ListDelete_CDLink(CDLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((p-&gt;next)==(*L)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    q-&gt;next-&gt;prior=p;//让删除结点的下一个结点的前驱指向p；</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>众所周知，指针是c语言的灵魂，指针使得链表的实现简单明了起来。但是问题来了，在c语言还没有的时代，又想描述链表，怎么办呢？<br>这就有了静态链表</p><h4 id="静态链表的设计"><a href="#静态链表的设计" class="headerlink" title="静态链表的设计"></a>静态链表的设计</h4><p>首先，我们来解决一个最重要的问题，没有指针，怎么表示下一个元素的位置呢？</p><p>当时的人们想出来的办法便是，用数组的下标来代替指针。我们把这个数组的下标叫做游标。</p><p>第二个问题，当我们要往数组里插入元素时，如何确定数组里哪些分量未被使用，要插到哪个位置上呢？当我们删除一个元素的时候，要把这个删除后已经不存放数据的数组分量链接到哪里去，然后再次被使用呢？</p><p>解决办法是将所有未被使用过的以及被删除的分量用一个游标链成一个备用链表。<br>每当进行插入的使用便从备用链表上取得第一个结点作为待插入的新结点。<br>反之，在删除时将从链表中删除下来结点链接到备用链表上。</p><p>有没有觉得上面的描述特别熟悉，这实际上就是C语言里面malloc函数和free函数做的事情，在静态链表中，我们得自己实现，不过操作起来也不复杂。</p><p>最后一个问题，我们现在已经知道了我们把静态链表分为两部分，一部分存放数据，一部分不存放数据，我们称之为备用链表。那么我们如何标识这两部分呢？</p><p>解决办法，我们这里把数组下标为0位置的游标用来存放备用链表的第一个元素（也就是数组中第一个不存放数据的元素）的下标<br>我们这里把数组下标为1的位置游标用来存放第一个数据不为空的元素的下标<br>这里还有个细节就是我们把游标为0设为这两部分的结束。</p><h4 id="静态链表的定义"><a href="#静态链表的定义" class="headerlink" title="静态链表的定义"></a>静态链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ElemType char//这里我们使用的例子，采取字符</span><br><span class="line">#define MaxSize 10  //链表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;//存储的数据元素</span><br><span class="line">    int next;//游标，用来指示下一个数组分量的下标</span><br><span class="line">&#125;SLinkList[MaxSize];//静态链表</span><br></pre></td></tr></table></figure><h4 id="静态链表的操作"><a href="#静态链表的操作" class="headerlink" title="静态链表的操作"></a>静态链表的操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitSpace_SL(SLinkList space)&#123; </span><br><span class="line">  int i;</span><br><span class="line">  for (i = 2; i &lt; MaxSize-1; i++)&#123;</span><br><span class="line">      space[i].data=&#x27; &#x27;;</span><br><span class="line">      space[i].next=i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  space[0].next=2;</span><br><span class="line">  space[0].data=&#x27; &#x27;;</span><br><span class="line">  space[1].next=0;</span><br><span class="line">  space[1].data=&#x27; &#x27;;</span><br><span class="line">  space[MaxSize-1].next=0;</span><br><span class="line">  space[MaxSize-1].data=&#x27; &#x27;;</span><br><span class="line">  return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求表长-1"><a href="#求表长-1" class="headerlink" title="求表长"></a>求表长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int ListLength(SLinkList space)&#123;</span><br><span class="line">    int length=0;//空表长度为0</span><br><span class="line">    int i=space[1].next;//指向第一个有数据的位置</span><br><span class="line">    while (i!=0)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        i=space[i].next;//相当于指针的p=p-&gt;next</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的操作便是遍历表：<br>这里的i=space[i].next;相当于指针的p=p-&gt;next</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>尽管我们现在有了单链表，也不再会使用静态链表了，但是它的思想还是挺神奇的。<br>总的来说，它和单链表很像，插入删除不需要移动元素，所有我们称之为静态链表。<br>但是它不仅有单链表不能随机存取的缺点，也没有解决连续分配（数组）带来的表长难以确定的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 绪论</title>
      <link href="/post/146816a0.html"/>
      <url>/post/146816a0.html</url>
      
        <content type="html"><![CDATA[<p><strong>程序=数据结构+算法</strong><br><img src="/img/sujgxl.png" alt=""></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>数据 数据元素和数据项<br>数据对象：具有相同性质的数据元素的集合，是数据的一个子集<br>数据结构：相互之间存在一种或多种特定关系的数据元素的集合<br>数据类型：值的集合和定义在此集合上的一组操作的总称（原子类型和结构类型）<br>抽象数据类型（Abstract Data Type）：是抽象数据组织及与之相关的操作，数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。</p><h4 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h4><p>逻辑结构 存储结构 运算</p><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><p>线性结构：线性表、栈、队列、数组<br>非线性结构：集合、树、图</p><h5 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h5><p>指数据结构在计算机中的表示或映像。存储结构会影响数据运算的速度、存储空间分配的方便与否<br><strong>常用存储结构：</strong><br>顺序存储（下面三种为非顺序存储）<br>链式存储<br>索引存储：附加一个索引表（索引项=关键字+地址）<br>散列存储（哈希存储）：根据元素的关键字计算该元素的存储地址</p><h5 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h5><p>每个逻辑结构都有自己的基本的数据运算<br><strong>运算的定义是针对逻辑结构的，指出运算的功能</strong><br><strong>运算的实现是针对存储结构的，指出运算的具体操作步骤（即不同存储结构有着不同的实现）</strong></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="五个特性"><a href="#五个特性" class="headerlink" title="五个特性"></a>五个特性</h5><p>有穷性：算法必须是有穷的，而程序可以是无穷的<br>确定性：相同的输入只能得出相同的输出<br>可行性：能通过基本操作实现算法<br>输入<br>输出：算法处理的结果</p><h5 id="优秀算法的标准"><a href="#优秀算法的标准" class="headerlink" title="优秀算法的标准"></a>优秀算法的标准</h5><p>正确性<br>可读性<br>健壮性：能处理异常状况<br>高效率与低存储</p><h4 id="算法效率量度"><a href="#算法效率量度" class="headerlink" title="算法效率量度"></a>算法效率量度</h4><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”）<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>助记：常对幂指阶</strong><br><strong>一般只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层循环循环了几次</strong><br><strong>存在不同情况讨论时，平均时间复杂度=各个情况的循环次数与概率的加权和</strong><br>可以只考虑阶数高的部分<br>问题规模足够大时，常数项可以忽略<br>大O表示“同阶”，同等数量级<br>多项相加，只保留最高阶项；多项相乘都保留</p><h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p>空间开销(内存开销)与问题规模n的关系<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>普通程序</strong><br>内存装入程序代码和数据，一般程序代码与问题规模无关，而数据格式：<br>单一变量 $O(1)$<br>一维数组 $O(n)$<br>k维数组  $O(n^k)$<br><strong>递归程序：空间复杂度=递归调用的深度×数据格式</strong></p><h5 id="master公式"><a href="#master公式" class="headerlink" title="master公式"></a>master公式</h5><p>递归函数可表示成$T(N) = a <em> T(N/b) + O(N^d)$<br>$log_ba &gt; d时，时间复杂度为O(N^{log_ba})$<br>$log_ba &lt; d时，时间复杂度为O(N^d)$<br>$log_ba = d时，时间复杂度为O(N^d </em> log_2N)$</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百囚徒问题</title>
      <link href="/post/5a05dd41.html"/>
      <url>/post/5a05dd41.html</url>
      
        <content type="html"><![CDATA[<p>这两天偶然刷到了一个油管博主讲解百囚徒问题，感觉非常有意思，思路非常好，所以决定记录下来。<br>本文内容来自Eugene Curtin，Max Warshauer. The locker puzzle，The Mathematical Intelligencer（2006）：28-31<br>参考知乎 凉拌苦瓜 博主的文章：<a href="https://zhuanlan.zhihu.com/p/410614948">https://zhuanlan.zhihu.com/p/410614948</a></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在某个法制不健全的国家， 监狱中有编号1到100的100名死刑犯。监狱长给了他们最后一次机会：</p><p>一个房间里有100个抽屉，监狱长随意地把1到100这100个号码放入1号到100号抽屉中，每个抽屉一张。囚犯们逐个进入房间，每人可以任意打开50个抽屉，之后关上。如果每名囚犯都在这50个抽屉中发现了他的号码，那么所有的犯人都会被赦免；如果有人没有找到他的号码，那么所有的囚犯都会被处死。在第一个囚犯进入房间之前，囚犯们允许一起讨论开抽屉的“策略”，但一旦第一个囚犯进入房间，他们之间就被禁止交流。</p><h4 id="寻找思路"><a href="#寻找思路" class="headerlink" title="寻找思路"></a>寻找思路</h4><p>如果<strong>纯粹随机</strong>开抽屉，那么所有人都被赦免的概率只有：<br>$(\frac{1}{2})^{100}\approx0.000000000000000000000000000000008$<br>这个概率相当于两个人在地球上找到同一粒沙子的概率，根本不可能</p><p>寻找线索，以原文为框架，尽量给出了一个正向寻找最佳策略的思路。但要注意最佳策略未必本来就是一个被正向找到的过程。<br>为了简化问题，我们先把囚徒成员数简化为10个，每个成员可以检查5个抽屉，这时随机策略的成功概率也只有$(\frac{1}{2})^{10}=(\frac{1}{1024})$了。</p><p>提高成功概率的一个思路是给每个人分配固定的5个抽屉去检查，我们可以先来验证一下这个猜测。假设我们制定的策略1为：1-5号成员检查1-5号抽屉，6-10号成员检查6-10号抽屉。那么他们成功的概率等于1-5号码牌刚好被分配到了1-5号抽屉中，概率为：<br>$(\frac{5}{10})(\frac{4}{9})(\frac{3}{8})(\frac{2}{7})(\frac{1}{6})=(\frac{1}{242})$</p><p>该策略成功的概率比随机策略提高了，但成功的概率仍然比较小。值得注意的是，prisoner1如果在该策略中找到了自己的号码，则prisoner6找到自己号码的概率为5/9，prisoner2找到自己号码的概率为4/9，即prisoner1是否成功与其他成员是否成功具有相关性。</p><p>那么我们猜想，在策略中提高不同成员检查结果的相关性可能会提高团队的成功概率。理想的策略是如果prisoner1成功，那么其他所有成员也会成功，这时团队成功的概率为1/2，当然很难实现（实际上无法实现），但我们可以找到一个使prisoner1与一部分成员成功的概率相同的策略，并验证在该策略下团队成功的概率。</p><h4 id="完美策略方案-单向循环链表的运用"><a href="#完美策略方案-单向循环链表的运用" class="headerlink" title="完美策略方案 单向循环链表的运用"></a>完美策略方案 单向循环链表的运用</h4><p>每个囚徒的策略，就是首先打开与自己编号相同的抽屉，从中取出号码牌，并打开号码牌所对应的抽屉。之后，重复此过程，直到找到自己的号码牌，或者50个抽屉的机会用完。 <strong>实际就是看抽屉是否存在大于51个元素的链表，如果都小于50，那么所有囚徒一定都可以存活。</strong><br><img src="/img/loop1.png" alt="loop"><br>例如，29号囚徒首先打开了29号抽屉，里面放着51号的号码牌，于是他打开51号抽屉，里面放着18号的号码牌，于是他打开18号的抽屉，里面放着29号的号码牌，他完成了任务。</p><h5 id="计算概率"><a href="#计算概率" class="headerlink" title="计算概率"></a>计算概率</h5><p>比起计算“所有循环链表的长度不超过50”的概率，“有一个循环链表长度超过50”的概率更容易计算。因为“有一个循环链表的长度是51”和“有一个循环链表的长度是52”之类的事件是彼此互斥的（循环链表的长度总和是100，所以如果有大于50的链表，也只会存在一个），所以总概率就是它们的和。而对于$m&gt;=51$，只需先选出$m$个元素，将它们构成一个环，之后再将剩下的元素随机打乱即可唯一地得到一种分布。</p><p>具体地说，所有形成长度为m环的映射种类为：<br>$C^m_{100}(m-1)!(100-m)!=100!/m$</p><p>全排列个数为$100!$  </p><p>因此这个概率等于$P(m)=1/m$ </p><p>综上，所有圆环长度不超过50的概率等于<br>$P=1-\sum_{m=51}^{100}\frac{1}{m}\approx0.312$</p><p>这个概率就是囚徒被释放的概率。当囚徒人数趋于无穷大时，概率趋向于：<br>$P=1-\sum_{m=N+1}^{2N}\frac{1}{m}\rightarrow1-ln2$  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不那么严密地说，这个策略的关键点在于让所有囚徒尽可能地一起成功或者一起失败，因此所有玩家的任务不再是独立的，一旦有一个人成功，他所翻出的号码牌对应的人也一定会成功，同时只要有一半的人成功，剩下的人都一定成功。</p><p>通过计算可得，在之前所有人都成功的条件下，下一个人成功的概率依次为<br>50%,75.25%,89.26%,95.63%,…..</p><p>这个策略被证明最优。</p><h5 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h5><p>我觉得这个问题精彩在于对于概率本质的理解，收获很多，也再一次感受到了数学的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex基础知识</title>
      <link href="/post/3acd2553.html"/>
      <url>/post/3acd2553.html</url>
      
        <content type="html"><![CDATA[<h4 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h4><p>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>总结：<strong>vuex是一个集中式管理组件依赖的共享数据的工具，可以解决不同组件数据共享问题。</strong></p><h4 id="vue的引入"><a href="#vue的引入" class="headerlink" title="vue的引入"></a>vue的引入</h4><p>可以在使用脚手架手动创建项目的时候就选中vuex，会自动引入。或者:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save    //安装</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27; </span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//注册vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数 </span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure></p><h4 id="vuex核心模块"><a href="#vuex核心模块" class="headerlink" title="vuex核心模块"></a>vuex核心模块</h4><p>vuex核心: state，mutations，actions，getters，modules<br><img src="/img/vuex.png" alt="vuex"></p><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><p><strong>state是放置所有公共状态的属性，如果你有一个公共状态数据，你只需要定义在 state对象中。下面就是定义了一个存储数字的count。</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    // 管理数据</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>我们怎样在其他组件使用state里面的值呢？<br>主要是两种方式：<br>1.原始形式<br>组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过this.$store.state.count使用 --&gt;</span><br><span class="line">&lt;!-- 使用插值表达式获取，省略this --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>2.辅助函数 mapState<br>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapState&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">//利用展开运算符将导出的状态映射给计算属性</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后直接当作计算属性使用:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用插值表达式获取 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>我们怎么修改count的值呢？</p><h5 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h5><p><strong>使用mutations修改state里面的数据。state数据的修改只能通过mutations，并且一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步。</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">//定义一个让count增加的方法，每次增加多少要传递参数</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">//定义一个让count减少的方法，每次减少多少要传递参数，以对象的形式传递。</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>mutations里面存放修改state数据的方法。方法的第一个参数是store里面的state属性。我们可以在state上面找到我们存放的数据；方法的第二个参数是payload（参数名字也可以自己重命名），载荷，调用mutaiions的时候，可以传递参数，任何形式的参数都可以。官方推荐大多数情况下payload应该是一个对象，因为包含多个字段时使用对象形式更清晰已读。</strong></p><p>然后我们在其他组件中使用：<br>1.原始形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;add&#x27;,2)&quot;&gt;点击每次count增加2&lt;/div&gt;</span><br><span class="line">&lt;div @click=&quot;$store.commit(&#x27;sub&#x27;,&#123;num:1&#125;)&quot;&gt;点击每次count减少1。参数以对象形式传递&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>2.辅助函数  mapMutations<br>和mapState很像，把位于mutations中的方法提取了出来，我们可以将它导入。mapMutations将组件中的 methods 映射为 store.commit调用。用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState, mapMutations&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">//然后当作普通方法使用</span><br><span class="line">    ...mapMutations([&#x27;add&#x27;, &#x27;sub&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例如</span><br><span class="line"> &lt;div @click=&quot;add(2)&quot;&gt;+&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h5 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h5><p><strong>state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作。比如异步请求数据和定时器等操作。官方介绍：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。所以我们在addAsync 中使用context.commit(‘add’, num)使用了mutations的add方法。</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改state的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">//一秒后增加count的值</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>在其他组件中使用：<br>1.原始形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.dispatch(&#x27;addAsync&#x27;,2)&quot;&gt;点击后等待一秒再增加2&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>2.辅助函数  mapActions<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    //当作普通方法调用就好</span><br><span class="line">    ...mapActions([&#x27;addAsync&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h5><p><strong>有时我们还需要从state中派生出一些状态，这些状态是依赖state的，然后我们就会用到getters</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改statement的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  getters: &#123;</span><br><span class="line">    handeleCount: (state) =&gt; &#123;</span><br><span class="line">      return `$&#123;state.count&#125;只小鸡`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>在其他组件中使用：<br>1.原始形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;$store.getters.handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><br>2.辅助函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">   //然后当作计算属性使用即可</span><br><span class="line">    ...mapGetters([&#x27;handeleCount&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//例如</span><br><span class="line">&lt;div&gt;&#123;&#123;handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>1.state定义数据，使用$store.state获取<br>2.mutations修改数据，同步操作，使用$store.commit提交修改。<br>3.actions主要用于异步操作，通过mutations间接修改state数据，使用$store.dispatch提交修改。<br>4.getters主要用于派生依赖state的数据，使用$store.getters获取</strong><br>此文章介绍的是vuex最基础的使用，更多用法和更详细的介绍指路官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次型</title>
      <link href="/post/33cf95bf.html"/>
      <url>/post/33cf95bf.html</url>
      
        <content type="html"><![CDATA[<h4 id="二次型基本概念"><a href="#二次型基本概念" class="headerlink" title="二次型基本概念"></a>二次型基本概念</h4><p>对于二次齐多项式:<br>$f(x1,x2,x3,…,xn)=a<em>{11}x_1^2+2a</em>{12}x<em>1x_3+…+2a</em>{1n}x<em>1x_n+…+…+a</em>{nn}x<em>n^2$<br>可以写成矩阵形式：<br>$\left[\begin{array}{c}x_1&amp;x_2&amp;…x_n\end{array}\right]<br>\left[\begin{array}{cc}a</em>{11}&amp;a<em>{12}&amp;…a</em>{1n} \\<br>a<em>{21}&amp;a</em>{22}&amp;…a<em>{2n}  \\<br>a</em>{n1}&amp;a<em>{n2}&amp;…a</em>{nn}\end{array}\right]<br>\left[\begin{array}{}x_1  \\<br>x_2  \\<br>…  \\<br>x_n\end{array}\right]=x^TAx$</p><h4 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h4><p>标准型与规范型<br>标准型：没有混合项   规范型：平方项系数只有1，-1, 0<br>若存在可逆矩阵C使得C^TAC=B,则称A与B合同<br>二次型化为标准型后得到的$\Lambda$与A合同并且其对角线的值是A的特征值</p><h4 id="变换二次型为标准型的方法"><a href="#变换二次型为标准型的方法" class="headerlink" title="变换二次型为标准型的方法"></a>变换二次型为标准型的方法</h4><p>配方法与正交法</p><h5 id="正交法"><a href="#正交法" class="headerlink" title="正交法"></a>正交法</h5><ol><li>写出二次型矩阵A</li><li>求出A的特征值</li><li>求出对应特征向量</li><li>将特征向量正交化，组合到一起即可得到正交矩阵Q $x=Qy$<h4 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h4>3个重要的充要条件：</li><li>正惯性指数$p=n$</li><li>特征值都大于0</li><li>全部顺序主子式大于</li></ol><p>必要条件：A的行列式|A|&gt;0,所有主对角线元素大于0</p><hr><p>考研复习的进度有点慢，自己要抓紧了<br>实习生活还挺舒服的，之前学的前端开发知识有了用武之地<br>千里之行始于这一篇blog，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建站感想</title>
      <link href="/post/134cee24.html"/>
      <url>/post/134cee24.html</url>
      
        <content type="html"><![CDATA[<hr><p>blog正式成型是2022年6月28号，正值繁忙的小学期，也离考研仅5个月了，希望自己能够越来越好吧。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better than better</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
