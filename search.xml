<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6.5840/6.824 Lab4 KVRaft</title>
      <link href="/post/3b16a234.html"/>
      <url>/post/3b16a234.html</url>
      
        <content type="html"><![CDATA[<p>Lab 链接：<a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html</a></p><p>lab4是实现一个基于raft的k/v数据库，相比于lab2，lab4会存在多个server，因此需要raft协议来实现一致性。为了保证一致性，我们还需要lab2中的思想，利用rpc的序列号来判断重复请求，保证重复的Put/Append请求只在第一次出现时应用到状态机。</p><p>具体而言，系统的整体运行流程如下：</p><ul><li>客户端将请求发送给Leader</li><li>Leader的应用层(K/V数据库)将操作向下发送到自己的Raft层</li><li>Leader的Raft层将操作发送到多个副本Server</li><li>副本回复Leader日志拷贝成功</li><li>Leader的Raft收到过半回复向上层应用层服务提示操作可执行</li><li>应用层真正执行操作并告知Client结果</li><li>其余副本也需要想自己的应用层应用已提交的日志</li></ul><h1>4A 无快照的KVRaft</h1><p>4A是实现无快照的K/Vserver，我们延续在lab2中的基本设计，Rpc结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type PutAppendArgs struct &#123;</span><br><span class="line">Key   string</span><br><span class="line">Value string</span><br><span class="line">ClientId int64</span><br><span class="line">RpcSeq   uint64</span><br><span class="line">&#125;</span><br><span class="line">type GetArgs struct &#123;</span><br><span class="line">Key string</span><br><span class="line">ClientId int64</span><br><span class="line">RpcSeq   uint64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时添加一些用于判断的错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">OK                 = &quot;OK&quot;</span><br><span class="line">ErrNoKey           = &quot;ErrNoKey&quot;</span><br><span class="line">ErrWrongLeader     = &quot;ErrWrongLeader&quot;</span><br><span class="line">ErrHandleOpTimeout = &quot;ErrHandleOpTimeout&quot;</span><br><span class="line">ErrChanClosed      = &quot;ErrChanClosed&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于Client端，与lab2类似，我们不断轮询Server即可，不过由于Raft协议，我们需要增加一个leaderId，客户端只能与leader进行访问，代码比较简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (ck *Clerk) PutAppend(key string, value string, op string) &#123;</span><br><span class="line">// You will have to modify this function.</span><br><span class="line">args := &amp;PutAppendArgs&#123;Key: key, Value: value, Op: op, Seq: ck.GetSeq(), Identifier: ck.identifier&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">reply := &amp;PutAppendReply&#123;&#125;</span><br><span class="line">ok := ck.servers[ck.leaderId].Call(&quot;KVServer.PutAppend&quot;, args, reply)</span><br><span class="line">if !ok || reply.Err == ErrNotLeader || reply.Err == ErrLeaderOutDated &#123;</span><br><span class="line">ck.leaderId += 1</span><br><span class="line">ck.leaderId %= len(ck.servers)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch reply.Err &#123;</span><br><span class="line">case ErrChanClose:</span><br><span class="line">continue</span><br><span class="line">case ErrHandleOpTimeOut:</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>Server</strong>端，我们知道每一个请求信息通过接口Start交付给Raft层后，必须在raft层commit后才能进行应用，这之间存在一定的等待时间。因此，必然需要一个协程不断接收raft层的commit日志来进行一系列的处理，包括重复Rpc的判断、数据库操作等。</p><p>Server结构体如下：在lab2的基础上我们增加了一个raft当中的index 到 chan LastRpc的map 来记录等待commit信息的RPC handler(Get、Put等操作)的通道。<br>而在LastRpc中增加一个ApplyTerm，记录commit被apply时的term, 因为其可能与Start相比发生了变化, 需要将这一信息返回给客户端。<br>因此LastRpc不再仅仅作为上一次RPC的记录，而是作为已发送过的Rpc的记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type LastRpc struct &#123;</span><br><span class="line">LastRpcSeq uint64</span><br><span class="line">Err        Err</span><br><span class="line">Value      string</span><br><span class="line">ApplyTerm  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KVServer struct &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">me      int</span><br><span class="line">rf      *raft.Raft</span><br><span class="line">applyCh chan raft.ApplyMsg</span><br><span class="line">dead    int32 // set by Kill()</span><br><span class="line"></span><br><span class="line">maxraftstate int // snapshot if log grows this big</span><br><span class="line"></span><br><span class="line">// Your definitions here.</span><br><span class="line">kvMap   map[string]string</span><br><span class="line">lastRpc map[int64]LastRpc // clientId -&gt; lastRpcSeq</span><br><span class="line">waiCh   map[int]chan LastRpc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get、Put等Rpc Handler的设计结构都比较简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) Put(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">// Your code here.</span><br><span class="line">opArgs := &amp;Op&#123;OpType: OpPut, RpcSeq: args.RpcSeq, Key: args.Key, Value: args.Value, ClientId: args.ClientId&#125;</span><br><span class="line"></span><br><span class="line">res := kv.OpHandler(opArgs)</span><br><span class="line">reply.Err = res.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get、Put和Append都将请求封装成Op结构体，然后调用OpHandler函数进行处理。OpHandler利用通道等待ApplyHandler处理完消息后返回结果给客户端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) OpHandler(opArgs *Op) (res LastRpc) &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line">if rpc, ok := kv.lastRpc[opArgs.ClientId]; ok &amp;&amp; rpc.LastRpcSeq == opArgs.RpcSeq &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">return rpc</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">startIndex, startTerm, isLeader := kv.rf.Start(*opArgs)</span><br><span class="line">if !isLeader &#123;</span><br><span class="line">return LastRpc&#123;Err: ErrWrongLeader, Value: &quot;&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kv.mu.Lock()</span><br><span class="line">newCh := make(chan LastRpc)</span><br><span class="line">kv.waiCh[startIndex] = newCh</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line">delete(kv.waiCh, startIndex)</span><br><span class="line">close(newCh)</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-time.After(HandleOpTimeout):</span><br><span class="line">res.Err = ErrHandleOpTimeout</span><br><span class="line">return</span><br><span class="line">case msg, success := &lt;-newCh:</span><br><span class="line">if success &amp;&amp; msg.ApplyTerm == startTerm &#123;</span><br><span class="line">res = msg</span><br><span class="line">return</span><br><span class="line">&#125; else if !success &#123;</span><br><span class="line">res.Err = ErrChanClosed</span><br><span class="line">return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">res.Err = ErrWrongLeader</span><br><span class="line">res.Value = &quot;&quot;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplyHandler需要不断等待kv.applyCh发来新的已commited并且可以apply的消息：</p><ul><li>判断log请求的ClientId和RpcSeq是否在历史记录lastRpc中是否存在, 如果存在就直接返回历史记录</li><li>不存在就需要应用到状态机, 并更新历史记录</li><li>如果log请求的CommandIndex对应的key在waiCh中存在, 表面当前节点可能是一个Leader, 需要将结果发送给RPC handler。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) ApplyHandler() &#123;</span><br><span class="line">for !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line">if log.CommandValid &#123;</span><br><span class="line">op := log.Command.(Op)</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"></span><br><span class="line">needApply := false</span><br><span class="line">var res LastRpc</span><br><span class="line">if lastrpc, ok := kv.lastRpc[op.ClientId]; ok &#123;</span><br><span class="line">if lastrpc.LastRpcSeq == op.RpcSeq &#123;</span><br><span class="line">res = lastrpc</span><br><span class="line">&#125; else if lastrpc.LastRpcSeq &lt; op.RpcSeq &#123;</span><br><span class="line">needApply = true</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">needApply = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if needApply &#123;</span><br><span class="line">res = kv.KvMapExecute(&amp;op)</span><br><span class="line">res.ApplyTerm = log.SnapshotTerm</span><br><span class="line">kv.lastRpc[op.ClientId] = res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch, ok := kv.waiCh[log.CommandIndex]</span><br><span class="line">if !ok &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">res.ApplyTerm = log.SnapshotTerm</span><br><span class="line">ch &lt;- res</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kv *KVServer) KvMapExecute(op *Op) (res LastRpc) &#123;</span><br><span class="line">res.LastRpcSeq = op.RpcSeq</span><br><span class="line">switch op.OpType &#123;</span><br><span class="line">case OpGet:</span><br><span class="line">value, ok := kv.kvMap[op.Key]</span><br><span class="line">if ok &#123;</span><br><span class="line">res.Value = value</span><br><span class="line">return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">res.Err = ErrNoKey</span><br><span class="line">res.Value = &quot;&quot;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">case OpPut:</span><br><span class="line">kv.kvMap[op.Key] = op.Value</span><br><span class="line">return</span><br><span class="line">case OpAppend:</span><br><span class="line">value, ok := kv.kvMap[op.Key]</span><br><span class="line">if ok &#123;</span><br><span class="line">kv.kvMap[op.Key] = value + op.Value</span><br><span class="line">return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">kv.kvMap[op.Key] = op.Value</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：<br><img src="/img/kvraft4Ares.png" alt=""></p><h1>4B 有快照的KVRaft</h1><p>lab 4B是在4A的基础上实现快照。当底层raft的log过大时生成快照并截断日志，并将快照持久化存储到本地。</p><p>实际逻辑并不复杂，但是正如lab中所说的一样，测试时raft的一些边界情况和小细节会暴露出来，进而需要调试很久。</p><p>快照中应该包括内存的数据库、每个clerk序列号的记录信息、同时也应该记录最近一次应用到状态机的日志索引, 凡是低于这个索引的日志都是包含在快照中的。</p><p>因此在server结构体中添加以下成员:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">persister    *raft.Persister</span><br><span class="line">lastApplied  int</span><br></pre></td></tr></table></figure><p>生成和加载快照的函数防止raft中的写即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) SnapShot() []byte &#123;</span><br><span class="line">w := new(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line"></span><br><span class="line">e.Encode(kv.kvMap)</span><br><span class="line">e.Encode(kv.lastRpc)</span><br><span class="line"></span><br><span class="line">snapshot := w.Bytes()</span><br><span class="line">return snapshot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (kv *KVServer) ReadSnapShot(snapShot []byte) &#123;</span><br><span class="line">if len(snapShot) == 0 || snapShot == nil &#123;</span><br><span class="line">// DPrintf(&quot;server %v LoadSnapShot: snapShot is nil&quot;, kv.me)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r := bytes.NewBuffer(snapShot)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line"></span><br><span class="line">kvmap := make(map[string]string)</span><br><span class="line">lastrpc := make(map[int64]LastRpc)</span><br><span class="line"></span><br><span class="line">if d.Decode(&amp;kvmap) != nil || d.Decode(&amp;lastrpc) != nil &#123;</span><br><span class="line">// DPrintf(&quot;server %v LoadSnapShot: decode error&quot;, kv.me)s</span><br><span class="line">&#125; else &#123;</span><br><span class="line">kv.kvMap = kvmap</span><br><span class="line">kv.lastRpc = lastrpc</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候我们需要生成快照呢？即当我们收到log进行判断即可,低于lastApplied索引的日志都是包含在快照中d ,因此我们直接跳过即可，对于kv.maxraftstate != -1 &amp;&amp; kv.persister.RaftStateSize() &gt;= kv.maxraftstate，则表示需要生成日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) ApplyHandler() &#123;</span><br><span class="line">...</span><br><span class="line">if log.CommandIndex &lt;= kv.lastApplied &#123;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">if kv.maxraftstate != -1 &amp;&amp; kv.persister.RaftStateSize() &gt;= kv.maxraftstate &#123;</span><br><span class="line">snapShot := kv.SnapShot()</span><br><span class="line">kv.rf.Snapshot(log.CommandIndex, snapShot)</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么时候加载日志呢？则是当ApplyHandler从通道收到的日志信息表明这是一个快照时，则需要加载日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) ApplyHandler() &#123;</span><br><span class="line">for !kv.killed() &#123;</span><br><span class="line">log := &lt;-kv.applyCh</span><br><span class="line">if log.CommandValid &#123;</span><br><span class="line">            ...</span><br><span class="line">&#125; else if log.SnapshotValid &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line">if log.SnapshotIndex &gt;= kv.lastApplied &#123;</span><br><span class="line">kv.ReadSnapShot(log.Snapshot)</span><br><span class="line">kv.lastApplied = log.SnapshotIndex</span><br><span class="line">&#125;</span><br><span class="line">kv.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>K/V server部分的代码就完成了，但是不出意外就报错了，在测试时出现了<code>logs were not trimmed</code>的错误，在检测了没有死锁和持锁接发通道消息等问题后，发现应该是raft层无法承受高并发而导致clerk无限重发Rpc，因此我们要减少raft发送Rpc的数量并且让clerk在失败时等待一会</p><p>在start中，让Raft等待一段时间，积累多个请求后一次发送，避免发送过多的Rpc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class="line">...</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer func() &#123;</span><br><span class="line">rf.ResetHeartTimer(15)</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少Raft中发送InstallSnapshot RPC的数量，原来在handleAppendEntries中，如果发现follower需要的日志项被快照截断则立即调用协程发送快照。我们将对这种情况都做一定修改，让其仅设置rf.nextIndex[server] = rf.lastIncludedIndex，让leader在下一次心跳时再调用协程发送快照。</p><p>除此之外我们让clerk先sleep再重试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func (ck *Clerk) Get(key string) string &#123;</span><br><span class="line">...</span><br><span class="line">for &#123;</span><br><span class="line">...</span><br><span class="line">if !ok || getReply.Err == ErrWrongLeader &#123;</span><br><span class="line">ck.leaderId = (ck.leaderId + 1) % len(ck.servers) // try next server if not ok or wrong leader</span><br><span class="line">time.Sleep(50 * time.Millisecond)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">switch getReply.Err &#123;</span><br><span class="line">case ErrChanClosed:</span><br><span class="line">time.Sleep(time.Microsecond * 50)</span><br><span class="line">continue</span><br><span class="line">case ErrHandleOpTimeout:</span><br><span class="line">time.Sleep(time.Microsecond * 50)</span><br><span class="line">continue</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下:<br><img src="/img/kvraft4bo.png" alt=""><br><img src="/img/kvraft4Bres.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 6.5840/6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.5840/6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840/6.824 Lab3 Raft</title>
      <link href="/post/271158e5.html"/>
      <url>/post/271158e5.html</url>
      
        <content type="html"><![CDATA[<p>Lab 链接：<a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a><br>Raft 原论文：<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf</a></p><p>Raft这个lab的难度相比较与前两个提高了很多，由于我之前接触过这个lab，所以上手还是很快的，lab3主要有4个子任务，我也会分任务进行记载。</p><p>Raft 是一种分布式一致性协议，旨在解决分布式系统中数据一致性和容错性的问题。为此，Raft 会首先在系统内自动选出一个 Leader 节点，并由这个 Leader 节点负责维护系统内所有节点上的操作日志的一致性。Leader 节点将负责接收用户的请求，将用户请求中携带的操作日志 replicate 到系统内的各个节点上，并告诉系统内各个节点将操作日志中的操作序列应用到各个节点中的状态机上。</p><p>更详细的细节会在后续实现当中说明。</p><hr><h1>3A Leader election</h1><p>Lab 3A要求我们实现Leader选取。在Raft中，Server分为三种状态：<code>Leader 、Follower 、 Candidate</code>。初始情况下都为 Follower 。三种状态的转变流程如图所示：<br><img src="/img/raft.png" alt="Raft状态转换图"></p><p>我们需要做的就是借助rpc通信实现这个过程</p><p>对于具体的结构设计，raft论文已经给我们指出了，如下所示：<br><img src="/img/raftstrc.png" alt="raftstrc"></p><p>阅读论文的第5节，我们可以知道，Leader选取的过程如下：</p><ul><li>初始情况下，所有节点均为Follower，当心跳检测超时时，Follower会转换为Candidate状态，并开始选举</li><li>每一个收到投票请求的Server，判断rpc中参数是否符合上图figure2的要求，如果符合，则投票，否则拒绝投票</li><li>如果Server得到了超过半数的投票，则Server成为Leader，并向其他Server发送心跳，保持Leader状态</li><li>若超时时间内无新的Leader产生, 再进行下一轮投票, 为了避免出现论文中所说的选举几轮都无Leader产生的情况, 应当给不同Server的投票超时设定随机值</li></ul><p>当然，在实现过程中还有许多细节，下面在代码逻辑中详细给出</p><h2 id="3A-代码逻辑">3A 代码逻辑</h2><p>对于Raft结构体、RequestVote以及AppendEntrys的结构，我们参照Figure2实现即可，除此之外对于Raft结构体，我还添加了下列元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   state           int</span><br><span class="line">electionTimeout time.Duration</span><br><span class="line">timeStamp       time.Time</span><br><span class="line">validVoteCount  int</span><br></pre></td></tr></table></figure><p><code>state</code>即服务器状态；<code>electionTimeout</code>为选举超时时间，即为每个Server设定一个不同的重新发起选取Leader的超时时间；<code>timeStamp</code>为当前时间，以此与<code>electionTimeout</code>比较来确定是否超时；<code>validVoteCount</code>为当前有效投票数</p><hr><p>Lab已告诉我们在ticker中检测是否需要发起选举我们利用time.Since()来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) ticker() &#123;</span><br><span class="line">for rf.killed() == false &#123;</span><br><span class="line"></span><br><span class="line">// Your code here (3A)</span><br><span class="line">// Check if a leader election should be started.</span><br><span class="line"></span><br><span class="line">// pause for a random amount of time between 50 and 350</span><br><span class="line">// milliseconds.</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">if rf.state != Leader &amp;&amp; time.Since(rf.timeStamp) &gt; rf.electionTimeout &#123;</span><br><span class="line">go rf.election()</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">ms := 50 + (rand.Int63() % 300)</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果超时，就发起一个协程进行选举。在选举函数中，我们需要更新Server的自身状态，并且异步的向其他server发起投票请求，即<code>RequetVote RPC</code>。下面函数中的collectVote是对sendRequetVote的封装，以更简单的实现异步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) election() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">rf.state = Candidate</span><br><span class="line">rf.currentTerm++          // increment current term</span><br><span class="line">rf.votedFor = rf.me       // vote for self</span><br><span class="line">rf.validVoteCount = 1     // count the vote for self</span><br><span class="line">rf.timeStamp = time.Now() // update timeStamp</span><br><span class="line"></span><br><span class="line">args := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: len(rf.log) - 1,</span><br><span class="line">LastLogTerm:  rf.log[len(rf.log)-1].Term,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">// send RequestVote RPCs to all other servers concurrently.</span><br><span class="line">for server, _ := range rf.peers &#123;</span><br><span class="line">if server != rf.me &#123;</span><br><span class="line">go rf.collectVote(server, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>collectVote</code>发起投票请求，并且处理投票结果。<br><code>collectVote</code>调用<code>sendRequestVote</code>发送投票请求</p><ul><li>如果RPC调用失败, 直接返回</li><li>如果server回复了更大的term, 表示当前这一轮的投票已经废弃, 按照回复更新term、自身角色和投票数据，返回false</li><li>如果发现当前投票已经结束了(即票数过半), 返回</li><li>否则按照投票结果对自身票数自增，自增后如果票数过半, 检查状态后转换自身角色为Leader，并开始发送心跳<br><strong>特别注意</strong>，在转化角色前必须先检测自己是否为Follower，因为collectVote也是与RPC心跳的handler并发的, 可能新的Leader已经产生, 并通过心跳改变了自己的role为Follower, 如果不检查的话, 将导致多个Leader的存在</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) collectVote(server int, args *RequestVoteArgs) &#123;</span><br><span class="line">reply := RequestVoteReply&#123;&#125;</span><br><span class="line">ok := rf.sendRequestVote(server, args, &amp;reply)</span><br><span class="line">if !ok &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">if args.Term != rf.currentTerm &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.votedFor = -1</span><br><span class="line">rf.state = Follower // convert to follower if term is greater than current term.</span><br><span class="line">&#125;</span><br><span class="line">if !reply.VoteGranted &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.validVoteCount++</span><br><span class="line">if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">if rf.state == Follower &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rf.state = Leader     // become leader.</span><br><span class="line">go rf.sendHeartbeat() // start sending heartbeat.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>投票的接收方即RequestVote函数则严格按照Figure 2进行设计:</p><ul><li>如果args.Term &lt; rf.currentTerm, 直接拒绝投票, 并告知更新的投票</li><li>如果args.Term &gt; rf.currentTerm, <strong>更新rf.votedFor = -1, 之前轮次的投票作废</strong>，令 rf.currentTerm = args.Term ，解决孤立节点Term过大的情况</li><li>如果满足下面两个情况之一, 投票, 然后更新currentTerm, votedFor,role, timeStamp</li><li><ul><li>args.LastLogTerm &gt; rf.log[len(rf.log)-1].Term</li></ul></li><li><ul><li>args.LastLogTerm == rf.log[len(rf.log)-1].Term &amp;&amp; args.LastLogIndex &gt;= len(rf.log)-1, 并且未投票或者投票对象是自己</li></ul></li><li>其他情况不投票<br>除此之外，记得更新时间戳</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// example RequestVote RPC handler.</span><br><span class="line">func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">// Your code here (3A, 3B).</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.VoteGranted = false</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">// new term</span><br><span class="line">rf.votedFor = -1</span><br><span class="line">rf.currentTerm = args.Term // solve the problem about Orphaned node</span><br><span class="line">rf.state = Follower</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if rf.votedFor == -1 || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">if args.LastLogTerm &gt; rf.log[len(rf.log)-1].Term ||</span><br><span class="line">(args.LastLogTerm == rf.log[len(rf.log)-1].Term &amp;&amp; args.LastLogIndex &gt;= len(rf.log)-1) &#123;</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.VoteGranted = true</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.VoteGranted = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>leader产生后就需要立即发送心跳rpc，不断调用sendAppendEntries函数，发送空的Entries<br>需要注意的是，在处理接受到的返回信息时，如果args.Term != rf.currentTerm，说明函数调用间隙字段被修改了，需要直接返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) sendHeartbeat() &#123;</span><br><span class="line">for rf.killed() == false &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">if rf.state != Leader &#123; // stop sending heartbeat if not leader.</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">for server := range rf.peers &#123;</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: 0,</span><br><span class="line">PrevLogTerm:  0,</span><br><span class="line">Entries:      nil,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">if server != rf.me &#123;</span><br><span class="line">go rf.handleHeartbeat(server, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Duration(heartBeatTimeout))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rf *Raft) handleHeartbeat(server int, args *AppendEntriesArgs) &#123;</span><br><span class="line">reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">ok := rf.sendAppendEntries(server, args, reply)</span><br><span class="line">if !ok &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">if args.Term != rf.currentTerm &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = reply.Term // update currentTerm.</span><br><span class="line">rf.votedFor = -1</span><br><span class="line">rf.state = Follower // become follower.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于AppendEntries函数，同样严格按照Figure 2实现即可</p><ul><li>如果term &lt; currentTerm表示这是一个旧leader的消息, 告知其更新的term并返回false</li><li>如果args.Term &gt; currentTerm, 更新currentTerm, 并转换为follower状态,同时要记得令rf.votedFor = -1，终止其他不应该继续的投票</li><li>如果自己的日志中prevLogIndex处不存在有效的日志, 或者与prevLogTerm不匹配, 返回false</li><li>如果现存的日志与请求的信息冲突, 删除冲突的日志(这一部分不涉及)</li><li>添加日志(这一部分不涉及)</li><li>如果leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)<br>同时, 收到AppendEntries需要更新对应的时间戳timeStamp</li></ul><hr><p><img src="/img/raft3Ares.png" alt=""></p><hr><h1>3B Log</h1><p>3B 主要是实现日志复制以及其引出的选举限制</p><p>日志复制核心是通过<code>AppendEntries RPC</code>中的PrevLogIndex、PrevLogTerm来校验Follower的日志是否与Leader一致，如果不一致，则需要通过AppenEntriesRPc来达到一致。前两者的值由nextIndex决定。具体细节边讲代码边讲</p><p>心跳Rpc和正常的AppendEntries的区别仅在于是否携带Logs，因此我们在2A的代码的基础上改变心跳Rpc的代码即可</p><h2 id="3B代码逻辑">3B代码逻辑</h2><p>在<code>sendHeartbeat()</code>函数中，我们需要为每个server单独构建<code>AppendEntriesArgs</code>，有以下要点：</p><ul><li>PrevLogIndex = rf.nextIndex[i] - 1 即follower最后一个有效日志</li><li>PrevLogTerm = rf.log[rf.nextIndex[i]-1].Term 即follower最后一个有效日志的任期<br>这两者用于Follower判断自己的日志是否合法</li><li>如果len(rf.log)-1 &gt;= rf.nextIndex[i]，则表明有新的log需要发送，需要携带Logs，否则就发送一个空log作为心跳rpc</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">for server := range rf.peers &#123;</span><br><span class="line">if server == rf.me &#123; // skip self</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: rf.nextIndex[server] - 1,</span><br><span class="line">PrevLogTerm:  rf.log[rf.nextIndex[server]-1].Term,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">if len(rf.log)-1 &gt;= rf.nextIndex[server] &#123; // send log entries.</span><br><span class="line">args.Entries = rf.log[rf.nextIndex[server]:] // send remaining logs.</span><br><span class="line">&#125; else &#123; // send heartbeat.</span><br><span class="line">args.Entries = make([]LogEntry, 0) // send empty log entries.</span><br><span class="line">&#125;</span><br><span class="line">go rf.handleAppendEntries(server, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对AppendEntries返回的信息的处理中，<code>handleAppendEntries(server, args)</code>，在success时，我们需要更新rf.nextIndex[server]和rf.matchIndex[server]，判断是否可以commit，更改commitIndex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if reply.Success &#123;</span><br><span class="line">rf.matchIndex[server] = args.PrevLogIndex + len(args.Entries) // update matchIndex.</span><br><span class="line">rf.nextIndex[server] = rf.matchIndex[server] + 1              // update nextIndex.</span><br><span class="line"></span><br><span class="line">for N := len(rf.log) - 1; N &gt; rf.commitIndex; N-- &#123; // update commitIndex</span><br><span class="line">count := 1</span><br><span class="line">for peer := range rf.peers &#123;</span><br><span class="line">if peer != rf.me &amp;&amp; rf.matchIndex[peer] &gt;= N &amp;&amp; rf.log[N].Term == rf.currentTerm &#123; // check if majority of matchIndex is greater than or equal to N.</span><br><span class="line">count++ // count the number of servers that have log entry at index N.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if count &gt; len(rf.peers)/2 &#123; // if majority of servers have log entry at index N.</span><br><span class="line">rf.commitIndex = N // update commitIndex.</span><br><span class="line">break              // break the loop.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.condApply.Signal()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>handleAppendEntries(server, args)</code>还有一个要点，在follower的日志和leader的不同时，需要leader调整nextIndex重试，这里使用6.5840有提到的快速回滚的方法，在AppendEntriesReply中添加三个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XTerm: Follower中与Leader冲突的Log对应的Term, 如果Follower在对应位置没有Log将其设置为-1</span><br><span class="line">XIndex: Follower中，对应Term为XTerm的第一条Log条目的索引</span><br><span class="line">XLen: 空白的Log槽位数, 如果Follower在对应位置没有Log，那么XTerm设置为-1,在实际代码中，我们将其设定为Fowller的log长度</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if reply.Term == rf.currentTerm &amp;&amp; rf.state == Leader &#123; // if the follower&#x27;s log is inconsistent with the leader&#x27;s log.</span><br><span class="line">// quick rollback</span><br><span class="line">if reply.XTerm == -1 &#123;</span><br><span class="line">rf.nextIndex[server] = reply.XLen</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">index := rf.nextIndex[server] - 1</span><br><span class="line">for index &gt; 0 &amp;&amp; rf.log[index].Term &gt; reply.XTerm &#123;</span><br><span class="line">index--</span><br><span class="line">&#125;</span><br><span class="line">if rf.log[index].Term == reply.XTerm &#123;</span><br><span class="line">rf.nextIndex[server] = index + 1 // update nextIndex.</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.nextIndex[server] = reply.XIndex</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AppendEntries()</code>中，Follower收到回复后, 按如下规则做出反应:</p><ul><li>如果XTerm != -1, 表示PrevLogIndex这个位置发生了冲突, Follower检查自身是否有Term为XTerm的日志项</li><li><ul><li>如果有, 则将nextIndex[i]设置为自己Term为XTerm的最后一个日志项的下一位, 这样的情况出现在Follower有着更多旧Term的日志项(Leader也有这样Term的日志项), 这种回退会一次性覆盖掉多余的旧Term的日志项</li></ul></li><li><ul><li>如果没有, 则将nextIndex[i]设置为XIndex, 这样的情况出现在Follower有着Leader所没有的Term的旧日志项, 这种回退会一次性覆盖掉没有出现在Leader中的Term的日志项</li></ul></li><li>如果XTerm == -1, 表示Follower中的日志不存在PrevLogIndex处的日志项, 这样的情况出现在Follower的log数组长度更短的情况下, 此时将nextIndex[i]减去XLen</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if args.PrevLogIndex &gt;= len(rf.log) &#123;</span><br><span class="line">// Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span><br><span class="line">reply.XTerm = -1</span><br><span class="line">reply.XLen = len(rf.log)</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Success = false</span><br><span class="line">return</span><br><span class="line">&#125; else if rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">reply.XTerm = rf.log[args.PrevLogIndex].Term</span><br><span class="line">i := args.PrevLogIndex</span><br><span class="line">for rf.log[i].Term == reply.XTerm &#123;</span><br><span class="line">i -= 1</span><br><span class="line">&#125;</span><br><span class="line">reply.XIndex = i + 1</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">reply.Success = false</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后Follower需要依据PrevLogIndex删除非法的logs，并添加新的log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if len(args.Entries) != 0 &amp;&amp; len(rf.log) &gt; args.PrevLogIndex+1 &#123;</span><br><span class="line">rf.log = rf.log[:args.PrevLogIndex+1]</span><br><span class="line">&#125;</span><br><span class="line">rf.log = append(rf.log, args.Entries...)</span><br></pre></td></tr></table></figure><p>最后实现一个将commit应用到状态机的协程,可以使用条件变量或者time.Sleep实现，lab中hints提示了不能不断执行，逻辑还是比较简单的，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) applyMsgToStatemachine() &#123;</span><br><span class="line">for rf.killed() == false &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">for rf.commitIndex &lt;= rf.lastApplied &#123;</span><br><span class="line">rf.condApply.Wait()</span><br><span class="line">&#125;</span><br><span class="line">for rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">rf.lastApplied++</span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">CommandValid: true,</span><br><span class="line">Command:      rf.log[rf.lastApplied].Command,</span><br><span class="line">CommandIndex: rf.lastApplied,</span><br><span class="line">&#125;</span><br><span class="line">rf.applych &lt;- *msg</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">// time.Sleep(10 * time.Millisecond) // sleep for 10 milliseconds.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>易错点</strong>：每次选出新的leader后需要重新初始化nextIndex[]和matchIndex[]：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if rf.validVoteCount &gt; len(rf.peers)/2 &#123; // majority vote received, become leader.</span><br><span class="line">if rf.state == Follower &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rf.state = Leader // become leader.</span><br><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = len(rf.log)</span><br><span class="line">rf.matchIndex[i] = 0</span><br><span class="line">&#125;</span><br><span class="line">go rf.sendHeartbeat() // start sending heartbeat.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>在实现了快速回滚的情况下，测试的结果时间还是比较长，潜在的问题可能是在更新commitIndex处使用了一个循环，导致时间复杂度过高，目前还没想到好的优化方案，后面再说<br><img src="/img/raft3Bres.png" alt=""></p><hr><h1>3C Persistence</h1><p>3C的任务是实现可持久化，如果基于 Raft 的服务器重新启动，它应该从中断处恢复服务。这要求 Raft 保持在重启后仍然存在的持久状态。</p><p>论文中提到需要我们持久化的数据只有三个：<code>votedFor、currentTerm、Log</code>。</p><ul><li>votedFor:</li><li><ul><li>votedFor记录了一个节点在某个Term内的投票记录, 因此如果不将这个数据持久化, 可能会导致如下情况:</li></ul></li><li><ul><li>在一个Term内某个节点向某个Candidate投票, 随后故障。故障重启后, 又收到了另一个RequestVote RPC, 由于其没有将votedFor持久化, 因此其不知道自己已经投过票, 结果是再次投票, 这将导致同一个Term可能出现2个Leader</li></ul></li><li>currentTerm:</li><li><ul><li>currentTerm的作用也是实现一个任期内最多只有一个Leader, 因为如果一个几点重启后不知道现在的Term时多少, 其无法再进行投票时将currentTerm递增到正确的值, 也可能导致有多个Leader在同一个Term中出现</li></ul></li><li>Log:</li><li><ul><li>利用Log来恢复自身的状态</li></ul></li></ul><p>而其他的数据如commitIndex、lastApplied、nextIndex、matchIndex都可以通过rpc信息重建</p><h2 id="3C代码逻辑">3C代码逻辑</h2><p>完善代码框架中的<code>persist()</code>和<code>readPersist()</code>，照着注释写即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) persist() &#123;</span><br><span class="line">w := new(bytes.Buffer)</span><br><span class="line">e := labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.currentTerm)</span><br><span class="line">e.Encode(rf.votedFor)</span><br><span class="line">e.Encode(rf.log)</span><br><span class="line">raftstate := w.Bytes()</span><br><span class="line">rf.persister.Save(raftstate, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// restore previously persisted state.</span><br><span class="line">func (rf *Raft) readPersist(data []byte) &#123;</span><br><span class="line">if data == nil || len(data) &lt; 1 &#123; // bootstrap without any state?</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line">d := labgob.NewDecoder(r)</span><br><span class="line">var currentTerm int</span><br><span class="line">var votedFor int</span><br><span class="line">var log []LogEntry</span><br><span class="line">if d.Decode(&amp;currentTerm) != nil || d.Decode(&amp;votedFor) != nil || d.Decode(&amp;log) != nil &#123;</span><br><span class="line">DPrintf(&quot;readPersist failed\n&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.currentTerm = currentTerm</span><br><span class="line">rf.votedFor = votedFor</span><br><span class="line">rf.log = log</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他函数中，只要修改了currentTerm、votedFor、log，我们就进行持久化。在make函数中，由于崩溃恢复时readPersist修改了log，我们需要在执行readPersist后对nextIndex进行初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func Make ... &#123;</span><br><span class="line">...</span><br><span class="line">// initialize from state persisted before a crash</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = len(rf.log)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试了很多次，结果和lab相差不大，是否就可以不管2B的结果了？<br><img src="/img/raft3Cres.png" alt=""></p><hr><h1>3D Log Compaction</h1><p>3D的任务是实现日志压缩，即Snapshot快照的实现。快照是Raft要求上层的应用程序做的, 因为Raft本身并不理解应用程序的状态和各种命令；Raft需要选取一个Log作为快照的分界点, 在这个分界点要求应用程序做快照, 并删除这个分界点之前的Log；在持久化快照的同时也持久化这个分界点之后的Log。</p><p>以一个K/V数据库为例, Log就是Put或者Get, 当这个应用运行了相当长的时间后, 其积累的Log将变得很长, 但K/V数据库实际上键值对并不多, 因为Log包含了大量的对同一个键的赋值或取值操作。因此， 应当设计一个阈值，例如1M， 将应用程序的状态做一个快照，然后丢弃这个快照之前的Log。</p><h2 id="3D代码设计">3D代码设计</h2><p>参考原论文中的figure13，实现snapshot的代码。首先我们需要在Raft结构体中加入下面几个成员，保存snapshot的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Raft struct &#123;</span><br><span class="line">...</span><br><span class="line">snapShot          []byte // snapshot of the state machine for fast recovery</span><br><span class="line">lastIncludedIndex int    // index of the last entry in the snapshot for fast recovery</span><br><span class="line">lastIncludedTerm  int    // term of the last entry in the snapshot for fast recovery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的一个问题，每次对log进行截断时，commitIndex和nextIndex等索引该如何更新呢？<br>我们可以称基于现有log日志数组的真实长度的真实索引为realIndex，而整个Raft服务中不断自增的Log索引为全局索引globalIndex，他们和lastIncludedIndex之间有着以下关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">realIndex = globalIndex - rf.lastIncludedIndex</span><br><span class="line">globalIndex = rf.lastIncludedIndex + realIndex</span><br></pre></td></tr></table></figure><p>访问rf.log我们使用realIndex，其他情况均使用globalIndex。这样就可以很好的解决对于索引的操作，并且注意，我的代码中索引都是从1开始的，0是占位符</p><hr><p>Snapshot()函数负责在接受到应用层的快照请求后，进行快照的生成，并更新Raft结构体中的snapshot和lastIncludedIndex等成员。</p><p>当index &gt; commitIndex 或者 lastIncludedIndex 时需要拒绝该请求，否则就可以保存snapshot并更改相应状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) Snapshot(index int, snapshot []byte) &#123;</span><br><span class="line">// Your code here (3D).</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if rf.commitIndex &lt; index || index &lt;= rf.lastIncludedIndex &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.snapShot = snapshot</span><br><span class="line">rf.lastIncludedTerm = rf.log[rf.RealLogIndex(index)].Term</span><br><span class="line">rf.log = rf.log[rf.RealLogIndex(index):] // log[0] store log[index]</span><br><span class="line">rf.lastIncludedIndex = index</span><br><span class="line"></span><br><span class="line">if rf.lastApplied &lt; index &#123;</span><br><span class="line">rf.lastApplied = index</span><br><span class="line">&#125;</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要更改代码中涉及索引的部分，以及对于3C中的可持久化的部分也需要更改，具体就不赘述了</p><p>特别在make初始化时，我们需要读取快照和可持久化，因此我们也需要更改nextIndex，此时就需要注意其索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// initialize from state persisted before a crash</span><br><span class="line">rf.readSnapshot(persister.ReadSnapshot())</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.GlobalLogIdx(len(rf.log)) // index start by 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>3D部分的重点是InstallSnapshot RPC的实现</p><p>假设有一个Follower的日志数组长度很短, 短于Leader做出快照的分界点, 那么这中间缺失的Log将无法通过心跳AppendEntries RPC发给Follower, 因此这个确实的Log将永久无法被补上。因此我们需要实现一个InstallSnapshot RPC，用于在Leader和Follower之间传输快照，以补全缺失的Log。Leader稍后再通过AppendEntries RPC发送快照后的Log。</p><p>参考原论文Figure 13的设计：<br><img src="/img/InstallSnapshotRpc.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type InstallSnapshotArgs struct &#123;</span><br><span class="line">Term              int         // leader’s term</span><br><span class="line">LeaderId          int         // so follower can redirect clients</span><br><span class="line">LastIncludedIndex int         // snapshot replaces log[index:]</span><br><span class="line">LastIncludedTerm  int         // term of lastIncludedIndex</span><br><span class="line">Data              []byte      // raw bytes of the snapshot chunk</span><br><span class="line">LastIncludedCmd   interface&#123;&#125; // inorder to occupy position at 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type InstallSnapshotReply struct &#123;</span><br><span class="line">Term int // currentTerm, for leader to update itself</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LastIncludedCmd用于对0索引日志的占位使用，截断后的日志，使用LastIncludedIndex位置的日志项对0号日志进行占位</p><ul><li>在sendHeartbeat()心跳函数中，如果args.PrevLogIndex &lt; rf.lastIncludedIndex，说明Follower的日志过短，则发送InstallSnapshot RPC</li><li>在handleAppendEntries()处理RPC回复的函数中，如果发现已经回退到lastIncludedIndex还不能满足要求, 就需要发送InstallSnapshot RPC</li></ul><p>发送InstallSnapshot RPC的handleInstallSnapshot函数实现如下：注意发送Rpc时不要持有锁，并且发送成功后需要将nextIndex设置为GlobalLogIdx(1), 因为0索引处是占位, 其余的部分已经不需要再发送了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) handleInstallSnapshot(server int) &#123;</span><br><span class="line">reply := &amp;InstallSnapshotReply&#123;&#125;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">if rf.state != Leader &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args := &amp;InstallSnapshotArgs&#123;</span><br><span class="line">Term:              rf.currentTerm,</span><br><span class="line">LeaderId:          rf.me,</span><br><span class="line">LastIncludedIndex: rf.lastIncludedIndex,</span><br><span class="line">LastIncludedTerm:  rf.lastIncludedTerm,</span><br><span class="line">Data:              rf.snapShot,</span><br><span class="line">LastIncludedCmd:   rf.log[0].Command,</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">ok := rf.sendInstallSnapshot(server, args, reply)</span><br><span class="line">if !ok &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">if reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.votedFor = -1</span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line">rf.persist()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex[server] = rf.GlobalLogIdx(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于InstallSnapshot Rpc的响应，特别需要注意的是要检查lastApplied和commitIndex 是否小于LastIncludedIndex, 如果是, 更新为LastIncludedIndex；同时要记得更新定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer func() &#123;</span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">// Reply immediately if term &lt; currentTerm</span><br><span class="line">if args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">rf.votedFor = -1</span><br><span class="line">&#125;</span><br><span class="line">rf.state = Follower</span><br><span class="line"></span><br><span class="line">// If existing log entry has same index and term as snapshot’s last included entry, retain log entries following it and reply</span><br><span class="line">hasEntry := false</span><br><span class="line">realIdx := 0</span><br><span class="line">for ; realIdx &lt; len(rf.log); realIdx++ &#123;</span><br><span class="line">if rf.GlobalLogIdx(realIdx) == args.LastIncludedIndex &amp;&amp; rf.log[realIdx].Term == args.LastIncludedTerm &#123;</span><br><span class="line">hasEntry = true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">SnapshotValid: true,</span><br><span class="line">Snapshot:      args.Data,</span><br><span class="line">SnapshotTerm:  args.LastIncludedTerm,</span><br><span class="line">SnapshotIndex: args.LastIncludedIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if hasEntry &#123;</span><br><span class="line">rf.log = rf.log[realIdx:]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.log = make([]LogEntry, 0)</span><br><span class="line">rf.log = append(rf.log, LogEntry&#123;Term: rf.lastIncludedTerm, Command: args.LastIncludedCmd&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Discard the entire log</span><br><span class="line">// Reset state machine using snapshot contents (and load snapshot’s cluster configuration)</span><br><span class="line">rf.snapShot = args.Data</span><br><span class="line">rf.lastIncludedIndex = args.LastIncludedIndex</span><br><span class="line">rf.lastIncludedTerm = args.LastIncludedTerm</span><br><span class="line"></span><br><span class="line">if rf.commitIndex &lt; args.LastIncludedIndex &#123;</span><br><span class="line">rf.commitIndex = args.LastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if rf.lastApplied &lt; args.LastIncludedIndex &#123;</span><br><span class="line">rf.lastApplied = args.LastIncludedIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.applych &lt;- *msg</span><br><span class="line">rf.persist()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试时，由于有许多地方需要更改，所以要不断的dubug，最好就是写好日志输出信息慢慢找，详细的就不赘述了。有一点就是在apply msg到状态机时，rf.applyCh &lt;- *msg不能够加锁，否则由于该通道长时间阻塞而产生死锁现象。<br>还有就是在产生新leader时需要对nextIndex和matchIndex进行如下初始化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; len(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = rf.VirtualLogIdx(len(rf.log))</span><br><span class="line">rf.matchIndex[i] = rf.lastIncludedIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的测试结果如下，大量测试后显示效果比lab中的还有好一些</p><p><img src="/img/raft3Dres.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 6.5840/6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.5840/6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840/6.824 Lab2 Key/Value Server</title>
      <link href="/post/4f335a90.html"/>
      <url>/post/4f335a90.html</url>
      
        <content type="html"><![CDATA[<p>lab2官网 ： <a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvsrv.html">https://pdos.csail.mit.edu/6.824/labs/lab-kvsrv.html</a></p><p>这是一个新的lab，但是感觉是官方觉得直接上raft太难了，所以加了个稍微简单点的。主要任务是实现一个key/value服务，该服务应该能够存储和检索键值对，并支持并发访问。</p><hr><h1>一、 概述</h1><p>lab2 只需完成src/kvsrv文件夹下的代码，不需要修改其他文件。首先研究一下lab给出的基本框架，可以看到给了我们4种rpc报文：<code>PutAppendArgs、PutAppendReply、GetArgs、GetReply</code>，前两者负责put和append的通信，后两者负责Get的通信。而对于Server和Client，lab给出了基本框架，我们只需要实现其中的<code>Put</code>、<code>Get</code>、<code>Append</code>三个方法即可。</p><h2 id="1-1-client">1.1 client</h2><p>从Lab官网的提示我们可以看到，要求我们能够分辨不同的客户端，并且能够处理重复的rpc请求，特别是对append的处理，因此我们引入clientId int64 与rpcId uint32两个变量来区分不同的客户端和rpc请求。新的Clerk结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Clerk struct &#123;</span><br><span class="line">server *labrpc.ClientEnd</span><br><span class="line">// You will have to modify this struct.</span><br><span class="line">clientId int64</span><br><span class="line">rpcId    uint32 // rpc id for each client request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PutAppendArgs 报文结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type PutAppendArgs struct &#123;</span><br><span class="line">Key   string</span><br><span class="line">Value string</span><br><span class="line">// You&#x27;ll have to add definitions here.</span><br><span class="line">// Field names must start with capital letters,</span><br><span class="line">// otherwise RPC will break.</span><br><span class="line">ClientId int64</span><br><span class="line">RpcId    uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>nrand()函数是lab给我们提供的随机生成int64类型数的函数，我们可以利用他来生成ClientId，而RpcId则可以由我们自行递增。</p><p>Client端的几个函数都很简单，调用一下call即可,以PutApepend这个函数为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func (ck *Clerk) PutAppend(key string, value string, op string) string &#123;</span><br><span class="line">// You will have to modify this function.</span><br><span class="line"></span><br><span class="line">ck.rpcId++</span><br><span class="line">// rpcId++ // increment rpc id for each RPC request</span><br><span class="line">putAppendArgs := PutAppendArgs&#123;key, value, ck.clientId, ck.rpcId&#125;</span><br><span class="line">putAppendReply := PutAppendReply&#123;&#125;</span><br><span class="line">for &#123;</span><br><span class="line">ok := ck.server.Call(&quot;KVServer.&quot;+op, &amp;putAppendArgs, &amp;putAppendReply)</span><br><span class="line">if ok &#123;</span><br><span class="line">return putAppendReply.Value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-server">1.2 server</h2><p>在server端，我们需要利用两个map，一个map用来存储K\V键值对，另外一个用来存储client 和他的上次所发的Rpc的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type LastRpc struct &#123;</span><br><span class="line">value string</span><br><span class="line">rpcId uint32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type KVServer struct &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line"></span><br><span class="line">// Your definitions here.</span><br><span class="line">kvMap   map[string]string</span><br><span class="line">lastRpc map[int64]LastRpc // clientId -&gt; lastRpcId</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>tips</strong>: 为什么这里需要存储value呢？因为在append时，返回的是旧的value值，而如果遇到的是重复的报文，我们返回的依然是第一次执行时返回的旧value，而不是K\Vmap中的最新值</p><p>设计了这个结构后，其他的函数的实现就比较简单了，我只贴一下append 的代码，对于并发的控制，我就通过一把大锁来解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (kv *KVServer) Append(args *PutAppendArgs, reply *PutAppendReply) &#123;</span><br><span class="line">// Your code here.</span><br><span class="line"></span><br><span class="line">kv.mu.Lock()</span><br><span class="line">defer kv.mu.Unlock()</span><br><span class="line">curClientId := args.ClientId</span><br><span class="line">curRpcId := args.RpcId</span><br><span class="line">lastRpc, ok := kv.lastRpc[curClientId]</span><br><span class="line">if ok &amp;&amp; lastRpc.rpcId &gt;= curRpcId &#123; // duplicate rpc request, ignore it.</span><br><span class="line">reply.Value = lastRpc.value</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">curValue, ok := kv.kvMap[args.Key]</span><br><span class="line">if ok &#123;</span><br><span class="line">kv.kvMap[args.Key] = curValue + args.Value</span><br><span class="line">reply.Value = curValue // return the old value after append.</span><br><span class="line">&#125; else &#123;</span><br><span class="line">kv.kvMap[args.Key] = args.Value // if the key does not exist, just append the value.</span><br><span class="line">reply.Value = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">kv.lastRpc[curClientId] = LastRpc&#123;curValue, curRpcId&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二 、一些问题</h1><h2 id="2-1">2.1</h2><p>测试时，一个客户端和多个客户端的测试会出现 <code>linearizability check timed out, assuming history is ok</code> 的warn</p><p>试着找了找原因，在test.go下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">res, info := porcupine.CheckOperationsVerbose(models.KvModel, opLog.Read(), linearizabilityCheckTimeout)</span><br><span class="line">if res == porcupine.Illegal &#123;</span><br><span class="line">...</span><br><span class="line">&#125; else if res == porcupine.Unknown &#123;</span><br><span class="line">fmt.Println(&quot;info: linearizability check timed out, assuming history is ok&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>porcupine.Unknown 我看了下 porcupine 的源码，porcupine最后会调用checkParallel函数来并行的检测每个goroutine的结果，如果1秒没有返回，则会回报TimeOut，打印上述的这个warn，我将test中的<code>linearizabilityCheckTimeout</code>改为2s，则不再出现此问题:<br><img src="/img/kvserverres1.png" alt=""></p><p>更深层的原因，推测是设计的结构还是不够精简，导致系统运行的效率较低，后续可以改良一下</p><h2 id="2-2">2.2</h2><p>关于lab中要求实现线性一致性，由于lab2只涉及到了一个server，没有用于容错的副本server，所以对于线性一致性的的实现我们只需要记得加锁、合理处理重复报文即可。更复杂线性一致性涉及的可能会在后续lab中涉及</p>]]></content>
      
      
      <categories>
          
          <category> 6.5840/6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.5840/6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5840/6.824 Lab1 MapReduce</title>
      <link href="/post/d5c40702.html"/>
      <url>/post/d5c40702.html</url>
      
        <content type="html"><![CDATA[<p>6.5840官网链接：<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">https://pdos.csail.mit.edu/6.824/labs/lab-mr.html</a><br>写完了发现其实没写啥，全贴代码去了，逻辑还是算比较简单的，但是其中的思想还是让我受益匪浅。lab2 的博客再改进改进。</p><hr><h1>一、概述</h1><p><code>MapReduce: Simplified Data Processing on Large Clusters</code>提出了一种针对大数据处理的编程模型和实现，使得编程人员无需并行和分布式系统经验就可以轻松构建大数据处理应用。该模型将大数据处理问题拆解为两步，即 <strong>map</strong>和 <strong>reduce</strong>，<strong>map</strong> 阶段将一组输入的键值对转化为中间结果键值对，<strong>reduce</strong> 阶段对中间结果键值对按照相同的键进行值的合并，从而得到最终的结果。</p><h2 id="1-1-背景">1.1 背景</h2><p>对于 Google 来说，每天运行的系统会产生大量的原始数据，同时又要对这些原始数据进行加工产生各种衍生数据，虽然大部分数据加工的逻辑都较为简单，然而由于数据量过于庞大，为了在合理的时间内完成数据处理，通常需要将待处理的数据分发到几百或几千台机器上并行计算，这就存在几个问题：</p><ul><li><ol><li>如何使计算可并行</li></ol></li><li><ol start="2"><li>如何分发数据</li></ol></li><li><ol start="3"><li>如何处理异常</li></ol></li></ul><p>如果每一个数据加工任务都需要独立去解决上述的问题，一方面会使得原本简单的代码逻辑变得庞大、复杂和难以维护，另一方面也是在重复工作。受 <strong>Lisp</strong> 等其他函数式编程语言中的 <strong>map</strong> 和 <strong>reduce</strong> 函数的启发，Google 的工程师们发现大部分的数据处理遵循如下的模式：</p><ul><li><ol><li>对输入的每一条数据应用一个 <strong>map</strong> 函数产生一组中间结果键值对</li></ol></li><li><ol start="2"><li>对中间结果键值对按照相同的键聚合后，应用 <strong>reduce</strong> 函数生成最终的衍生数据</li></ol></li></ul><p>因此，Google 的工程师们抽象出了 <strong>MapReduce</strong> 框架，使得应用开发人员可以专注于计算逻辑实现而无需关心底层运行细节，统一由框架层处理并行、容错、数据分发和负载均衡等系统问题。现在再来看前面提到的问题是如何解决的：</p><ul><li><ol><li>如何使计算可并行：在 <strong>map</strong> 阶段，对数据分发后，各任务间无依赖，可并行执行；在 <strong>reduce</strong> 阶段，不同 <strong>key</strong> 的数据处理间无依赖，可并行执行</li></ol></li><li><ol start="2"><li>如何分发数据：在 <strong>map</strong> 阶段，可按执行 <strong>map</strong> 任务的节点数量平均分发（这只是一种可能的策略，具体分发策略见后文描述）；在 <strong>reduce</strong> 阶段，可按 key 相同的数据聚合后分发</li></ol></li><li><ol start="3"><li>如何处理异常：重新执行某个节点上失败的 <strong>map</strong> 或 <strong>reduce</strong> 任务作为首要的容错手段</li></ol></li></ul><h2 id="1-2-系统架构与关键流程">1.2 系统架构与关键流程</h2><p>在 <strong>map</strong> 执行阶段，框架会自动将输入数据分为 <strong>M</strong> 片，从而将 <strong>map</strong> 任务分发到多台机器上并行执行，每台机器只处理某一片的数据。同样的，在 <strong>reduce</strong> 阶段，框架首先将中间结果数据根据分片函数（例如 <code>hash(key) mod R</code>）拆分为 <strong>R</strong> 片，然后分发给 <strong>reduce</strong> 任务执行，用户可自行指定 <strong>R</strong> 的值和实现具体的分片函数。</p><p>下图展示了 Google 所实现的 <strong>MapReduce</strong> 框架的整体执行流程：<br><img src="/img/mapreduce.png" alt="alt"></p><ul><li><ol><li>首先 MapReduce 框架将输入数据分为 M 片，每片数据大小一般为 16 MB 至 64 MB（具体大小可由用户入参控制），然后将 MapReduce 程序复制到集群中的一批机器上运行。</li></ol></li><li><ol start="2"><li>在所有的程序拷贝中，某台机器上的程序会成为主节点（master），其余称为工作节点（worker），由主节点向工作节点分派任务，一共有 M 个 map 任务和 R 个 reduce 任务需要分派。主节点会选择空闲的工作节点分派 map 或 reduce 任务。</li></ol></li><li><ol start="3"><li>如果某个工作节点被分派了 map 任务则会读取当前的数据分片，然后将输入数据解析为一组键值对后传递给用户自定义的 map 函数执行。map 函数产生的中间结果键值对会暂存在内存中。</li></ol></li><li><ol start="4"><li>暂存在内存中的中间结果键值对会周期性的写入到本地磁盘中，并根据某个分片函数将这些数据写入到本地磁盘下的 R 个区，这样相同键的中间结果数据在不同的 map 节点下属于同一个区号，就可以在后续将同一个键的中间结果数据全部发给同一个 reduce 节点。同时，这些数据写入后的地址会回传给 master 节点，master 节点会将这些数据的地址发送给相应的 reduce 节点。</li></ol></li><li><ol start="5"><li>当 reduce 节点接收到 master 节点发送的中间结果数据地址通知后，将通过 RPC 请求根据数据地址读取 map 节点生成的数据。在所有中间结果数据都读取完成后，reduce 节点会先将所有中间结果数据按照键进行排序，这样所有键相同的数据就聚合在了一起。之所以要排序是因为一个 reduce 节点会分发处理多个键下的中间结果数据。如果中间结果数据量太大不足以完全载入内存，则需要使用外部排序。</li></ol></li><li><ol start="6"><li>reduce 节点执行时会先遍历排序后的中间结果数据，每遇到一个新的键就会将该键及其对应的所有中间结果数据传递给用户自定义的 reduce 函数执行。reduce 函数执行的结果数据会追加到当前 reduce 节点的最终输出文件里。</li></ol></li><li><ol start="7"><li>当所有 map 任务和 reduce 任务都执行完成后，master 节点会唤醒用户程序，并将控制权交还给用户代码。</li></ol></li></ul><hr><h1>二、代码实现</h1><p>Lab1 的任务是依托给出的框架，完善<code>src/mr</code>目录下的<code>Coordinator</code>、<code>Worker</code>和<code>Rpc</code>的代码，实现一个简单的<code>MapReduce</code>框架。</p><p>代码其实已经给出了一个串行运行的mapreduce，我们需要做的就是借助于rpc将其改为并行的框架，可支持多个线程或机器同时完成一个任务，以提高运行效率。</p><p><strong>整体流程：</strong></p><ul><li><code>worker</code>启动一个无限循环，通过<code>rpc</code>向<code>coordinator</code>节点获取任务，然后<code>coordinator</code>通过<code>rpc</code>分配<code>map</code>任务给<code>worker</code>节点，等待<code>worker</code>节点将<code>map</code>任务完成。<code>coordinator</code>在<strong>分配任务后会使用协程检测该任务是否在10秒内完成，如果超时则重新分配任务</strong>。</li><li><code>worker</code>节点将分配的<code>map</code>任务完成以后，生成对应的中间文件<code>intermediate</code>，将结果返回给<code>coordinator</code>，<code>coordinator</code>接收到结果以后，更新任务状态，主要记录所有的<code>map</code>任务是否完成。</li><li><code>coordinator</code>根据<code>worker</code>的回报信息进行判断,如果是<code>map</code>类型则已完成的<code>map</code>任务数量 +<strong>1</strong>，然后判断更新<code>mapFinished</code>。如果是<code>reduce</code>类型，则更新相应的状态，已完成的<code>reduce</code>任务数量 +<strong>1</strong>。</li><li>当所有的<code>map</code>任务都完成以后，即<code>mapFinished</code>状态转变。<code>coordinator</code>会将<code>map</code>获取的中间文件分配给<code>worker</code>节点作为<code>reduce</code>任务的输入，然后<code>worker</code>节点执行<code>reduce</code>任务。</li><li>每次完成<code>reduce</code>任务后<code>worker</code>节点向<code>coordinator</code>报告并更新状态，直到所有任务完成，完成<code>mapreduce</code>任务。</li></ul><h2 id="2-1-rpc">2.1 rpc</h2><p>对于rpc，我其实只需要2种通信4种消息类型即可，一个是用于获取任务，一个是用于报告任务完成情况。<br><code>GetTaskRequest</code>与<code>GetTaskResponse</code>用于获取任务，<code>ReportStatusRequest</code>与<code>ReportStatusResponse</code>用于报告任务完成情况。<br>但是其具体的内容需要根据<code>coordinator</code>和<code>worker</code>的具体实现进行定义，在代码完成的过程中一步步完善。最后的定义如下：意义都如名字所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type GetTaskRequest struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GetTaskResponse struct &#123;</span><br><span class="line">TaskIdentifier  string</span><br><span class="line">TaskType        int // 0:map 1:reduce 2:sleep</span><br><span class="line">MapFileName     string</span><br><span class="line">ReduceFilesName []string</span><br><span class="line">ReduceNumber    int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReportStatusRequest struct &#123;</span><br><span class="line">TaskIdentifier        string</span><br><span class="line">IntermediateFilesName []string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReportStatusResponse struct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-coordinator">2.2 coordinator</h2><p>coordinator 或者说 master 节点，其核心功能是分配任务，并且检测任务是否完成。<br>我们定义Task任务如下，这个Task任务是动态的任务，使我们分配给worker来做的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Task struct &#123;</span><br><span class="line">name         string</span><br><span class="line">taskType         int</span><br><span class="line">mapFileName  string</span><br><span class="line">reduceFileId int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name是由一个全局自增的<code>taskIdentifier</code>来标识的，以区别任务，taskType是任务的类型，0表示map任务，1表示reduce任务，2表示Sleep，无任务。</p><p>coordinator的定义如下;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Coordinator struct &#123;</span><br><span class="line">// Your definitions here.</span><br><span class="line">mapFiles            map[string]int   // name : status</span><br><span class="line">reduceFiles         map[int]int      // id : status</span><br><span class="line">intermediateFiles   map[int][]string // id : names</span><br><span class="line">taskMap             map[string]*Task // taskIdentifier : Task</span><br><span class="line">mapFinishedCount    int              // number of map tasks finished</span><br><span class="line">reduceFinishedCount int              // number of reduce tasks finished</span><br><span class="line">mapFinished         bool             // all map tasks finished</span><br><span class="line">reduceNumber        int              // number of reduce tasks</span><br><span class="line">mutex               sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapFiles与reduceFiles这两个map是用来记录静态任务的状态的，mapFiles记录map任务的状态，reduceFiles记录reduce任务的状态。status则是需要我们完成的静态任务的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ( // Status</span><br><span class="line">Ready = iota</span><br><span class="line">Running</span><br><span class="line">Finished</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>coordinator主要实现两个函数，一个是用于分发任务的AssignTask，一个是用于检测任务状态的ReportStatus</p><p>对于AssignTask，我们仅需遍历mapFiles与reduceFiles，对于处于Ready状态的任务，我们分配给worker，并将其状态改为Running。具体的逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func (c *Coordinator) AssignTask(args *GetTaskRequest, reply *GetTaskResponse) error &#123;</span><br><span class="line">c.mutex.Lock()</span><br><span class="line">defer c.mutex.Unlock()</span><br><span class="line">reply.MapFileName = &quot;&quot;</span><br><span class="line">reply.ReduceFilesName = make([]string, 0)</span><br><span class="line">reply.ReduceNumber = c.reduceNumber</span><br><span class="line">reply.TaskIdentifier = strconv.Itoa(taskIdentifier)</span><br><span class="line">taskIdentifier++ // dont forget ++</span><br><span class="line">if c.mapFinished &#123;</span><br><span class="line">for v := range c.reduceFiles &#123;</span><br><span class="line">if c.reduceFiles[v] == Ready &#123;</span><br><span class="line">c.reduceFiles[v] = Running</span><br><span class="line">reply.ReduceFilesName = append(reply.ReduceFilesName, c.intermediateFiles[v]...)</span><br><span class="line">reply.TaskType = Reduce</span><br><span class="line">newTask := &amp;Task&#123;reply.TaskIdentifier, reply.TaskType, &quot;&quot;, v&#125;</span><br><span class="line">c.taskMap[reply.TaskIdentifier] = newTask</span><br><span class="line">go c.HandleTimeout(reply.TaskIdentifier)</span><br><span class="line">return nil</span><br><span class="line">&#125; else &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.TaskType = Sleep</span><br><span class="line">return nil</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for v := range c.mapFiles &#123;</span><br><span class="line">if c.mapFiles[v] == Ready &#123;</span><br><span class="line">c.mapFiles[v] = Running</span><br><span class="line">reply.MapFileName = v</span><br><span class="line">reply.TaskType = Map</span><br><span class="line">newTask := &amp;Task&#123;reply.TaskIdentifier, reply.TaskType, reply.MapFileName, -1&#125;</span><br><span class="line">c.taskMap[reply.TaskIdentifier] = newTask</span><br><span class="line">go c.HandleTimeout(reply.TaskIdentifier)</span><br><span class="line">return nil</span><br><span class="line">&#125; else &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.TaskType = Sleep</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用协程处理超时时，我们通过time.Sleep让其睡眠10s，若10s后该Task还在taskMap中，则认定其超时，将其从taskMap中删除，并将其对应的静态任务状态改为Ready，等待重新分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func (c *Coordinator) HandleTimeout(taskId string) &#123;</span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">c.mutex.Lock()</span><br><span class="line">defer c.mutex.Unlock()</span><br><span class="line">if t, ok := c.taskMap[taskId]; ok &#123;</span><br><span class="line">if t.taskType == Map &#123;</span><br><span class="line">f := t.mapFileName</span><br><span class="line">if c.mapFiles[f] == Running &#123;</span><br><span class="line">c.mapFiles[f] = Ready</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">f := t.reduceFileId</span><br><span class="line">if c.reduceFiles[f] == Running &#123;</span><br><span class="line">c.reduceFiles[f] = Ready</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">delete(c.taskMap, taskId)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于ReportStatus，我们需要根据worker汇报的信息进行判断，如果完成的Task是Map，我们需要判断所有的Map任务是否都完成了，并且要将Map生成的中间文件加入到对应的Reduce任务组中，具体逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func (c *Coordinator) ReportStatus(args *ReportStatusRequest, reply *ReportStatusResponse) error &#123;</span><br><span class="line">c.mutex.Lock()</span><br><span class="line">defer c.mutex.Unlock()</span><br><span class="line">if t, ok := c.taskMap[args.TaskIdentifier]; ok &#123;</span><br><span class="line">if t.taskType == Map &#123;</span><br><span class="line">f := t.mapFileName</span><br><span class="line">c.mapFiles[f] = Finished</span><br><span class="line">c.mapFinishedCount++</span><br><span class="line">if c.mapFinishedCount == len(c.mapFiles) &#123;</span><br><span class="line">c.mapFinished = true</span><br><span class="line">&#125;</span><br><span class="line">for _, v := range args.IntermediateFilesName &#123;</span><br><span class="line">index := strings.LastIndex(v, &quot;_&quot;)</span><br><span class="line">reduceId, err := strconv.Atoi(v[index+1:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">c.intermediateFiles[reduceId] = append(c.intermediateFiles[reduceId], v)</span><br><span class="line">&#125;</span><br><span class="line">delete(c.taskMap, t.name)</span><br><span class="line">return nil</span><br><span class="line">&#125; else if t.taskType == Reduce &#123;</span><br><span class="line">f := t.reduceFileId</span><br><span class="line">c.reduceFiles[f] = Finished</span><br><span class="line">c.reduceFinishedCount++</span><br><span class="line">delete(c.taskMap, t.name)</span><br><span class="line">return nil</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Fatal(&quot;task type is not map and reduce&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(&quot;Task %s not found\n&quot;, args.TaskIdentifier)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-worker">2.3 worker</h2><p>worker的主要逻辑：在一个无限循环中，不断向coordinator请求任务，如果coordinator分配了任务，worker就执行该任务，并将执行结果汇报给coordinator。比较简单，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Your worker implementation here.</span><br><span class="line">for &#123;</span><br><span class="line">args := GetTaskRequest&#123;&#125;</span><br><span class="line">reply := GetTaskResponse&#123;&#125;</span><br><span class="line">call(&quot;Coordinator.AssignTask&quot;, &amp;args, &amp;reply)</span><br><span class="line">if reply.TaskType == Map &#123;</span><br><span class="line">intermediateFilesName := HandleMapTask(mapf, reply.MapFileName, reply.ReduceNumber, reply.TaskIdentifier)</span><br><span class="line">reportStatusArgs := ReportStatusRequest&#123;reply.TaskIdentifier, intermediateFilesName&#125;</span><br><span class="line">reportStatusReply := ReportStatusResponse&#123;&#125;</span><br><span class="line">call(&quot;Coordinator.ReportStatus&quot;, &amp;reportStatusArgs, &amp;reportStatusReply)</span><br><span class="line">&#125; else if reply.TaskType == Reduce &#123;</span><br><span class="line">HandleReduceTask(reducef, reply.ReduceFilesName)</span><br><span class="line">reportStatusArgs := ReportStatusRequest&#123;reply.TaskIdentifier, []string&#123;&#125;&#125;</span><br><span class="line">reportStatusReply := ReportStatusResponse&#123;&#125;</span><br><span class="line">call(&quot;Coordinator.ReportStatus&quot;, &amp;reportStatusArgs, &amp;reportStatusReply)</span><br><span class="line">&#125; else if reply.TaskType == Sleep &#123;</span><br><span class="line">time.Sleep(time.Millisecond * 100)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.Fatal(&quot;Unknown task type&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandleMapTask与HandleReduceTask其实就是将串行的map和reduce操作封装一下，比较简单，主要是注意Hints中有提示我们利用json来处理数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">func HandleMapTask(mapf func(string, string) []KeyValue, mapFileName string, reduceNum int, taskId string) []string &#123;</span><br><span class="line">intermediate := []KeyValue&#123;&#125;</span><br><span class="line">file, err := os.Open(mapFileName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;cannot open %v&quot;, mapFileName)</span><br><span class="line">&#125;</span><br><span class="line">content, err := io.ReadAll(file)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;cannot read %v&quot;, mapFileName)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">kva := mapf(mapFileName, string(content))</span><br><span class="line">intermediate = append(intermediate, kva...)</span><br><span class="line"></span><br><span class="line">intermediateFileNames := make([]string, reduceNum)</span><br><span class="line">intermediateFiles := make([]*os.File, reduceNum)</span><br><span class="line">for i := 0; i &lt; reduceNum; i++ &#123;</span><br><span class="line">oname := &quot;mr&quot;</span><br><span class="line">oname = oname + &quot;_&quot; + taskId + &quot;_&quot; + strconv.Itoa(i)</span><br><span class="line">ofile, _ := os.Create(oname)</span><br><span class="line">intermediateFiles[i] = ofile</span><br><span class="line">intermediateFileNames[i] = oname</span><br><span class="line">&#125;</span><br><span class="line">for _, kv := range intermediate &#123; //将数据写入到对应的文件中。为了方便reduce读取，所以选择以json格式写入</span><br><span class="line">index := ihash(kv.Key) % reduceNum</span><br><span class="line">enc := json.NewEncoder(intermediateFiles[index])</span><br><span class="line">enc.Encode(&amp;kv)</span><br><span class="line">&#125;</span><br><span class="line">return intermediateFileNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HandleReduceTask(reducef func(string, []string) string, reduceFilesName []string) string &#123;</span><br><span class="line">intermediateFiles := make([]*os.File, len(reduceFilesName))</span><br><span class="line">intermediate := []KeyValue&#123;&#125;</span><br><span class="line">for i := 0; i &lt; len(reduceFilesName); i++ &#123;</span><br><span class="line">intermediateFiles[i], _ = os.Open(reduceFilesName[i])</span><br><span class="line">kv := KeyValue&#123;&#125;</span><br><span class="line">dec := json.NewDecoder(intermediateFiles[i])</span><br><span class="line">for &#123;</span><br><span class="line">if err := dec.Decode(&amp;kv); err != nil &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">intermediate = append(intermediate, kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(ByKey(intermediate))</span><br><span class="line">oname := &quot;mr-out-&quot;</span><br><span class="line"></span><br><span class="line">index := reduceFilesName[0][strings.LastIndex(reduceFilesName[0], &quot;_&quot;)+1:]</span><br><span class="line">oname = oname + index</span><br><span class="line">ofile, _ := os.Create(oname)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// call Reduce on each distinct key in intermediate[],</span><br><span class="line">// and print the result to mr-out-0.</span><br><span class="line">//</span><br><span class="line">i := 0</span><br><span class="line">for i &lt; len(intermediate) &#123;</span><br><span class="line">j := i + 1</span><br><span class="line">for j &lt; len(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">values := []string&#123;&#125;</span><br><span class="line">for k := i; k &lt; j; k++ &#123;</span><br><span class="line">values = append(values, intermediate[k].Value)</span><br><span class="line">&#125;</span><br><span class="line">output := reducef(intermediate[i].Key, values)</span><br><span class="line"></span><br><span class="line">// this is the correct format for each line of Reduce output.</span><br><span class="line">fmt.Fprintf(ofile, &quot;%v %v\n&quot;, intermediate[i].Key, output)</span><br><span class="line"></span><br><span class="line">i = j</span><br><span class="line">&#125;</span><br><span class="line">return oname</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>三、bug</h1><p>代码的逻辑其实还是比较简单的，主要是设计几个结构体来彼此通信，有一个点卡了我一会，就是对于TaskType这个，最开始我只设定了Map、Reduce两种状态，后面测试出现问题，原因在于mrcoordinator每隔一秒钟调用Done()函数来判断整个任务是否完成，而Done是通过<code>c.reduceFinishedCount == c.reduceNumber</code>来判断的。</p><p>如果没有后面加入的Sleep状态，所有Reduce任务完成后，由于worker会不断向coordinator发送任务请求，coordinator的代码逻辑中没有对于所有Reduce任务完成后的处理，导致worker仍然再不停的进行处理空的Map任务，不断打印HandleMap中的log.Fatalf(“cannot open %v”, mapFileName)这一错误。</p>]]></content>
      
      
      <categories>
          
          <category> 6.5840/6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6.5840/6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-445 bustub Project4：Concurrency Control</title>
      <link href="/post/6b93e080.html"/>
      <url>/post/6b93e080.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面-2">写在前面</h2><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/592700870">https://zhuanlan.zhihu.com/p/592700870</a></li><li><a href="https://www.bilibili.com/video/BV1bQ4y1Y7iT">https://www.bilibili.com/video/BV1bQ4y1Y7iT</a></li><li><a href="https://zhuanlan.zhihu.com/p/592700870">https://zhuanlan.zhihu.com/p/592700870</a></li></ul><p>历时整整两个月，总算完成了15445的学习，收获很大，总体上说，project4的难度是比较低的，个人感觉2 &gt;&gt; 3 &gt; 4 ≈ 1。</p><p><img src="/img/15445res.png" alt="15445res.png"></p><p>Project4: Concurrency Control主要是依据lecture中的2PL以及三种事务隔离机制实现一个锁管理器，并且要具备死锁检测的功能。主要分为三个task：</p><ul><li>Lock Manager ：锁管理器，利用 2PL 实现并发控制。支持 REPEATABLE_READ、READ_COMMITTED 和 READ_UNCOMMITTED 三种隔离级别，支持 SHARED、EXCLUSIVE、INTENTION_SHARED、INTENTION_EXCLUSIVE 和 SHARED_INTENTION_EXCLUSIVE 五种锁，支持 table 和 row 两种锁粒度，支持锁升级。</li><li>Deadlock Detection：死锁检测，运行在一个 background 线程，每间隔一定时间检测当前是否出现死锁，并挑选合适的事务将其 abort 以解开死锁。</li><li>Concurrent Query Execution：修改之前实现的 SeqScan、Insert 和 Delete 算子，加上适当的锁以实现并发的查询。</li></ul><h2 id="一、前置知识">一、前置知识</h2><h3 id="1-1-Serializable">1.1 Serializable</h3><p>当事务并发时，假如事务并发执行的顺序能够等于这些事务按某种顺序顺序执行的结果，那么称这些事务的并发是 serializable schedule，称这两个 schedule 是 Serializable Schedule。事务并发执行的顺序很难确保说是等价于某种顺序执行，只能依照不同的并发策略而定。</p><h3 id="1-2-Two-Phase-Locking（2PL）">1.2 Two Phase Locking（2PL）</h3><p>通过并发策略就能够管理事务，是他们自动保证一个 schedule 是 serializable。不难想到，保证 schedule 正确性的方法就是合理的加锁 (locks) 策略，2PL 就是其中之一。</p><p><strong>注意</strong>：2PL 保证正确性的方式是通过获得锁的顺序实现的，也就说我们没办法强制要求事务按照某个 serial schedule 并发，<strong>只能保证最终结果是正确的。</strong></p><p>2PL，顾名思义，有两个阶段：<code>growing</code> 和 <code>shrinking</code>：</p><ul><li><code>growing</code>： 事务可以按需获取某条数据的锁，lock manager 决定同意或者拒绝。一旦开始释放锁就进了 shrinking 阶段</li><li><code>shrinking</code>：阶段中，事务只能释放之前获取的锁，不能获得新锁，即一旦开始释放锁，之后就只能释放锁。</li></ul><h3 id="1-3-Transaction-isolation-mechanism">1.3 Transaction isolation mechanism</h3><p>按照等级(<strong>隔离程度</strong>)由低到高：</p><ul><li>Read uncommitted (未提交读)</li><li>Read committed (提交读)</li><li>Repeatable read (可重复读) (mysql默认)</li><li>Serializable (可序列化)</li></ul><p><img src="/img/TransactionIso.png" alt="TransactionIso"></p><p>√代表可能出现的问题<br><strong>注意：</strong> 可以采用提高事务的隔离级别的方式来解决脏读、不可重复读、幻读等问题, 但与此同时, 事务的隔离级别越高, 并发能力也就越低; 所以, 还需要读者根据业务需要进行权衡</p><h4 id="1-3-1-未提交读-Read-uncommitted">1.3.1 未提交读 (Read uncommitted)</h4><ul><li><p><strong>定义</strong><br><code>是最低的隔离级别, 在这种事务隔离级别下, 一个事务可以读到另外一个事务未提交的数据</code></p></li><li><p><strong>数据库加锁情况(实现原理)</strong><br><code>事务在读数据的时候并未对数据加锁</code><br><code>事务在修改数据的时候只对数据增加写锁，并在使用完后立即释放</code></p></li><li><p><strong>现象解释</strong><br><code>事务1读取某行记录时, 事务2也能对这行记录进行读取、更新, 并且因为事务一并未对数据增加任何锁</code><br><code>当事务2也对该记录进行更新时, 事务1再次读取该记录, 能读到事务2对该记录的修改版本 (因为事务2只增加了共享读锁, 事务1可以再增加共享读锁读取数据), 即使该修改尚未被提交, 若此时事务2回滚, 那事务1读到的就脏数据了, 这就引发了脏读现象</code><br><code>事务1更新某行记录时, 事务2不能对这行记录做更新, 直到事务1结束 (因为事务1对数据增加了共享读锁, 事务2不能增加排他写锁进行数据的修改)</code></p></li></ul><h4 id="1-3-2-提交读-Read-committed">1.3.2 提交读 (Read committed)</h4><ul><li><p><strong>定义</strong><br><code>可以理解成都已提交, 在一个事务修改数据过程中, 如果事务还没提交, 其他事务不能读该数据</code></p></li><li><p><strong>数据库加锁情况</strong><br><code>事务对当前被读取的数据增加行级共享锁(读到时才加锁), 一旦读完该行, 立即释放该行行级共享锁</code><br><code>事务在更新某数据的瞬间(在更新的瞬间), 必须先对其加行级排它锁, 直到事务结束才释放</code></p></li><li><p><strong>现象解释</strong><br><code>事务1在读取某行记录的整个过程中, 事务2都可以对该行记录进行读取 (因为事务一对该行记录增加行级共享锁的情况下, 事务二同样可以对该数据增加共享锁来读数据)</code><br><code>事务1读取某行的一瞬间, 事务2不能修改该行数据, 但是, 只要事务1读取完改行数据, 事务2就可以对该行数据进行修改 (事务一在读取的一瞬间会对数据增加共享锁, 任何其他事务都不能对该行数据增加排他锁; 但是事务一只要读完该行数据, 就会释放行级共享锁, 一旦锁释放, 事务二就可以对数据增加排他锁并修改数据)</code><br><code>事务1更新某行记录时, 事务2不能对这行记录做更新, 直到事务1结束 (事务一在更新数据的时候, 会对该行数据增加排他锁, 知道事务结束才会释放锁, 所以, 在事务二没有提交之前, 事务一都能不对数据增加共享锁进行数据的读取; 所以, 提交读可以解决脏读的现象)</code></p></li></ul><h4 id="1-3-3-可重复读-Repeatable-reads">1.3.3 可重复读 (Repeatable reads)</h4><ul><li><p><strong>定义</strong><br><code>由于提交读隔离级别会产生不可重复读的读现象, 所以比提交读更高一个级别的隔离级别就可以解决不可重复读的问题, 这种隔离级别就叫可重复读 </code></p></li><li><p><strong>数据库锁情况</strong><br><code>事务在读取某数据的瞬间 (就是开始读取的瞬间), 必须先对其加行级共享锁, 直到事务结束才释放</code><br><code>事务在更新某数据的瞬间 (就是发生更新的瞬间), 必须先对其加行级排他锁, 直到事务结束才释放</code></p></li><li><p><strong>现象解释</strong><br><code>事务1在读取某行记录的整个过程中, 事务2都可以对该行记录进行读取 (因为事务一对该行记录增加行级共享锁的情况下, 事务二同样可以对该数据增加共享锁来读数据)</code><br><code>事务1在读取某行记录的整个过程中, 事务2都不能修改该行数据 (事务一在读取的整个过程会对数据增加共享锁, 直到事务提交才会释放锁, 所以整个过程中, 任何其他事务都不能对该行数据增加排他锁; 所以, 可重复读能够解决不可重复读的读现象)</code><br><code>事务1更新某行记录时, 事务2不能对这行记录做更新, 直到事务1结束 (事务一在更新数据的时候, 会对该行数据增加排他锁, 知道事务结束才会释放锁, 所以, 在事务二没有提交之前, 事务一都能不对数据增加共享锁进行数据的读取; 所以, 提交读可以解决脏读的现象)</code></p></li></ul><h4 id="1-3-4-可序列化-Serializable">1.3.4 可序列化 (Serializable)</h4><ul><li><p><strong>定义</strong><br><code>是最高的隔离级别, 前面三种隔离级别都无法解决的幻读, 在可序列化的隔离级别中可以解决</code></p></li><li><p><strong>数据库锁情况</strong><br><code>事务在读取数据时, 必须先对其加表级共享锁, 直到事务结束才释放</code><br><code>事务在更新数据时, 必须先对其加表级排他锁, 直到事务结束才释放</code></p></li><li><p><strong>现象解释</strong><br><code>事务1正在读取A表中的记录时, 则事务2也能读取A表, 但不能对A表做更新、新增、删除, 直到事务1结束 (因为事务一对表增加了表级共享锁, 其他事务只能增加共享锁读取数据, 不能进行其他任何操作)</code><br><code>事务1正在更新A表中的记录时, 则事务2不能读取A表的任意记录, 更不可能对A表做更新、新增、删除, 直到事务1结束 (事务一对表增加了表级排他锁, 其他事务不能对表增加共享锁或排他锁, 也就无法进行任何操作)</code></p></li><li><p>序列化事务产生的效果:</p></li><li><ul><li>无法读取其他事务已经修改单位提交的记录</li></ul></li><li><ul><li>在当前事务完成之前, 其他事务不能修改当前事务已经读取的记录</li></ul></li><li><ul><li>在当前事务完成之前, 其他事务插入的新记录, 其索引键值不能在当前事务的任何语句所读取的索引键范围中</li></ul></li></ul><p>在本项目中，并不涉及可序列化这一隔离级别，因此我们只需关注前三种隔离级别即可。</p><h2 id="二、Lock-Manager">二、Lock Manager</h2><p>Lock Manager 的结构：</p><p><img src="/img/lockmanager.png" alt="lockmanager.png"></p><p>Lock Manager 的作用是处理事务发送的锁请求，例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。</p><h3 id="2-1-Lock">2.1 Lock</h3><h4 id="1-检查事务的状态：">1.检查事务的状态：</h4><p>若 txn 处于 Abort/Commit 状态，抛逻辑异常，不应该有这种情况出现。<br>若 txn 处于 Shrinking 状态，则需要检查 txn 的隔离级别是否允许当前锁请求类型：</p><ul><li>READ_UNCOMMITTE 隔离级别中只允许使用X和IX锁(即只加写锁)</li><li>READ_UNCOMMITTE 隔离级别下收缩状态下不允许获得X和IX锁（写锁）</li><li>READ_COMMITTED 隔离级别在收缩状态下只允许使用IS、S锁（即读锁）</li><li>REPEATABLE_READ 隔离级别在收缩状态下不允许使用锁</li></ul><p>如果是对row加锁，要注意不能加意向锁，同时要检查是否持有 row 对应的 table lock。</p><h4 id="2-从map处获取对应的lock-request-queue">2.从map处获取对应的lock_request_queue</h4><p>从 table_lock_map_ 中获取 table 对应的 lock request queue。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</p><h4 id="3-检查锁请求是否为锁升级">3.检查锁请求是否为锁升级</h4><ul><li>遍历队列查看有没有与当前事务 id 相同的请求。如果存在这样的请求，则代表当前事务在此前已经得到了在此资源上的一把锁，接下来可能需要锁升级</li><li>判断此前授予锁类型是否与当前请求锁类型相同。若相同，则代表是一次重复的请求，直接返回。否则进行下一步检查。</li><li>判断当前资源上是否有另一个事务正在尝试升级（queue-&gt;upgrading_ == INVALID_TXN_ID）。若有，则终止当前事务，抛出 UPGRADE_CONFLICT 异常。因为不允许多个事务在同一资源上同时尝试锁升级。</li><li>判断升级锁的类型和之前锁是否兼容，不能反向升级。<strong>允许的升级规则</strong>：IS -&gt; [S, X, IX, SIX] ，S -&gt; [X, SIX]， IX -&gt; [X, SIX]， SIX -&gt; [X]</li><li>进行锁升级。</li><li><ul><li>释放当前已经持有的锁，包括lock_manager中的锁记录和事务中的锁记录。</li></ul></li><li><ul><li>升级的锁作为一个新的请求加入队列，插入的位置是当前第一个没有被授予的锁的位置。这里插入的位置是根据优先级规则来确定的。如果队列中存在锁升级请求，若锁升级请求正为当前请求，则优先级最高。否则代表其他事务正在尝试锁升级，优先级高于当前请求。若队列中不存在锁升级请求，则遍历队列。如果，当前请求是第一个 waiting 状态的请求，则代表优先级最高。如果当前请求前面还存在其他 waiting 请求，则要判断当前请求是否前面的 waiting 请求兼容。若兼容，则仍可以视为优先级最高。若存在不兼容的请求，则优先级不为最高。</li></ul></li><li><ul><li>并在 queue 中标记当前事务正在尝试升级</li></ul></li><li>若不是锁升级，则为平凡的锁请求，加入到request_queue_即可，<strong>在此处可以将 LockRequest的裸指针优化为智能指针。</strong></li></ul><h4 id="4-尝试获取锁">4.尝试获取锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//等待直到新锁被授予。</span><br><span class="line">      while (!GrantLock(upgrade_lock_request, lock_request_queue)) &#123;</span><br><span class="line">        //在 GrantLock() 中，Lock Manager 会判断是否可以满足当前锁请求。若可以满足，则返回 true，事务成功获取锁，并退出循环。</span><br><span class="line">        //若不能满足，则返回 false，事务暂时无法获取锁，在 wait 处阻塞，</span><br><span class="line">        //等待资源状态变化时被唤醒并再次判断是否能够获取锁。资源状态变化指的是什么？其他事务释放了锁。</span><br><span class="line">        lock_request_queue-&gt;cv_.wait(lock);</span><br><span class="line">        if (txn-&gt;GetState() == TransactionState::ABORTED) &#123;</span><br><span class="line">          lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;</span><br><span class="line">          lock_request_queue-&gt;request_queue_.remove(upgrade_lock_request);</span><br><span class="line">          lock_request_queue-&gt;cv_.notify_all();</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>GrantLock()判断锁请求lock_request是否可被授予。依次判断lock_request_queue中已经授予的锁是否和当前向获取的锁冲突，当全部不冲突才返回true，只要队列中有任意一个granted的锁与当前请求的锁冲突，则false。</p><h3 id="2-2-Unlock">2.2 Unlock</h3><p>Unlock的逻辑比较简单</p><ul><li>确保当前事务中持有该表的锁</li><li>table lock，在释放时需要先检查其下的所有 row lock 是否已经释放。</li><li>获取对应的 lock_request_queue</li><li>遍历请求队列，找到 unlock 对应的 granted 请求</li><li>在锁成功释放后，调用 cv_.notify_all() 唤醒所有阻塞在此 table 上的事务</li><li>找到对应的请求后，根据事务的隔离级别和锁类型修改其状态。</li><li><ul><li>当隔离级别为 REPEATABLE_READ 时，S/X 锁释放会使事务进入 Shrinking 状态。</li></ul></li><li><ul><li>当为 READ_COMMITTED 时，只有 X 锁释放使事务进入 Shrinking 状态。</li></ul></li><li><ul><li>当为 READ_UNCOMMITTED 时，X 锁释放使事务 Shrinking，S 锁不会出现。</li></ul></li></ul><h2 id="二、Deadlock-Detection">二、Deadlock Detection</h2><ul><li><p>此task利用一个unordered_map类型的waits_for_来表示事务之间的等待关系。wait for 是一个有向图，t1-&gt;t2 即代表 t1 事务正在等待 t2 事务释放资源。当 wait for 图中存在环时，即代表出现死锁，需要挑选事务终止以打破死锁。<br><br></p></li><li><p>我们并不需要时刻维护 wait for 图，而是在死锁检测线程被唤醒时，根据当前请求队列构建 wait for 图，再通过 wait for 图判断是否存在死锁。当判断完成后，将丢弃当前 wait for 图。下次线程被唤醒时再重新构建。<br><br></p></li><li><p>最常见的有向图环检测算法包括 DFS 和拓扑排序。在这里我们选用 DFS 来进行环检测。构建 wait for 图时要保证搜索的确定性。始终从 tid 较小的节点开始搜索，在选择邻居时，也要优先搜索 tid 较小的邻居。<br><br></p></li><li><p>构建 wait for 图的过程是，遍历 table_lock_map 和 row_lock_map 中所有的请求队列，对于每一个请求队列，用一个二重循环将所有满足等待关系的一对 tid 加入 wait for 图的边集。满足等待关系是指，对于两个事务 a 和 b，a 是 waiting 请求，b 是 granted 请求，则生成 a-&gt;b 一条边。<br><br></p></li><li><p>在发现环后，我们可以得到环上的所有节点。此时我们挑选 youngest 的事务将其终止。youngest 的事务即是tid 最大的事务。<br><br></p></li><li><p>挑选出 youngest 事务后，将此事务的状态设为 Aborted。并且在请求队列中移除此事务，释放其持有的锁，终止其正在阻塞的请求，并调用 cv_.notify_all() 通知正在阻塞的相关事务。此外，还需移除 wait for 图中与此事务有关的边。不是不用维护 wait for 图，每次使用重新构建吗？这是因为图中可能存在多个环，不是打破一个环就可以直接返回了。需要在死锁检测线程醒来的时候打破当前存在的所有环。</p></li></ul><h2 id="三、Concurrent-Query-Execution">三、Concurrent Query Execution</h2><p>此task是对查询执行的tuple进行并发控制，即对最基本三种算子SeqScan、Insert、Delete进行修改以满足并发控制。</p><h3 id="3-1-SeqScan">3.1 SeqScan</h3><ul><li>在初始化时 Init()中 进行并发控制，在 READ_UNCOMMITTED 下不用加锁，其余两种隔离级别下需要加锁，需先给表加IS锁</li><li>利用迭代器遍历时 Next()中 对行加锁，并且在遍历到结尾时释放锁，在 READ_COMMITTED 下，在 Next() 函数中，若表中已经没有数据，则提前释放之前持有的锁。在 REPEATABLE_READ 下，在 Commit/Abort 时统一释放，无需手动释放。并且先释放行锁再释放表锁。</li><li>实现一个 <code>Predicate pushdown to SeqScan</code> 的优化，即将 Filter 算子结合进 SeqScan 里，这样我们仅需给符合 predicate 的行加上 S 锁，减小加锁数量。利用这个while循环实现：</li><li><ul><li><code>while (plan_-&gt;filter_predicate_ != nullptr &amp;&amp;        !plan_-&gt;filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;());</code></li></ul></li></ul><h3 id="3-2-Insert-Delete">3.2 Insert &amp; Delete</h3><ul><li>Insert &amp; Delete 的操作类似，在 Init() 函数中，为表加上 IX 锁，在Next() 中为行加 X 锁。</li><li>若获取失败则抛 ExecutionException 异常。另外，这里的获取失败不仅是结果返回 false，还有可能是抛出了 TransactionAbort() 异常，例如 UPGRADE_CONFLICT，需要用 try catch 捕获。</li></ul><h2 id="四、Leaderboard-Task">四、Leaderboard Task</h2><h3 id="4-1-Predicate-Pushdown-to-SeqScan">4.1 Predicate Pushdown to SeqScan</h3><p>在第三节已经讲过此优化，即将 Filter 算子结合进 SeqScan 里，这样我们仅需给符合 predicate 的行加上 S 锁，减小加锁数量。利用一个while循环实现：<code>while (plan_-&gt;filter_predicate_ != nullptr &amp;&amp;            !plan_-&gt;filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;());</code></p><h3 id="4-2-Implement-UpdateExecutor">4.2 Implement UpdateExecutor</h3><p>实现Update这个算子，这样可以在原地直接修改 tuple，不需要先 Delete 再 Insert。利用tableheap中的UpdateTuple这个api实现即可，注意表加 IX 锁，行加 X 锁。返回更新的行的数量。</p><h3 id="4-3-Use-Index">4.3 Use Index</h3><p>修改IndexScan这个算子以让他满足并发控制，利用索引能大幅提高查询效率。具体做法是修改 IndexScan 算子，添加一种单点查询的情况。并在优化规则中尝试匹配形如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filter</span><br><span class="line">  |</span><br><span class="line">SeqScan</span><br></pre></td></tr></table></figure><p>的情况，并且 Filter 的 Predicate 形如 x=a，其中 x 是 ColumnValue，x 上有索引，a 是 ConstantValue。注意这条优化规则要在 MergeFilterScan 之前执行，否则 Filter 会直接被 Merge 到 SeqScan 里了。或者直接优化已经完成 Merge 的 SeqScan 算子。</p><p>在成功匹配后，提取出 a，并将查询计划更新为执行索引单点查询的 IndexScan 算子，使用 ScanKey(tuple{a}) 查询，需要构造一下包含 a 的 tuple。同样，单点查询时IndexScan 算子中要注意加锁，表 IS 行 S。</p><h2 id="总结-2">总结</h2><p>期间由于学业和各种原因断断续续的将近2个月才完成15445，但是收获的东西却比整个学期学校安排的课还多。感谢Andy和各位助教设计了此课程，下一步就是转战6.824了。</p>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-445 bustub Project3：Query Execution</title>
      <link href="/post/b4f7d51b.html"/>
      <url>/post/b4f7d51b.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/587566135">https://zhuanlan.zhihu.com/p/587566135</a></li><li><a href="https://www.bilibili.com/video/BV1bQ4y1Y7iT">https://www.bilibili.com/video/BV1bQ4y1Y7iT</a><br>知乎那个博主写的非常好，对我的启发很大，感激~</li></ul><p>Project3：Query Execution 主要是实现查询过程中的一系列算子，就难度，个人感觉是不如lab2的B+tree的，主要是需要阅读源码，并且要对Bustub的体系结构以及查询引擎的原理有一定的理解。</p><p>主要任务如下：</p><ul><li>Task1：Access Method Executors. 包含 SeqScan、Insert、Delete、IndexScan 四个算子。</li><li>Task2：Aggregation and Join Executors. 包含 Aggregation、NestedLoopJoin、NestedIndexJoin 三个算子。</li><li>Task3：Sort + Limit Executors and Top-N Optimization. 包含 Sort、Limit、TopN 三个算子，以及实现将 Sort + Limit 优化为 TopN 算子。</li><li>Leaderboard Task：为 Optimizer 实现新的优化规则，目前我仅做了hash join，其他优化如Join Reordering、Filter Push Down、Column Pruning等有时间了再完成</li></ul><h2 id="前置知识">前置知识</h2><p>下图是官网给出的BusTub的整体架构，在开始之前我会阐述一下一条sql语句在BusTub中的执行过程。(部分内容参考上面的知乎链接)</p><p><img src="/img/BusTub.png" alt="BusTub"></p><h3 id="Parse">Parse</h3><p>一条 sql 语句，首先经过 Parser 生成一棵抽象语法树 <code>AST</code>。Bustub 中采用了 libpg_query 库将 sql 语句 parse 为 AST。</p><h3 id="Binder">Binder</h3><p>Binder 的工作是将AST转变为Bustub AST，即将AST上的关键词绑定到数据库实体(c++类)上。</p><p>例如有这样一条 sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT colA FROM table1;</span><br></pre></td></tr></table></figure><p>其中 SELECT 和 FROM 是关键字，colA 和 table1 是标识符。Binder 遍历 AST，将这些词语绑定到相应的实体上。实体是 Bustub 可以理解的各种 c++ 类。绑定完成后，得到的结果是一棵 Bustub 可以直接理解的树。把它叫做 <code>Bustub AST</code>。</p><h3 id="Planner">Planner</h3><p>Planner对 <code>Bustub AST</code> 进行遍历生成初步的查询计划。查询计划也是一棵树的形式。同时查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。</p><p>例如这条 sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.y, t2.x FROM t1 INNER JOIN t2 ON t1.x = t2.y;</span><br></pre></td></tr></table></figure><p>生成的原始查询计划如下图(摘至上面提到的博客，下文类似的图均来自此博客)：<br><img src="/img/QueryPlan.png" alt="QueryPlan"></p><h3 id="Optimizer">Optimizer</h3><p>Optimizer 顾名思义，就是对查询计划进行修改优化，生成最终的查询计划。Optimizer 主要有两种实现方式：</p><ul><li>Rule-based. Optimizer 遍历初步查询计划，根据已经定义好的一系列规则，对 PlanNode 进行一系列的修改、聚合等操作。例如我们在 Task 3 中将要实现的，将 Limit + Sort 合并为 TopN。这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 Plan Node。</li><li>Cost-based. 这种 Optimizer 首先需要读取数据，利用统计学模型来预测不同形式但结果等价的查询计划的 cost。最终选出 cost 最小的查询计划作为最终的查询计划。</li></ul><p>另外值得一提的是，一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。一个比较典型的例子是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p><h3 id="Executor">Executor</h3><p>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：</p><ul><li>Iterator Model，或 Pipeline Model，或火山模型。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。可以看到，火山模型一次调用请求一条数据，占用内存较小，但函数调用开销大，特别是虚函数调用造成 cache miss 等问题。</li><li>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高。但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</li><li>Vectorization Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库都采用这种模型。</li></ul><p>Bustub 采用的是 Iterator Model。</p><p>此外，算子的执行方向也有两种：</p><ul><li>Top-to-Bottom. 从根节点算子开始，不断地 pull 下层算子的数据。</li><li>Bottom-to-Top. 从叶子节点算子开始，向上层算子 push 自己的数据。</li></ul><p>Bustub 采用 Top-to-Bottom。</p><p>在根节点算子处，就得到了我们想要查询的数据，一条 sql 语句完成了它的使命。</p><p>好了写到这里就可以开始做lab了，但是很快发现自己还是一头雾水，不知从哪里开始。在指导书中，有提示我们使用TableIterator和Catalog，这两个是什么呢？</p><p>TableIterator其实是访问table heap的工具，而table heap是管理 table 数据的结构，可以理解为，物理内存由 Table Page 来决定，而逻辑结构则由 Table Heap 来决定。</p><p>Catalog：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Catalog is a non-persistent catalog that is designed for use by executors within the DBMS execution engine. It handles table creation, table lookup, index creation, and index lookup</span><br></pre></td></tr></table></figure><p>数据库并非是通过直接访问数据页来完成数据的增删查改，而是通过维护一个内部目录，来 traces 数据库中的元数据，在本项目中，同样需要通过与 System Catalog 的交互，以查询有关表、索引以及架构的信息。Catalog 维护了几张 hashmap，保存了 table id 和 table name 到 table info 的映射关系。table id 由 Catalog 在新建 table 时自动分配，table name 则由用户指定。这里的 table info 包含了一张 table 的 metadata，有 schema、name、id 和指向 table heap 的指针。系统的其他部分想要访问一张 table 时，先使用 name 或 id 从 Catalog 得到 table info，再访问 table info 中的 table heap。</p><p>查看task1我们需要完成的SeqScanExecutor类，可以看到引入了AbstractExecutor，ExecutorContext，SeqScanPlanNode，Tuple，Schema，大概的功能如下：</p><p>AbstractExecutor：火山式元组迭代器模型的实现，也是其余 Executor 的基类<br>ExecutorContext：存储了一个 Executor 的过程中所有必要的内容，包括 Transaction、Catalog、Buffer Pool Manager、Log Manager、Lock Manager、Transaction Manager对象和获取对象的接口。<br>SeqScanPlanNode：继承自 AbstractPlanNode，表示执行计划结点类型，每个节点会接收子节点的输出元组作为输入，且顺序相当重要。接口则主要涉及到执行计划的输出、获取子节点等。<br>Tuple：对应数据表中的一行数据。每个 tuple 都由 RID 唯一标识。RID 由 page id + slot num 构成。tuple 由 value 组成，value 的个数和类型由 table info 中的 schema 指定。<br>Schema：类如其名，主要接口多是关于获取表中的列的相关信息</p><p>最后，用上面提到的博客中的一张图结尾，很好的画出了table的结构，也揭示了我们应该怎么解决task：<br><img src="/img/BustubTable.png" alt="BustubTable"></p><h2 id="Task1：Access-Method-Executors">Task1：Access Method Executors</h2><h3 id="SeqScan">SeqScan</h3><p>引入TableIterator和TableInfo，在next中对TableIterator叠加即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TableIterator table_iterator_;</span><br><span class="line">const TableInfo *table_info_;</span><br></pre></td></tr></table></figure><p>TableIterator和TableInfo的获取我们都需要通过上文提到的ExecutorContext中的Catalog来得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;table_info_ = this-&gt;exec_ctx_-&gt;GetCatalog()-&gt;GetTable(plan_-&gt;table_oid_);</span><br><span class="line">this-&gt;table_iterator_ = table_info_-&gt;table_-&gt;Begin(exec_ctx_-&gt;GetTransaction());</span><br></pre></td></tr></table></figure><h3 id="Insert">Insert</h3><p>利用api将tuple追加至table尾部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool inserted = table_info_-&gt;table_-&gt;InsertTuple(insert_tuple, rid, exec_ctx_-&gt;GetTransaction());</span><br></pre></td></tr></table></figure><p>同时要注意更新与 table 相关的所有 index。index 与 table 类似，同样由 Catalog 管理。需要注意的是，由于可以对不同的字段建立 index，一个 table 可能对应多个 index，所有的 index 都需要更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (inserted) &#123;</span><br><span class="line">      std::for_each(table_indexes_.begin(), table_indexes_.end(),</span><br><span class="line">                    [&amp;insert_tuple, &amp;rid, &amp;table_info = table_info_, &amp;exec_ctx = exec_ctx_](IndexInfo *index) &#123;</span><br><span class="line">                      index-&gt;index_-&gt;InsertEntry(insert_tuple.KeyFromTuple(table_info-&gt;schema_, index-&gt;key_schema_,index-&gt;index_-&gt;GetKeyAttr()),</span><br><span class="line">                      *rid, exec_ctx-&gt;GetTransaction());</span><br><span class="line">                    &#125;);</span><br><span class="line">      insert_count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Next() 返回一个包含一个 integer value 的 tuple，表示 table 中有多少行受到了影响。</p><h3 id="Delete">Delete</h3><p>只需将insert中的相应api更改一下即可，Delete 时，并不是直接删除，而是将 tuple 标记为删除状态，也就是逻辑删除。（在事务提交后，再进行物理删除，Project 3 中无需实现）</p><h3 id="IndexScan">IndexScan</h3><p>利用Project 2 中实现的 B+Tree Index Iterator来查找，本项目中执行计划的索引对象始终为BPlusTreeIndexForOneIntegerColumn，可以安全地将其转化并存储在执行器对象中，可以从索引对象BPlusTreeIndexForOneIntegerColumn构造索引迭代器，扫描所有键和元组 ID，从表堆中查找元组，并按索引键的顺序发出所有元组作为执行器的输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IndexScanExecutor::IndexScanExecutor(ExecutorContext *exec_ctx, const IndexScanPlanNode *plan)</span><br><span class="line">    : AbstractExecutor(exec_ctx),</span><br><span class="line">      plan_&#123;plan&#125;,</span><br><span class="line">      index_info_&#123;this-&gt;exec_ctx_-&gt;GetCatalog()-&gt;GetIndex(plan_-&gt;index_oid_)&#125;,</span><br><span class="line">      table_info_&#123;this-&gt;exec_ctx_-&gt;GetCatalog()-&gt;GetTable(index_info_-&gt;table_name_)&#125;,</span><br><span class="line">      tree_&#123;dynamic_cast&lt;BPlusTreeIndexForOneIntegerColumn *&gt;(index_info_-&gt;index_.get())&#125;,</span><br><span class="line">      iter_&#123;tree_-&gt;GetBeginIterator()&#125; &#123;&#125;</span><br></pre></td></tr></table></figure><p>Next()中仅需访问iter_即可，但是要注意索引中保存的是RID，还需要利用 RID 去 table 查询对应的 tuple。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*rid = (*iter_).second;</span><br><span class="line">  auto result = table_info_-&gt;table_-&gt;GetTuple(*rid, tuple, exec_ctx_-&gt;GetTransaction());</span><br><span class="line">  ++iter_;</span><br><span class="line"></span><br><span class="line">  return result;</span><br></pre></td></tr></table></figure><h2 id="Task-2-Aggregation-Join-Executors">Task 2 Aggregation &amp; Join Executors</h2><h3 id="Aggregation">Aggregation</h3><p>聚合的作用在于将一组值按照给定的结果进行合并。AggregationPlanNode有以下几类：</p><ul><li>GROUP BY（分组）</li><li>COUNT/COUNT(*)、MIN、MAX（规则）</li></ul><p>指导书中有以下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AggregationExecutor 不需要考虑处理 “HAVING” 过滤条件。原本 HAVING 的作用是对分组后的结果进行条件筛选，也可以用于在聚合计算后对聚合结果进行条件筛选。而在本实验中，planner 会将 having 处理成为 FilterPlanNode。因此，聚合执行器只需要对每组输入执行聚合，也就只有一个子节点（见执行计划输出结果，为MockScan） =&gt; 原本 “HAVING” 关键字也有聚合效果，但是本实验把它当作了 Filter 算子，因此 Aggregate 算子只需要考虑把“扫描”得到的结果做聚合即可。</span><br><span class="line"></span><br><span class="line">本实验中可以假设所有的聚合结果（即从数据表中得到的数据）都保存在内存中的哈希表里，即无需按照课程中提到的两阶段哈希实现 =&gt; 无需考虑使用BPM管理内存</span><br></pre></td></tr></table></figure><p>同时注意到Aggregation 是 pipeline breaker，意思是在整个查询计划的执行过程（即Pipeline）中，其他的算子，例如SeqSacn，一步一步往下执行并不会影响最终的遍历结果，但是由于聚合操作需要遍历完成整张表，不能遍历到一半就输出聚合结果，万一后面还有与当前字段重复的值呢？再新增到此前得到的结果里去，会极大地增大查询计划的执行难度。<br>因此，在 Init Aggregation 时，就需要把分组的结果都算出来，而不是像 Task#1 中，可以一条又一条tuple地去 Next 执行。在Init过程中，结果保存到SimpleAggregationHashTable aht_;中，next中利用SimpleAggregationHashTable::Iterator aht_iterator_;来访问即可</p><p>注意在实现GenerateInitialAggregateValue函数中，count()的初值设置为0，其余的设置为null</p><h3 id="NestedLoopJoin">NestedLoopJoin</h3><p>NestedLoopJoin的核心思想还是比较简单的，伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach tuple r in R: (Outer)</span><br><span class="line">    foreach tuple s in S: (Inner)</span><br><span class="line">        emit, if r and s match</span><br></pre></td></tr></table></figure><p>在实现时，主要是注意INIT过程中需要将right_tuple都先保存下来。同时在next()也要记录上一次右表匹配到的位置，否则左表的每一行只会产生一行输出。还需要注意处理left join的空值</p><h3 id="NestedIndexJoin">NestedIndexJoin</h3><p>如果查询包含具有 equal 条件的 Join，而且连接的外表在查询条件上具有索引，则使用 NestedIndexJoinPlanNode.</p><p>此处的核心思想与NestedLoopJoin类似，但是不需要预先保存right_tuple，只需在利用左表行去匹配右表时，利用索引去查找右表中所匹配的节点，保存他们RID，然后处理即可。</p><p>索引的使用方式与IndexScan类似，只需要利用到tree_-&gt;ScanKey这个api来查找对应的RID</p><p>同时注意Nested Index Join 的 Schema 中只有一个 child，用于传输 Join 中与外表(left table)对应的tuples，而非像 Nested Loop Join 中的有两个子节点</p><h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization">Task #3: Sort + Limit Executors and Top-N Optimization</h2><h3 id="Sort">Sort</h3><p>ORDER BY 匹配的是没有与索引绑定的键，BusTub 将对ORDER BY 运算符使用 SortPlanNode。</p><p>在Init中，与Aggregation的处理类似，需要先将所有的tuple保存下来，然后利用std::sort进行排序即可。排序依据于 order_bys中的keys，如果查询并不包含排序方向，就默认按照 ASC 执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::sort(</span><br><span class="line">      tuples_.begin(), tuples_.end(),</span><br><span class="line">      [order_bys = plan_-&gt;order_bys_, schema = child_executor_-&gt;GetOutputSchema()](const Tuple &amp;tuple_a,const Tuple &amp;tuple_b) &#123;</span><br><span class="line">        for (const auto &amp;order_key : order_bys) &#123;</span><br><span class="line">          switch (order_key.first) &#123;</span><br><span class="line">            case OrderByType::INVALID:</span><br><span class="line">            case OrderByType::DEFAULT:</span><br><span class="line">            case OrderByType::ASC:</span><br><span class="line">              if (static_cast&lt;bool&gt;(order_key.second-&gt;Evaluate(&amp;tuple_a, schema)</span><br><span class="line">                                        .CompareLessThan(order_key.second-&gt;Evaluate(&amp;tuple_b, schema)))) &#123;</span><br><span class="line">                return true;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">            case OrderByType::DESC:</span><br><span class="line">              if (static_cast&lt;bool&gt;(order_key.second-&gt;Evaluate(&amp;tuple_a, schema)</span><br><span class="line">                                        .CompareGreaterThan(order_key.second-&gt;Evaluate(&amp;tuple_b, schema)))) &#123;</span><br><span class="line">                return true;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">              &#125;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Limit">Limit</h3><p>利用一个变量记录emit了多少个tuple，当大于这个值是，直接返回false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_int32_t count_ = 0;</span><br></pre></td></tr></table></figure><h3 id="Top-N-Optimization">Top-N Optimization</h3><p>利用优先队列priority_queue来处理tuples，最后将priority_queue里的tuple给push到一个vector中，next()中依次访问这个vector即可。</p><p>只是实现这个算子是不够的，还需要我们完成OptimizeSortLimitAsTopN这个优化规则。我们只需遍历plan tree，当遇到limit节点时，判断其孩子节点是否是Sort，如果是Sort，则将这两个节点替换为一个 TopN。还是比较简单的。</p><h2 id="Leaderboard-Task">Leaderboard Task</h2><p>具体的要求我就不贴了，简而言之是要我们实现hash join这个算子，实现一系列优化规则，包括但不限于：Join Reorder 、Correctly Pick up Index、Predicate Push-down、 Column Pruning</p><p>我仅完成了hash join，优化规则有待后续完成</p><p>对于hash join，利用src/include/common/util/hash_util.h 里的 HashValue 函数将 <strong>join key</strong> hash 为 hash_t 类型，然后把 hash_t 作为键。join key由下面这个api得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">right_join_key = plan_-&gt;RightJoinKeyExpression().Evaluate(&amp;tuple, plan_-&gt;GetRightPlan()-&gt;OutputSchema());</span><br></pre></td></tr></table></figure><p>Init()中，将right_tuple以right_join_key为键push到哈希表中，随后对于left_child_executor_-&gt;Next(&amp;tuple, &amp;rid)得到的左表行，在哈希表中得到与left_join_key匹配的tuples，然后将这些匹配的行压入到一个vector中，在next()访问这个vector即可。</p><h2 id="总结">总结</h2><p>做lab3的时候一度做不下去了，因为源码读的我太痛苦了，还好坚持了下来，最后看到gradescope的成绩也是一整个心情舒畅，希望自己再接再厉吧。<br>回归到这个lab，自己收获还是很多的，对于Bustub 的架构以及查询计划有了一个深入的了解。</p>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终总结</title>
      <link href="/post/c262e439.html"/>
      <url>/post/c262e439.html</url>
      
        <content type="html"><![CDATA[<p>转眼间2023就没了，从写完<a href="https://v1per3.github.io/post/53d98f9e.html">2023上半年总结</a>到现在，自己感觉自己其实并没有太多的进步，原因是各方面的，但是呢，又想着还是要把写blog的习惯保持下去，所以就稍微写写吧。</p><h2 id="回顾一下-2">回顾一下</h2><p>写上一篇blog的时候，我还在西安，现在呢则在合肥，下一篇呢估计就会在苏州了。过去的半年自己给自己的压力算是比较小的，暑假就看了看单片机和操作系统的东西，并没有想着成系统的卷什么,更多的都是在玩。到了科大后，课后的闲暇时间自己更多是打会球，打打游戏或者看看感兴趣的东西，前2个月主要把linux和现代c++捡起来重新学了一遍，后面则开始做一些国外的课设，因为自己选修的课的原因，做了一半6.824，后面就没做了，想着后面空了把go系统学一遍再做一次。从11月末到现在自己断断续续的在做cmu15445的课设，因为中间经常偷懒，到现在都才做了前两个lab &gt;&lt;。至于力扣则是每天都在刷，周赛也会时不时的打打，但是现在差不多也到瓶颈了，中等基本能做，困难基本不会，想着就这样保持着吧，能面试就行了。</p><h2 id="展望一下-2">展望一下</h2><p>明年的首要目标肯定就是好好学习找到个好实习，去大城市感悟一下自己的牛马人生(&gt;&lt;),压力要上来了，所以要加油了！<br>首先把cmu15445的课设做出来，然后把go系统学一遍，做完6.824，然后开始准备春招找实习，首找go，其次cpp，如果时间富足，中间可以再学一下cs144。</p><h2 id="总结一下-2">总结一下</h2><p>感谢我的家人们，过去的一年，我的爷爷也离开了我，也让我更加明白了家人的可贵，希望家人们都可以永远健康，快乐<br>谢谢朋友和同学的帮助，希望大家都心想事成<br>2024，加油！</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-445 bustub Project2：B+ Tree</title>
      <link href="/post/bcba2380.html"/>
      <url>/post/bcba2380.html</url>
      
        <content type="html"><![CDATA[<p>Project2是自己实现一个B+树，CMU对于本次项目一共给了两个checkpoint，首先就是对B+树的基本操作以及基本结构的实现，包括插入、删除、查找，第二个则是对于并发访问的支持。本次项目虽然只是实现一个B+树，但是由于涉及到了前一章的BufferPoolManger，需要注意的细节非常多，所以还是花了不少时间。</p><p>对于此类数据结构，可以参考一个网站，可以很好的使用图形化理解其变化过程:<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><p>对于B+树的介绍就不在此赘述了，百度有很多解释，同时看了前两篇博客，源代码太多了反而影响阅读，因此本篇以讲解思路为主，记录遇到的问题和需要注意到的细节，接下来进入正题。</p><h2 id="B-树的基本数据结构">B+树的基本数据结构</h2><p>B+树中有内部节点和叶节点两种结构，它们存储的数据格式和内容不同。在此项目中，CMU为我们提供了一个基类BPlusTreePage,包含节点类型、当前容量、父节点信息等，<strong>规定 parent_page_id_ 为 INVALID_PAGE_ID 表示根节点</strong>；内部节点BPlusTreeInternalPage和叶节点BPlusTreeLeafPage都继承自BPlusTreePage，节点利用pair&lt;KeyType, ValueType&gt;的数组来进行数据存储：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MappingType std::pair&lt;KeyType, ValueType&gt;</span><br><span class="line">// Flexible array member for page data.</span><br><span class="line">  MappingType array_[1];</span><br></pre></td></tr></table></figure><p>对于内部节点，其储存的第一个键是无效的，即其理论结构为： &lt;无效键，指针，键，指针，键…，键，指针&gt;</p><p>而对于叶节点，其储存的键和指针都是有效的，即其理论结构为： &lt;键，指针，键，指针，键…，键，指针&gt;</p><p>内部节点虽然实现时存储的都是范式中的ValueType，但实际存储的就是叶结点的page_id，而叶节点存储的则是实际的数据的指针,这也对应B+树的性质，内部节点不保存实际数据，实际数据的相关信息都保存在叶结点中。由于要得到实际数据还需要利用BufferPoolManager来获取，因此该数据库中的索引均为非聚簇索引</p><p>array_[1] 等价于一个指针，但是其指向的数据并不需要我们new，而是由上一章我们实现的Buffer Pool Manager来分配，其分配的页的data即是我们需要的value，因此此处也需要用到reinterpret_cast(关于reinterpret_cast可以咨询gpt)。</p><p>节点对象的生命周期由我们上节实现的 BufferPoolManager 管理：取一个页面，用 FetchPage；使用结束归还一个页面，用 UnpinPage。因此，我们可以得到BPlusTreePage 中 page_id_ 成员的另一个含义：它不仅是 B+ 树中节点的编号，同时也是这个节点使用的 Page 在 BufferPool 中的编号，也可以理解为起到一个&quot;指针&quot;的效果。</p><p>写在前面：如果发现gradescope有一个测试总是过不了，大概率是Unpin和fetch的问题，没能保持一致导致空间溢出了，可以在BFM中相应的函数中打印日志来debug，这个过程是极其痛苦的。</p><p>了解了数据结构，接下来就是实现B+树的基本操作了，包括插入、删除、查找。</p><h2 id="B-树基本操作">B+树基本操作</h2><h3 id="查找-GetValue">查找(GetValue)</h3><p>查找的逻辑比较简单，给定一个键 x ，查找其是否在 B+ 树中存在。实现逻辑是先找到键可能在的叶节点，然后扫描一遍叶节点的内容确定是否存在。重点则是在找叶节点：</p><ul><li>从根节点开始，每次在内部节点中查找 x 所在的指针即value，实际是一个page_id，直到叶节点</li><li>循环时找内部节点中第一个比 x 大的键，取其左侧的值即可（k[0]无效），而这样不能探测到 x 比所有 k 都大的情况，所以要将 next_page_id 初始化为最右侧的键,即<code>next_page_id = internal_page-&gt;ValueAt(internal_page-&gt;GetSize() - 1);</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line">auto BPLUSTREE_TYPE::FindLeaf(const KeyType &amp;key) -&gt; Page *&#123;</span><br><span class="line">  page_id_t next_page_id = root_page_id_;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    Page* page = buffer_pool_manager_-&gt;FetchPage(next_page_id);</span><br><span class="line">    auto next_page = reinterpret_cast&lt;BPlusTreePage *&gt;(page-&gt;GetData());</span><br><span class="line">    if (next_page-&gt;IsLeafPage()) &#123;</span><br><span class="line">      return page;</span><br><span class="line">    &#125;</span><br><span class="line">    auto internal_page = static_cast&lt;InternalPage *&gt;(next_page);</span><br><span class="line"></span><br><span class="line">    // init next_page_id as the rightmost pointer</span><br><span class="line">    next_page_id = internal_page-&gt;ValueAt(internal_page-&gt;GetSize() - 1);</span><br><span class="line">    // if fount a greater key , set next_page_id as the pointer at its left</span><br><span class="line">    for (int i = 1; i &lt; internal_page-&gt;GetSize() ; i++) &#123; // ignore first key</span><br><span class="line">      if (comparator_(internal_page-&gt;KeyAt(i), key) &gt; 0) &#123;</span><br><span class="line">        next_page_id = internal_page-&gt;ValueAt(i-1);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(internal_page-&gt;GetPageId(),false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到叶结点后再GetValue中只需要遍历叶结点的键和key来比较就行了，同时一定要记得<strong>UnpinPage</strong></p><h3 id="插入-Insert">插入(Insert)</h3><p>B+树的插入流程如下：</p><ul><li>如果树为空，则创建根节点，并将其作为叶节点插入，对于<strong>每次root_page_id_ 更新时都要调用一次 UpdateRootPageId</strong>。</li><li>利用查询中的函数从根节点向下查找到键值应该所在的叶节点。如果叶结点已经存在该值，则直接返回false即可。</li><li>如果叶节点 插入后 达到了 max_size，则要进行分裂（split），创建一个新的叶节点，将原节点的一半内容拷贝到新节点，分裂点的键插入父节点，该键对应的值指向新的叶节点。</li><li>如果父节点不存在，说明是第一个叶节点兼根节点，需要创建一个新的根</li><li>如果父节点（内部节点）插入前 达到了 max_size，也要递归进行分裂并向上插入，同时将原节点的一半子节点的 parent_id_ 指针指向新的内部节点。如果根节点满了，则要创建一个新的根节点，使得 B+ 树长高一层。</li><li>同时要注意叶结点和内部节点判断满的条件是不一样的，叶结点在插入后等于max_size则需要分裂，而内部节点在插入前等于max_size则需要分裂并向上插入。</li></ul><p>核心代码如下：一些辅助函数就不给了，函数名字基本就彰显了其作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line">auto BPLUSTREE_TYPE::Insert(const KeyType &amp;key, const ValueType &amp;value, Transaction *transaction) -&gt; bool &#123;</span><br><span class="line">  if (IsEmpty()) &#123;</span><br><span class="line">    Page *page = buffer_pool_manager_-&gt;NewPage(&amp;root_page_id_);</span><br><span class="line">    UpdateRootPageId(1); // 1 means inserting a new root page</span><br><span class="line">    auto leaf_page = reinterpret_cast&lt;LeafPage *&gt;(page-&gt;GetData());</span><br><span class="line">    leaf_page-&gt;Init(root_page_id_,INVALID_PAGE_ID,leaf_max_size_);</span><br><span class="line">    leaf_page-&gt;SetKeyValueAt(0,key,value);</span><br><span class="line">    leaf_page-&gt;IncreaseSize(1);</span><br><span class="line">    leaf_page-&gt;SetNextPageId(INVALID_PAGE_ID);</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(root_page_id_,true);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Page *page = FindLeaf(key);</span><br><span class="line">  auto leaf_page = reinterpret_cast&lt;LeafPage *&gt;(page-&gt;GetData());</span><br><span class="line">  for (int i = 0; i &lt; leaf_page-&gt;GetSize() ; i++) &#123;</span><br><span class="line">    if (comparator_(leaf_page-&gt;KeyAt(i), key) == 0) &#123;</span><br><span class="line">      buffer_pool_manager_-&gt;UnpinPage(leaf_page-&gt;GetPageId(),false);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  leaf_page-&gt;Insert(key,value,comparator_);</span><br><span class="line">  if (leaf_page-&gt;GetSize() &lt; leaf_max_size_) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(leaf_page-&gt;GetPageId(),false);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //leaf page is full , split it</span><br><span class="line">  page_id_t new_page_id;</span><br><span class="line">  Page *new_page = buffer_pool_manager_-&gt;NewPage(&amp;new_page_id);</span><br><span class="line">  auto new_leaf_page = reinterpret_cast&lt;LeafPage *&gt;(new_page-&gt;GetData());</span><br><span class="line">  new_leaf_page-&gt;Init(new_page_id,leaf_page-&gt;GetParentPageId(),leaf_max_size_);</span><br><span class="line">  new_leaf_page-&gt;SetNextPageId(leaf_page-&gt;GetNextPageId());</span><br><span class="line">  leaf_page-&gt;SetNextPageId(new_page_id);</span><br><span class="line">  //move half data to new leaf page</span><br><span class="line">  leaf_page-&gt;MoveDataTo(new_leaf_page,(leaf_max_size_ + 1)/2);</span><br><span class="line"></span><br><span class="line">  BPlusTreePage *old_tree_page = leaf_page;</span><br><span class="line">  BPlusTreePage *new_tree_page = new_leaf_page;</span><br><span class="line">  KeyType split_key = new_leaf_page-&gt;KeyAt(0);</span><br><span class="line"></span><br><span class="line">  // recursively insert </span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // if the old page is root , create a new parent internal page as root</span><br><span class="line">    if (old_tree_page-&gt;IsRootPage()) &#123;</span><br><span class="line">      Page *new_page = buffer_pool_manager_-&gt;NewPage(&amp;root_page_id_);</span><br><span class="line">      auto new_root_page = reinterpret_cast&lt;InternalPage *&gt;(new_page-&gt;GetData());</span><br><span class="line">      new_root_page-&gt;Init(root_page_id_,INVALID_PAGE_ID,internal_max_size_);</span><br><span class="line">      // split_key next is not used , just a placeholder</span><br><span class="line">      new_root_page-&gt;SetKeyValueAt(0,split_key,old_tree_page-&gt;GetPageId());</span><br><span class="line">      new_root_page-&gt;SetKeyValueAt(1,split_key,new_tree_page-&gt;GetPageId());</span><br><span class="line">      new_root_page-&gt;IncreaseSize(2);</span><br><span class="line">      old_tree_page-&gt;SetParentPageId(root_page_id_);</span><br><span class="line">      new_tree_page-&gt;SetParentPageId(root_page_id_);</span><br><span class="line">      UpdateRootPageId();</span><br><span class="line">      buffer_pool_manager_-&gt;UnpinPage(root_page_id_,true);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // otherwise</span><br><span class="line">    page_id_t parent_page_id = old_tree_page-&gt;GetParentPageId();</span><br><span class="line">    Page *parent_page = buffer_pool_manager_-&gt;FetchPage(parent_page_id);</span><br><span class="line">    auto parent_internal_page = reinterpret_cast&lt;InternalPage *&gt;(parent_page-&gt;GetData());</span><br><span class="line">    parent_internal_page-&gt;Insert(split_key,new_tree_page-&gt;GetPageId(),comparator_);</span><br><span class="line">    new_tree_page-&gt;SetParentPageId(parent_internal_page-&gt;GetPageId());</span><br><span class="line">    if (parent_internal_page-&gt;GetSize() &lt;= internal_max_size_) &#123;</span><br><span class="line">      buffer_pool_manager_-&gt;UnpinPage(parent_page_id,true);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // parent is also full</span><br><span class="line">    page_id_t new_page_id;</span><br><span class="line">    Page *new_page = buffer_pool_manager_-&gt;NewPage(&amp;new_page_id);</span><br><span class="line">    auto new_internal_page = reinterpret_cast&lt;InternalPage *&gt;(new_page-&gt;GetData());</span><br><span class="line">    new_internal_page-&gt;Init(new_page_id,parent_internal_page-&gt;GetParentPageId(),internal_max_size_);</span><br><span class="line">    int new_page_size = (internal_max_size_ + 1) / 2;</span><br><span class="line">    int start_index = parent_internal_page-&gt;GetSize() - new_page_size;</span><br><span class="line">    for ( int i = start_index, j = 0 ; i &lt; parent_internal_page-&gt;GetSize(); ++i,++j) &#123;</span><br><span class="line">      new_internal_page-&gt;SetKeyValueAt(j,parent_internal_page-&gt;KeyAt(i),parent_internal_page-&gt;ValueAt(i));</span><br><span class="line">      Page *page = buffer_pool_manager_-&gt;FetchPage(parent_internal_page-&gt;ValueAt(i));</span><br><span class="line">      auto tree_page = reinterpret_cast&lt;BPlusTreePage *&gt;(page-&gt;GetData());</span><br><span class="line">      tree_page-&gt;SetParentPageId(new_page_id); // modify child&#x27;s parent</span><br><span class="line">      buffer_pool_manager_-&gt;UnpinPage(tree_page-&gt;GetPageId(),true);</span><br><span class="line">    &#125;</span><br><span class="line">    parent_internal_page-&gt;SetSize(internal_max_size_ - new_page_size + 1);</span><br><span class="line">    new_internal_page-&gt;SetSize(new_page_size);</span><br><span class="line"></span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(old_tree_page-&gt;GetPageId(),true);</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(new_tree_page-&gt;GetPageId(),true);</span><br><span class="line">    old_tree_page = parent_internal_page;</span><br><span class="line">    new_tree_page = new_internal_page;</span><br><span class="line">    split_key = new_internal_page-&gt;KeyAt(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(old_tree_page-&gt;GetPageId(),true);</span><br><span class="line">  buffer_pool_manager_-&gt;UnpinPage(new_tree_page-&gt;GetPageId(),true);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-Remove">删除(Remove)</h3><p>在实现删除之前需要先将迭代器实现了，主要是完成IndexIterator这个类的数据，我设计的成员变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line"> // add your own private member variables here</span><br><span class="line"> Page *page_ = nullptr;</span><br><span class="line"> B_PLUS_TREE_LEAF_PAGE_TYPE *leaf_page_ = nullptr;</span><br><span class="line"> int index_in_leaf_ = 0;</span><br><span class="line"> BufferPoolManager * buffer_pool_manager_ = nullptr; </span><br></pre></td></tr></table></figure><p>具体的代码我就不写了，比较简单，主要就是找index_in_leaf_这个索引的值，同时注意在析构函数中UnpinPage，在++操作中要完成跳页的处理(利用GetNextPageId)</p><p>在BPlusTree 类，实现三个函数，对于Begin(),我们一路向下找到最左边的叶节点即可，也不赘述了</p><p>重点则是B+树的删除操作:</p><ul><li>如果是空树，返回。否则找到键所在叶节点，从叶节点中删除键值。如果删除后没有下溢出或该叶节点是根节点，返回。</li><li>如果删除后叶节点下溢出（键值对个数小于 min_size , min_size = ( max_size + 1 ) / 2 ，考察兄弟节点：如果兄弟节点键值对个数大于 min_size ，从兄弟节点借一个键值对（左侧兄弟就借尾，右侧兄弟就借头），<strong>同时用借的键替换父节点中该节点位置的键</strong>。</li><li>如果兄弟节点键值对数不够借出，将该节点与兄弟节点合并，更新 next_page_id_，同时删除父节点中该位置的键值。</li><li>如果删除后父节点（内部节点）下溢出，仍然是借&amp;修改或合并&amp;删除两种方法处理，但规则与叶节点不同：借&amp;修改时，要把兄弟节点的键上移，父节点的键下移给该节点，同时把一个兄弟节点的值给该节点；合并&amp;删除时，要把父节点的键和兄弟节点的键值一块和该节点合并。</li><li>如果下溢出达到根节点，而且根节点只剩下一个子节点，说明树应该减少一层，将唯一的子节点设为新的根。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line">void BPLUSTREE_TYPE::Remove(const KeyType &amp;key, Transaction *transaction) &#123;</span><br><span class="line">  if (IsEmpty()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  Page *page = FindLeaf(key);</span><br><span class="line">  LeafPage *leaf_page = reinterpret_cast&lt;LeafPage *&gt;(page-&gt;GetData());</span><br><span class="line">  leaf_page-&gt;Remove(key,comparator_);</span><br><span class="line">  if (leaf_page-&gt;IsRootPage()) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;UnpinPage(leaf_page-&gt;GetPageId(),true);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (leaf_page-&gt;GetSize() &lt; leaf_page-&gt;GetMinSize()) &#123;</span><br><span class="line">    HandleFlow(leaf_page,transaction);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理溢出的代码就不贴了，太多了，可以看云服务器上的源代码，主要是优先考虑右侧的节点，首先是尝试借，借不到就和兄弟节点合并。</p><p>对于<strong>叶结点</strong>，父节点中更新的键，如果兄弟在左边，则用该节点新的第 0 个键（也就是刚借过来的），在右边用兄弟的第 0 个键即可（兄弟原来的第 1 个键，0 号被借走）。</p><p>对于<strong>内部节点</strong>：</p><ul><li>如果兄弟节点在左边：父节点中对应的键下移到该节点的key[1]处，兄弟节点的key[size-1]上移变为父节点的key，该节点 value[1] 改为原 value[0]，value[0] 改为兄弟 value[size-1]，兄弟节点 key,value[size-1] 删除。</li><li>如果兄弟节点在右边：父节点中对应的值右侧的key下移到该节点最右侧，对应value为兄弟节点的value[0]，父节点的key改为兄弟节点的key[1],然后删除兄弟节点的value[0]和key[1]。</li></ul><p>对于<strong>合并</strong>：</p><ul><li>把右侧节点的键值对插入左侧节点</li><li>将左侧节点的 next_page_id_ 指针更新为右侧节点的</li><li>在父节点中移除右节点值位置的键值</li><li>对于内部节点，我们需要将父节点中右节点位置的 key与右节点 value[0]作为一个键值对插入到左节点的尾部。</li></ul><h2 id="并发控制">并发控制</h2><p>在cmu的课件当中有针对该部分的知识做讲解，主要是有两种策略，一种是悲观锁，另外一种则是乐观锁。由于查找只需读锁，所以下面悲观锁与乐观锁的区别都是在插入与删除上。<br><strong>悲观锁</strong>：总是先对祖先上写锁，然后对子节点上写锁，如果子节点是安全节点，那么就可以将其祖先结点的所有写锁释放，否则继续持有。<br><strong>安全节点</strong>：</p><ul><li>如果操作为插入，则没有满的节点为安全节点；</li><li>如果操作为删除，则超过半满的节点为安全节点；</li><li>如果操作为读取，则所有节点均为安全节点。</li></ul><p><strong>乐观锁</strong>：乐观地认为插入/删除不会发生分裂或合并，于是只需沿路径像读取一样获取和释放读锁，然后检查叶节点：如果叶节点安全，那么假设正确，对其更新只需要叶节点的写锁；而如果不安全，说明假设错误，重新像悲观锁一样加一遍锁。</p><p>在该项目中，我们需要用到cmu给我们提高的一个参数：transaction，它携带了一个数据库事务的所有信息，这里我们只需要关注其两个成员 std::shared_ptr&lt;std::deque&lt;Page *&gt;&gt; page_set_ 和 std::shared_ptr&lt;std::unordered_set&lt;page_id_t&gt;&gt; deleted_page_set_，分别可以记录 B+ 树查找过程中访问的页面集合和删除的页面集合。同时要注意一个细节，对于根节点的访问我们需要在BPlusTree这个类中定义一个root_latch_来保护，而这个独立定义的锁如何放入 transaction 的 page_set 集合呢？我们规定：在 page_set 中放入一个 nullptr，表示锁定 root_latch_</p><p>同时要注意cmu项目任务介绍有提到需要先 Unlock 后 Unpin，因为 Unpin 后这个 Page 的 pin_count_可能降为 0，buffer_pool_manager 可能会将该 Page 指针的内容改写为另一个 Page 的，导致 Unlock 错误</p><p>对于确定为安全节点的 Page，我们只需要遍历transaction的page_set，然后释放这里面的祖先的锁即可。</p>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-445 bustub Project1：Buffer Pool Manager</title>
      <link href="/post/c154d63.html"/>
      <url>/post/c154d63.html</url>
      
        <content type="html"><![CDATA[<p>Project1 算是进入正式的项目了，做下来感觉整体难度还是挺高的(本人在实现的过程中还没有考虑细粒锁还是花费了大量的时间，有时间还可以优化一下)，因为此博客一般就只作为我自己的笔记，再加上2022fall早已结束，所以过程中就贴上源代码。</p><p>关于本门课程，由于本人英语听力水平实在有限，所以看的是B站一个中科院老师对于该课程的解读: <a href="https://www.bilibili.com/video/BV1bQ4y1Y7iT">https://www.bilibili.com/video/BV1bQ4y1Y7iT</a></p><p>好，接下来进入<strong>正题</strong>：</p><p>project1 一共有三个任务：</p><ul><li><strong>可扩展哈希表（Extendible Hash Table）</strong></li><li><strong>LRU-K 置换策略（LRU-K Replacement Policy）</strong></li><li><strong>缓冲池管理（Buffer Pool Manager）</strong></li></ul><p>其中缓冲池的实现会用到前两个</p><h2 id="可扩展哈希表（Extendible-Hash-Table）">可扩展哈希表（Extendible Hash Table）</h2><p>首先是我们为什么要引入可扩展哈希表？传统的静态哈希表在储存空间不足时进行扩展会非常麻烦，同时发生碰撞后的处理往往也会导致查找时间的增长。对于动态哈希表例如拉链法实现的哈希表，当某个哈希值对应的元素特别多时，查找的时间复杂度由O(1)退化为遍历的O(n)。<br>举个极端的例子，如果哈希函数是不管输入是什么都映射为 0，那么就和在第 0 位存储一个链表无异。如何设计散布更加均匀的哈希函数是优化的另一个方向，一种方法是当检测到某个桶中的元素过多时对表进行扩展。扩展最简单的做法是直接将哈希表的长度（桶数）翻倍，再将哈希函数的值域由 [0,n) 改为 [0,2n)，然后对所有存储的元素重新算一次哈希值分布到不同的桶中。</p><p>这种方法的缺点很明显：如果哈希表中已经存储了大量的元素，因为要对所有元素重算哈希值，扩展的过程会有巨大的计算量，导致一次突发的大延迟。实际上，进行扩展时，可能仅仅是某一个桶出现了拉链很长的状况，其它桶的余量还很充足。于是，出现了可扩展哈希表（Extendible Hash Table）的方案，其将哈希得到的下标与桶改为非一对一映射，并引入全局深度（Global Depth）和局部深度（Local Depth）的概念，实现扩展时只需对达到容量的那一个桶进行分裂，解决了以上问题。</p><p>可扩展哈希表的具体原理就不在此赘述了，可以参考下之前B站链接老师的讲解或者下面这篇博客：<a href="https://blog.csdn.net/MelroseLbt/article/details/129329316">https://blog.csdn.net/MelroseLbt/article/details/129329316</a> (这篇博客里有一定的地方没讲清楚，有迷糊可以看一下15445的作业，做一下就懂了)</p><h3 id="Bucket类">Bucket类</h3><p>首先我们要实现ExtendibleHashTable 类的内联类 Bucket 类的结构，Bucket就是可扩展哈希表中的桶，Bucket 使用 std::list 存储元素键值对，我们主要实现三个函数 Find，Remove 和 Insert：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Bucket &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit Bucket(size_t size, int depth = 0);</span><br><span class="line"></span><br><span class="line">  /** @brief Check if a bucket is full. */</span><br><span class="line">  inline auto IsFull() const -&gt; bool &#123; return list_.size() == size_; &#125;</span><br><span class="line"></span><br><span class="line">  /** @brief Get the local depth of the bucket. */</span><br><span class="line">  inline auto GetDepth() const -&gt; int &#123; return depth_; &#125;</span><br><span class="line"></span><br><span class="line">  /** @brief Increment the local depth of a bucket. */</span><br><span class="line">  inline void IncrementDepth() &#123; depth_++; &#125;</span><br><span class="line"></span><br><span class="line">  inline auto GetItems() -&gt; std::list&lt;std::pair&lt;K, V&gt;&gt; &amp; &#123; return list_; &#125;</span><br><span class="line"></span><br><span class="line">  /* @brief Find the value associated with the given key in the bucket.</span><br><span class="line">   */</span><br><span class="line">  auto Find(const K &amp;key, V &amp;value) -&gt; bool;</span><br><span class="line"></span><br><span class="line">  /* @brief Given the key, remove the corresponding key-value pair in the bucket.</span><br><span class="line">   */</span><br><span class="line">  auto Remove(const K &amp;key) -&gt; bool;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * @brief Insert the given key-value pair into the bucket.</span><br><span class="line">   *      1. If a key already exists, the value should be updated.</span><br><span class="line">   *      2. If the bucket is full, do nothing and return false.</span><br><span class="line">   */</span><br><span class="line">  auto Insert(const K &amp;key, const V &amp;value) -&gt; bool;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  size_t size_;</span><br><span class="line">  int depth_;  // local_depth</span><br><span class="line">  std::list&lt;std::pair&lt;K, V&gt;&gt; list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有什么难点，照着注释敲就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Find(const K &amp;key, V &amp;value) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      value = it-&gt;second;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Remove(const K &amp;key) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      list_.erase(it);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Bucket::Insert(const K &amp;key, const V &amp;value) -&gt; bool &#123;</span><br><span class="line">  for (auto it = list_.begin(); it != list_.end(); ++it) &#123;</span><br><span class="line">    if (it-&gt;first == key) &#123;</span><br><span class="line">      it-&gt;second = value;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!IsFull()) &#123;</span><br><span class="line">    list_.emplace_back(key, value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExtendibleHashTable类">ExtendibleHashTable类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int global_depth_;    // The global depth of the directory</span><br><span class="line">size_t bucket_size_;  // The size of a bucket</span><br><span class="line">int num_buckets_;     // The number of buckets in the hash table</span><br><span class="line">mutable std::mutex latch_;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  // The directory of the hash table</span><br></pre></td></tr></table></figure><p>以上是ExtendibleHashTable类的成员变量，注意dir_是桶的指针数组，因为可扩展哈希表中会有多个指针指向同一个桶，所以用 shared_ptr</p><p>获取键对应的哈希值下标函数，源代码已经给出了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::IndexOf(const K &amp;key) -&gt; size_t &#123;</span><br><span class="line">  int mask = (1 &lt;&lt; global_depth_) - 1;  </span><br><span class="line">  // eg: gd = 2 , 1 &lt;&lt; 2 = 100 , 100 -1 = 011 , this is we want</span><br><span class="line">  return std::hash&lt;K&gt;()(key) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们自己先实现一个创建桶的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::NewBucket(int local_depth) -&gt; std::shared_ptr&lt;Bucket&gt; &#123;</span><br><span class="line">  return std::make_shared&lt;Bucket&gt;(bucket_size_, local_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该类中，我们也主要实现Find，Remove 和 Insert这三个函数</p><p>对于Find函数，利用哈希函数得到键所对应的下标值找到对应的桶然后让桶查找即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Find(const K &amp;key, V &amp;value) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line">  return dir_[index]-&gt;Find(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Remove 时不用考虑空桶的合并收缩，因此也是找到桶然后让桶 Remove 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">auto ExtendibleHashTable&lt;K, V&gt;::Remove(const K &amp;key) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line">  return dir_[index]-&gt;Remove(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是Insert函数，Insert函数的逻辑如下：</p><ul><li>首先判断表中是否已经有了该键，有则更新其值</li><li>如果没有，则要判断该键所对应的桶是否满了，如果没满直接插入即可，否则：</li><li><ul><li>先判断local_depth是否等于global_depth_，如果相等则需要将目录dir_扩容成原来的两倍，并且将后半部分扩容部分的指针依次指向前半部分所指的shared_ptr</li></ul></li><li><ul><li>创建两个新桶，将旧桶里的元素分发到这两个新桶中</li></ul></li><li><ul><li>调整dir_中的指针指向这两个新桶</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename K, typename V&gt;</span><br><span class="line">void ExtendibleHashTable&lt;K, V&gt;::Insert(const K &amp;key, const V &amp;value) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  size_t index = IndexOf(key);</span><br><span class="line"></span><br><span class="line">  // If a key already exists, the value should be updated.</span><br><span class="line">  V val;  // no use,just for calling Bucket::Find()</span><br><span class="line">  if (dir_[index]-&gt;Find(key, val)) &#123;</span><br><span class="line">    dir_[index]-&gt;Insert(key, value);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If the bucket is full</span><br><span class="line">  while (dir_[index]-&gt;IsFull()) &#123;</span><br><span class="line">    int local_depth = dir_[index]-&gt;GetDepth();</span><br><span class="line">    // local_depth == global_depth_ , double dir size</span><br><span class="line">    if (local_depth == global_depth_) &#123;</span><br><span class="line">      size_t dir_size = dir_.size();</span><br><span class="line">      dir_.reserve(2 * dir_size);</span><br><span class="line">      std::copy_n(dir_.begin(), dir_size,</span><br><span class="line">                  std::back_inserter(dir_));  // Copy the shared_ptr directly from the first half to the second half</span><br><span class="line">      ++global_depth_;  // that&#x27;s why we need to updata index = IndexOf(key) in the end of the while loop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // make two new buckets</span><br><span class="line">    auto b0 = NewBucket(local_depth + 1);</span><br><span class="line">    auto b1 = NewBucket(local_depth + 1);</span><br><span class="line">    ++num_buckets_;  // only add 1 , because the old Bucket will be replaced by the new Bucket</span><br><span class="line">    int local_mask = 1 &lt;&lt; local_depth;</span><br><span class="line">    /*Since the elements belong to the same bucket, the original index (k) must be</span><br><span class="line">    the same. Therefore, we only need to compare the &#x27;local_depth&#x27; at that position</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // redistribute items from old bucket</span><br><span class="line">    for (auto &amp;[k, v] : dir_[index]-&gt;GetItems()) &#123;</span><br><span class="line">      size_t item_hash = std::hash&lt;K&gt;()(k);  // ExtendibleHashTable::indexOf() use std::hash&lt;K&gt;()</span><br><span class="line">      if (static_cast&lt;bool&gt;(item_hash &amp; local_mask)) &#123;</span><br><span class="line">        b1-&gt;Insert(k, v);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        b0-&gt;Insert(k, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // adjust dir_ points to the old bucket</span><br><span class="line">    for (size_t i = (std::hash&lt;K&gt;()(key) &amp; (local_mask - 1)); i &lt; dir_.size(); i += local_mask) &#123;</span><br><span class="line">      if (static_cast&lt;bool&gt;(i &amp; local_mask)) &#123;</span><br><span class="line">        dir_[i] = b1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dir_[i] = b0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // updata index of the incoming item after split</span><br><span class="line">    index = IndexOf(key);</span><br><span class="line">  &#125;</span><br><span class="line">  dir_[index]-&gt;Insert(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2">测试</h3><p>之前贴的博客，博主写了几个测试样例，可以加进去测一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make extendible_hash_table_test -j2</span><br><span class="line">./test/extendible_hash_table_test</span><br></pre></td></tr></table></figure><h2 id="LRU-K-置换策略（LRU-K-Replacement-Policy）">LRU-K 置换策略（LRU-K Replacement Policy）</h2><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。可以在做该项目之前先完成力扣的146. LRU 缓存，该题中采用双向链表和哈希表来完成该机制。</p><p>但是传统的LRU算法存在一定的缺陷：缓存污染问题。例如 Cache 容量是 3，存有较常访问的 [A，B，C]，此时有一个访问序列 D，E，F 到来，就会把 ABC 全踢掉，即使 DEF 以后可能再也不会出现。</p><p>为了解决这个缺陷，LRU-K算法应运而生。LRU-K算法在LRU算法的基础上，增加了缓存项在缓存中存在的时间，即K值，在该实验中我们用缓存页的访问次数代替存在时间，即hit_count。我们使用两个队列来实现LRU-K算法，一个队列history_list_储存hit_count &lt; k 的页面，另一个队列cache_list_储存hit_count &gt;= k 的页面。在遇到需要淘汰页面时，首先利用FIFO策略淘汰history_list_队首的页面，如果history_list_队列没有可淘汰的页面，则利用LRU策略淘汰cache_list_中的页面。为了达到O(1)的时间效率，我们需要用unordered_map来存储页和他在队列中的迭代器的映射关系。同时，在淘汰页面的过程中我们要注意evictable_，是否可淘汰的问题。</p><p>综上，我们构造LRUKReplacer的类成员如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// add this struct to record the status of the frame</span><br><span class="line">  struct FrameEntry &#123;</span><br><span class="line">    size_t hit_count_&#123;0&#125;;</span><br><span class="line">    bool evictable_&#123;false&#125;;</span><br><span class="line">    std::list&lt;frame_id_t&gt;::iterator pos_;</span><br><span class="line">  &#125;;</span><br><span class="line">std::list&lt;frame_id_t&gt; history_list_;  // hit_count_ &lt; k , replace use FIFO</span><br><span class="line">  std::list&lt;frame_id_t&gt; cache_list_;    // hit_count_ &gt;= k , only when historyList is empty replace use LRU</span><br><span class="line">  std::unordered_map&lt;frame_id_t, FrameEntry&gt; entries_;</span><br><span class="line"></span><br><span class="line">  size_t curr_size_&#123;0&#125;;   // cache size</span><br><span class="line">  size_t replacer_size_;  // frame_id need to be smaller than replacer_size_</span><br><span class="line">  size_t k_;</span><br><span class="line">  std::mutex latch_;</span><br></pre></td></tr></table></figure><p>注意在这里，evictable_初始化为false，笔者则是这里初始化为true，在task3 buffer pool出现了bug，并且不易于理清逻辑。</p><p>curr_size_实际上是指可以被替换的页的数量</p><h3 id="LRUKReplacer-实现">LRUKReplacer 实现</h3><p>该类中我们主要需要实现四个成员函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// @brief Find the frame with largest backward k-distance and evict that frame. Only frames </span><br><span class="line">// that are marked as &#x27;evictable_&#x27; are candidates for eviction.</span><br><span class="line">auto Evict(frame_id_t *frame_id) -&gt; bool;</span><br><span class="line"></span><br><span class="line">// @brief Record the event that the given frame id is accessed at current timestamp.</span><br><span class="line">// Create a new entry for access history if frame id has not been seen before.</span><br><span class="line">void RecordAccess(frame_id_t frame_id);</span><br><span class="line"></span><br><span class="line">// @brief Toggle whether a frame is evictable_ or non-evictable_. This function also</span><br><span class="line">// controls replacer&#x27;s size. Note that size is equal to number of evictable_ entries.</span><br><span class="line">void SetEvictable(frame_id_t frame_id, bool set_evictable_);</span><br><span class="line"></span><br><span class="line">// @brief Remove an evictable_ frame from replacer, along with its access history.</span><br><span class="line">// This function should also decrement replacer&#x27;s size if removal is successful.</span><br><span class="line">void Remove(frame_id_t frame_id);</span><br></pre></td></tr></table></figure><p><strong>Evict()</strong><br>比较简单</p><ul><li>首先判断curr_size_是否为0，如果为0，则直接返回false，否则：</li><li><ul><li>从队尾开始遍历history_list_，没找到就从队尾开始遍历cache_list_<br>两个队列中第一个可驱逐的就是满足条件的，之所以能这样做是因为在RecordAccess()中保证了这一点。<br>然后就是注意反向迭代器的删除：history_list_.erase(std::next(rit).base());</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">auto LRUKReplacer::Evict(frame_id_t *frame_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (curr_size_ == 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!history_list_.empty()) &#123;</span><br><span class="line">    for (auto rit = history_list_.rbegin(); rit != history_list_.rend(); ++rit) &#123;  // fisrt in first out</span><br><span class="line">      if (entries_[*rit].evictable_) &#123;</span><br><span class="line">        *frame_id = *rit;</span><br><span class="line">        history_list_.erase(std::next(rit).base());  // erase的入参只接受正向迭代器</span><br><span class="line">        entries_.erase(*frame_id);</span><br><span class="line">        --curr_size_;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!cache_list_.empty()) &#123;</span><br><span class="line">    for (auto rit = cache_list_.rbegin(); rit != cache_list_.rend();</span><br><span class="line">         ++rit) &#123;  // in RecordAccess() ,we have insure the first frame is the latest one</span><br><span class="line">      if (entries_[*rit].evictable_) &#123;</span><br><span class="line">        *frame_id = *rit;</span><br><span class="line">        cache_list_.erase(std::next(rit).base());</span><br><span class="line">        entries_.erase(*frame_id);</span><br><span class="line">        --curr_size_;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RecordAccess()</strong></p><ul><li>首先判断frame_id是否越界，如果越界，则抛出异常</li><li>然后更改++hit_count_，由于unordered_map的性质，如果entries_中没有该页，他会自动初始化一个</li><li>然后判断hit_count_的值，判断是否需要移入到cache_list_中，如果已经在cache_list_中也需要将其移动到队首以保证LRU策略</li></ul><p>注意到就算有新页进来curr_size_也不能加一，因为新页默认是不可驱逐的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::RecordAccess(frame_id_t frame_id) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  // for new frames , default hit count is 0</span><br><span class="line"></span><br><span class="line">  size_t count = ++entries_[frame_id].hit_count_;  // 新页在此添加进entries</span><br><span class="line">  if (count == 1) &#123;                                // new frame</span><br><span class="line">    // LOG_INFO(&quot;%d NEW FRAME&quot;,frame_id);</span><br><span class="line">    // ++curr_size_; // bug1,不应该++，因为默认的evictable_是false</span><br><span class="line">    history_list_.emplace_front(frame_id);</span><br><span class="line">    entries_[frame_id].pos_ = history_list_.begin();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (count == k_) &#123;  // reach k-hit , move from history_list_ to the front of cache_list_</span><br><span class="line">      // LOG_INFO(&quot;No.%d FRAME MOVE FROM HIST TO CACHE&quot; , frame_id);</span><br><span class="line">      history_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">      cache_list_.emplace_front(frame_id);</span><br><span class="line">      entries_[frame_id].pos_ = cache_list_.begin();</span><br><span class="line">    &#125; else if (count &gt; k_) &#123;  // move to the front of cache_list_ , insure the LRU</span><br><span class="line">      cache_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">      cache_list_.emplace_front(frame_id);</span><br><span class="line">      entries_[frame_id].pos_ = cache_list_.begin();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // count &lt; k , keep in history_list_ , do not move because the FIFO</span><br><span class="line">  // LOG_INFO(&quot;RECORD: %d&quot; , frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SetEvictable()</strong><br>该函数用于调整evictable_属性，比较简单，唯一要注意的就是对于curr_size_值的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::SetEvictable(frame_id_t frame_id, bool set_evictable_) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_.find(frame_id) == entries_.end()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (set_evictable_ &amp;&amp; !entries_[frame_id].evictable_) &#123;</span><br><span class="line">    curr_size_++;</span><br><span class="line">  &#125; else if (!set_evictable_ &amp;&amp; entries_[frame_id].evictable_) &#123;</span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  entries_[frame_id].evictable_ = set_evictable_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Remove()</strong><br>逻辑比较简单，看代码即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void LRUKReplacer::Remove(frame_id_t frame_id) &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  if (frame_id &gt; static_cast&lt;frame_id_t&gt;(replacer_size_)) &#123;</span><br><span class="line">    throw std::invalid_argument(std::string(&quot;Invalid frame_id: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_.find(frame_id) == entries_.end()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!entries_[frame_id].evictable_) &#123;</span><br><span class="line">    throw std::logic_error(std::string(&quot;Can&#x27;t remove an inevictable_ frame: &quot; + std::to_string(frame_id)));</span><br><span class="line">  &#125;</span><br><span class="line">  if (entries_[frame_id].hit_count_ &lt; k_) &#123;</span><br><span class="line">    history_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    cache_list_.erase(entries_[frame_id].pos_);</span><br><span class="line">  &#125;</span><br><span class="line">  --curr_size_;</span><br><span class="line">  entries_.erase(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲池管理（Buffer-Pool-Manager）">缓冲池管理（Buffer Pool Manager）</h2><p>Buffer Pool Manager 简单来说就是充当数据库上层设施和磁盘文件间的缓冲区，类似于 Cache 在 CPU 和内存间的作用。bustub 中有 Page 和 Frame 的概念，Page 是承载 4K 大小数据的类，可以通过 DiskManager 从磁盘文件中读写，带有 page_id 编号，is_dirty 标识等信息。Frame 不是一个具体的类，而可以理解为 Buffer Pool Manager（以下简称 BPM）中容纳 Page 的槽位，具体来说，BPM 中有一个 Page 数组，frame_id 就是某个 Page 在该数组中的下标。</p><p>外界只知道 page_id，向 BPM 查询时，BPM 要确定该 Page 是否存在以及其位置，所以要维护一个 page_id 到 frame_id 的映射，这里就使用我们刚完成的 ExtendibleHashTable。为区分空闲和占用的 Page，维护一个 free_list_，保存空闲的 frame_id。初始状态，所有 Page 都是空闲的。当上层需要取一个 Page 时，如果 Page 已存在于 BP 中，则直接返回；否则需要从磁盘读取到 BP 中。此时优先取空闲的 Page，否则只能从所有已经占用的 Page 中用我们刚完成的 LRUKReplacer 决定踢出某个 Page。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief Creates a new BufferPoolManagerInstance.</span><br><span class="line"> * @param pool_size the size of the buffer pool</span><br><span class="line"> * @param disk_manager the disk manager</span><br><span class="line"> * @param replacer_k the lookback constant k for the LRU-K replacer</span><br><span class="line"> * @param log_manager the log manager (for testing only: nullptr = disable logging). Please ignore this for P1.</span><br><span class="line"> */</span><br><span class="line">BufferPoolManagerInstance(size_t pool_size, DiskManager *disk_manager, size_t replacer_k = LRUK_REPLACER_K,</span><br><span class="line">                          LogManager *log_manager = nullptr);</span><br><span class="line"></span><br><span class="line">/** Number of pages in the buffer pool. */</span><br><span class="line">const size_t pool_size_;</span><br><span class="line">/** The next page id to be allocated  */</span><br><span class="line">std::atomic&lt;page_id_t&gt; next_page_id_ = 0;</span><br><span class="line">/** Bucket size for the extendible hash table */</span><br><span class="line">const size_t bucket_size_ = 4;</span><br><span class="line"></span><br><span class="line">/** Array of buffer pool pages. */</span><br><span class="line">Page *pages_;  // frame_id在这个数组中起到index的作用,可以就理解为内存中的页框(Page Frame,或页帧)</span><br><span class="line">/** Pointer to the disk manager. */</span><br><span class="line">DiskManager *disk_manager_ __attribute__((__unused__));</span><br><span class="line">/** Pointer to the log manager. Please ignore this for P1. */</span><br><span class="line">LogManager *log_manager_ __attribute__((__unused__));</span><br><span class="line">/** Page table for keeping track of buffer pool pages. */</span><br><span class="line">ExtendibleHashTable&lt;page_id_t, frame_id_t&gt; *page_table_;</span><br><span class="line">/** Replacer to find unpinned pages for replacement. */</span><br><span class="line">LRUKReplacer *replacer_;</span><br><span class="line">/** List of free frames that don&#x27;t have any pages on them. */</span><br><span class="line">std::list&lt;frame_id_t&gt; free_list_;</span><br><span class="line">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><h3 id="3-BufferPoolManagerInstance-类实现">3. BufferPoolManagerInstance 类实现</h3><p>在该类中主要要实现以下几个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// @brief Create a new page in the buffer pool. Set page_id to the new page&#x27;s id, or nullptr if all frames</span><br><span class="line">// are currently in use and not evictable (in another word, pinned).</span><br><span class="line">auto NewPgImp(page_id_t *page_id) -&gt; Page * override;</span><br><span class="line"></span><br><span class="line">// @brief Fetch the requested page from the buffer pool. Return nullptr if page_id needs to be fetched from the disk</span><br><span class="line">// but all frames are currently in use and not evictable (in another word, pinned).</span><br><span class="line">auto FetchPgImp(page_id_t page_id) -&gt; Page * override;</span><br><span class="line"></span><br><span class="line">// @brief Unpin the target page from the buffer pool. If page_id is not in the buffer pool or its pin count is already 0, return false.</span><br><span class="line">auto UnpinPgImp(page_id_t page_id, bool is_dirty) -&gt; bool override;</span><br><span class="line"></span><br><span class="line">// @brief Flush the target page to disk.</span><br><span class="line">// Use the DiskManager::WritePage() method to flush a page to disk, REGARDLESS of the dirty flag.</span><br><span class="line">// Unset the dirty flag of the page after flushing.</span><br><span class="line">auto FlushPgImp(page_id_t page_id) -&gt; bool override;</span><br><span class="line"></span><br><span class="line">// @brief Flush all the pages in the buffer pool to disk</span><br><span class="line">void FlushAllPgsImp() override;</span><br><span class="line"></span><br><span class="line">// @brief Delete a page from the buffer pool. If page_id is not in the buffer pool, do nothing and return true. If the</span><br><span class="line">// page is pinned and cannot be deleted, return false immediately.</span><br><span class="line">auto DeletePgImp(page_id_t page_id) -&gt; bool override;</span><br></pre></td></tr></table></figure><p><strong>NewPgImp()</strong><br>逻辑很简单，获取一个空闲页或者利用LRU-K淘汰一个页，然后利用这个页号来新建。<br>注意在初始化的过程中replacer_-&gt;RecordAccess(frame_id);必须在replacer_-&gt;SetEvictable(frame_id, false);之前，因为在SetEvictable中的if(entries.find(frame_id) == entries.end())判断时，此时还没有entries条目，所以会直接返回故会出bug。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::NewPgImp(page_id_t *page_id) -&gt; Page * &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!GetAvailableFrame(&amp;frame_id)) &#123;</span><br><span class="line">    // LOG_INFO(&quot;false: %d#&quot;,frame_id);</span><br><span class="line">    page_id = nullptr;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  // LOG_INFO(&quot;true: %d#&quot;,frame_id);</span><br><span class="line">  page_id_t new_page_id = AllocatePage();</span><br><span class="line">  // reset page 重置内存、元数据；更新 buffer pool</span><br><span class="line">  pages_[frame_id].page_id_ = new_page_id;</span><br><span class="line">  pages_[frame_id].ResetMemory();</span><br><span class="line">  pages_[frame_id].pin_count_ = 0;</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line"></span><br><span class="line">  page_table_-&gt;Insert(new_page_id, frame_id);</span><br><span class="line">  // &quot;Pin&quot; the frame by calling replacer.SetEvictable(frame_id, false)</span><br><span class="line">  /* RecordAccess必须在SetEvictable之前</span><br><span class="line">    因为在SetEvictable中的if(entries.find(frame_id) == entries.end())</span><br><span class="line">  ，此时还没有entries条目，所以会直接返回故会报错 */</span><br><span class="line">  replacer_-&gt;RecordAccess(frame_id);</span><br><span class="line">  replacer_-&gt;SetEvictable(frame_id, false);</span><br><span class="line">  pages_[frame_id].pin_count_++;</span><br><span class="line">  // record the access history</span><br><span class="line"></span><br><span class="line">  *page_id = new_page_id;</span><br><span class="line">  return &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中的GetAvailableFrame(&amp;frame_id)是我添加的一个函数，用于在free_list_中获取空闲页框或者利用LRU-K淘汰一个页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// add a function to GetAvailableFrame</span><br><span class="line">auto BufferPoolManagerInstance::GetAvailableFrame(frame_id_t *avilFrameId) -&gt; bool &#123;</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!free_list_.empty()) &#123;</span><br><span class="line">    // LOG_INFO(&quot;free_list_: %d#&quot;,frame_id);</span><br><span class="line">    frame_id = free_list_.front();</span><br><span class="line">    free_list_.pop_front();</span><br><span class="line">    *avilFrameId = frame_id;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // no free frame , find a replacement</span><br><span class="line">  if (replacer_-&gt;Evict(&amp;frame_id)) &#123;</span><br><span class="line">    // LOG_INFO(&quot;replacement: %d#&quot;,frame_id);</span><br><span class="line">    if (pages_[frame_id].IsDirty()) &#123;</span><br><span class="line">      disk_manager_-&gt;WritePage(pages_[frame_id].GetPageId(), pages_[frame_id].GetData());</span><br><span class="line">      pages_[frame_id].is_dirty_ = false;</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_-&gt;Remove(pages_[frame_id].GetPageId());</span><br><span class="line">    *avilFrameId = frame_id;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FetchPgImp()</strong><br>与NewPgImp类似，如果没有这个页就从磁盘读取并在BPM中加入该页，改变LRU-k中的访问记录和evictable_</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::FetchPgImp(page_id_t page_id) -&gt; Page * &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    if (!GetAvailableFrame(&amp;frame_id)) &#123;</span><br><span class="line">      return nullptr;  // cache中没有 同时也没有frame可以获取</span><br><span class="line">    &#125;</span><br><span class="line">    pages_[frame_id].page_id_ = page_id;</span><br><span class="line">    pages_[frame_id].ResetMemory();</span><br><span class="line">    pages_[frame_id].pin_count_ = 0;</span><br><span class="line">    pages_[frame_id].is_dirty_ = false;</span><br><span class="line">    disk_manager_-&gt;ReadPage(page_id, pages_[frame_id].data_);</span><br><span class="line">    page_table_-&gt;Insert(page_id, frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">  replacer_-&gt;RecordAccess(frame_id);</span><br><span class="line">  replacer_-&gt;SetEvictable(frame_id, false);</span><br><span class="line">  pages_[frame_id].pin_count_++;</span><br><span class="line">  return &amp;pages_[frame_id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UnpinPgImp()</strong><br>看代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::UnpinPgImp(page_id_t page_id, bool is_dirty) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  // If page_id is not in the buffer pool or its pin count is already 0, return false</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pages_[frame_id].pin_count_ &lt;= 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (--pages_[frame_id].pin_count_ == 0) &#123;</span><br><span class="line">    replacer_-&gt;SetEvictable(frame_id, true);</span><br><span class="line">  &#125;</span><br><span class="line">  if (is_dirty) &#123;</span><br><span class="line">    pages_[frame_id].is_dirty_ = is_dirty;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的逻辑也很简单，看代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">auto BufferPoolManagerInstance::FlushPgImp(page_id_t page_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  disk_manager_-&gt;WritePage(page_id, pages_[frame_id].data_);</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BufferPoolManagerInstance::FlushAllPgsImp() &#123;</span><br><span class="line">  for (size_t i = 0; i &lt; pool_size_; ++i) &#123;</span><br><span class="line">    if (pages_[i].GetPageId() == INVALID_PAGE_ID) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    FlushPgImp(pages_[i].GetPageId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto BufferPoolManagerInstance::DeletePgImp(page_id_t page_id) -&gt; bool &#123;</span><br><span class="line">  std::scoped_lock&lt;std::mutex&gt; lock(latch_);</span><br><span class="line">  frame_id_t frame_id;</span><br><span class="line">  if (!page_table_-&gt;Find(page_id, frame_id)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (pages_[frame_id].GetPinCount() &gt; 0) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  // 在页表中删除</span><br><span class="line">  page_table_-&gt;Remove(page_id);</span><br><span class="line">  // 在replace_移除对frame_id的跟踪</span><br><span class="line">  replacer_-&gt;Remove(frame_id);</span><br><span class="line">  // 在free_list_中插入</span><br><span class="line">  free_list_.emplace_back(frame_id);</span><br><span class="line">  // 重置BPM中的页框</span><br><span class="line">  pages_[frame_id].page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  pages_[frame_id].ResetMemory();</span><br><span class="line">  pages_[frame_id].pin_count_ = 0;</span><br><span class="line">  pages_[frame_id].is_dirty_ = false;</span><br><span class="line"></span><br><span class="line">  DeallocatePage(page_id);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU15-445 bustub Project0：Trie 树实现</title>
      <link href="/post/470938e7.html"/>
      <url>/post/470938e7.html</url>
      
        <content type="html"><![CDATA[<p>实验环境是在阿里云的云服务器上配置的，推荐使用该方式，方便快捷，就不在此赘述了</p><p>Project0主要是考察Modern C++编程基础，难度不大，2022fall的目标是实现一个字典树(Trie);</p><h2 id="字典树-Trie">字典树(Trie)</h2><p>字典树(Trie)是一种树形数据结构，用于高效地存储和检索字符串数据集中的键(高效地进行前缀匹配)。Trie 的本质是一个多叉树，每个节点有多个孩子，每个孩子对应一个字符，每个节点有一个布尔值表示当前节点是否是一个单词的结尾。<br>例如插入两个键值对 (“ab”, 1) 和 (“ac”, “val”)，则形成下图的结构：<br><img src="/img/Trie.png" alt="Trie"><br>root 是根节点，不存储键；a 是一个非终结节点，只存储键；下层的两个节点是终结节点，除了键还要存储一个任意类型的值。每个节点有一个 map 存储以每个子节点的键索引的子节点。</p><p>在该项目中，主要有三个类：</p><ul><li>TrieNode: 表示非终结节点，成员为键，是否是终结节点的标记，子节点 map</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TrieNode:</span><br><span class="line">  /** Key character of this trie node */</span><br><span class="line">  char key_char_;</span><br><span class="line">  /** whether this node marks the end of a key */</span><br><span class="line">  bool is_end_&#123;false&#125;;</span><br><span class="line">  /** A map of all child nodes of this trie node, which can be accessed by each</span><br><span class="line">   * child node&#x27;s key char. */</span><br><span class="line">  std::unordered_map&lt;char, std::unique_ptr&lt;TrieNode&gt;&gt; children_;</span><br></pre></td></tr></table></figure><ul><li>TrieNodeWithValue: 表示终结节点，继承自TrieNode，表示终结节点，带有一个 T 类型的 value</li><li>Trie: 表示整个 Trie 树</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Trie:</span><br><span class="line">  /* Root node of the trie */</span><br><span class="line">  std::unique_ptr&lt;TrieNode&gt; root_;</span><br><span class="line">  /* Read-write lock for the trie */</span><br><span class="line">  ReaderWriterLatch latch_;</span><br></pre></td></tr></table></figure><h2 id="TrieNode-实现">TrieNode 实现</h2><h3 id="TrieNode-构造函数">TrieNode 构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * TODO(P0): Add implementation</span><br><span class="line">   *</span><br><span class="line">   * @brief Construct a new Trie Node object with the given key char.</span><br><span class="line">   * is_end_ flag should be initialized to false in this constructor.</span><br><span class="line">   *</span><br><span class="line">   * @param key_char Key character of this trie node</span><br><span class="line">   */</span><br><span class="line">  explicit TrieNode(char key_char) &#123;</span><br><span class="line">    this-&gt;key_char_ = key_char;</span><br><span class="line">    this-&gt;is_end_ = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * TODO(P0): Add implementation</span><br><span class="line">   *</span><br><span class="line">   * @brief Move constructor for trie node object. The unique pointers stored</span><br><span class="line">   * in children_ should be moved from other_trie_node to new trie node.</span><br><span class="line">   *</span><br><span class="line">   * @param other_trie_node Old trie node.</span><br><span class="line">   */</span><br><span class="line">  TrieNode(TrieNode &amp;&amp;other_trie_node) noexcept &#123;</span><br><span class="line">    this-&gt;key_char_ = other_trie_node.key_char_;</span><br><span class="line">    this-&gt;is_end_ = other_trie_node.is_end_;</span><br><span class="line">    this-&gt;children_ = std::move(other_trie_node.children_);  // this?</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是移动构造函数（move constructor），由于 <code>unique_ptr</code> 表示独占性资源，没有拷贝构造函数，所以这里我们要用 <code>std::move</code>。</p><h3 id="TrieNode-成员函数">TrieNode 成员函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *InsertChildNode(char key_char, std::unique_ptr&lt;TrieNode&gt; &amp;&amp;child) &#123;</span><br><span class="line">  if (children_.find(key_char) != children_.end()) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  if (child-&gt;key_char_ != key_char) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  children_[key_char] = std::move(child);</span><br><span class="line">  return &amp;children_[key_char];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;TrieNode&gt; *GetChildNode(char key_char) &#123;</span><br><span class="line">  if (children_.find(key_char) != children_.end()) &#123;</span><br><span class="line">    return &amp;children_[key_char];</span><br><span class="line">  &#125;</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大多数成员函数的实现都很简单，只是注意在InsertChildNode()与GetChildNode()中，因为 unique_ptr 是独占性指针不能拷贝，返回值是 unique_ptr 的指针。</p><h2 id="TrieNodeWithValue-实现">TrieNodeWithValue 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Construct a new TrieNodeWithValue</span><br><span class="line">TrieNodeWithValue(char key_char, T value) : TrieNode(key_char), value_(value) &#123; is_end_ = true; &#125;</span><br><span class="line">// Construct a new TrieNodeWithValue object from a TrieNode object and specify its value.</span><br><span class="line">TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value) : TrieNode(std::move(trieNode)), value_(value) &#123; is_end_ = true; &#125;</span><br></pre></td></tr></table></figure><p>该类的is_end_始终为true</p><h2 id="Trie-实现">Trie 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trie() &#123; root_ = std::make_unique&lt;TrieNode&gt;(&#x27;\0&#x27;); &#125;</span><br></pre></td></tr></table></figure><p>构造函数，根节点不携带键</p><p><strong>Insert()</strong><br>沿 Trie 树搜索到键的最后一个字符，过程中如果节点不存在就创建。对于最后一个键的字符分三种情况：</p><ul><li>如果相应节点不存在，创建一个终结节点 TrieNodeWithValue，插入成功；</li><li>如果相应节点存在但不是终结节点（通过 is_end_ 判断），将其转化为 TrieNodeWithValue 并把值赋给该节点，该操作不破坏以该键为前缀的后续其它节点（children_ 不变），插入成功；</li><li>如果相应节点存在且是终结节点，说明该键在 Trie 树存在，规定不能覆盖已存在的值，返回插入失败。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">  bool Insert(const std::string &amp;key, T value) &#123;</span><br><span class="line">    latch_.WLock();</span><br><span class="line">    if (key.empty()) &#123;</span><br><span class="line">      latch_.WUnlock();</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    auto current = &amp;root_;</span><br><span class="line">    size_t i = 0;</span><br><span class="line">    // 找，找不到就新建，只到key的倒数第二个字符</span><br><span class="line">    while (i + 1 &lt; key.size()) &#123;</span><br><span class="line">      if ((*current)-&gt;GetChildNode(key[i]) == nullptr) &#123;</span><br><span class="line">        std::unique_ptr&lt;TrieNode&gt; tmp = std::make_unique&lt;TrieNode&gt;(key[i]);</span><br><span class="line">        (*current)-&gt;InsertChildNode(key[i], std::move(tmp));</span><br><span class="line">      &#125;</span><br><span class="line">      current = (*current)-&gt;GetChildNode(key[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第一种情况，末尾结点不存在</span><br><span class="line">    if ((*current)-&gt;GetChildNode(key[i]) == nullptr) &#123;</span><br><span class="line">      std::unique_ptr&lt;TrieNodeWithValue&lt;T&gt;&gt; tmp = std::make_unique&lt;TrieNodeWithValue&lt;T&gt;&gt;(key[i], value);</span><br><span class="line">      (*current)-&gt;InsertChildNode(key[i], std::move(tmp));</span><br><span class="line">      latch_.WUnlock();</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第二种情况，将普通结点转化为带value的结点</span><br><span class="line">    current = (*current)-&gt;GetChildNode(key[i]);</span><br><span class="line">    if (!(*current)-&gt;IsEndNode()) &#123;</span><br><span class="line">      auto *tmp = new TrieNodeWithValue&lt;T&gt;(std::move(*(*current)), value);</span><br><span class="line">      current-&gt;reset(tmp);</span><br><span class="line">      latch_.WUnlock();</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第三种情况</span><br><span class="line">    latch_.WUnlock();</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Remove()</strong></p><ul><li>递归地沿 Trie 树逐字符向下搜索给定键，如果中途发现不存在直接返回 false。</li><li>如果找到了，则将该节点的 is_end_ 标为 false（此时虽然其值仍存在，但会被我们视为非终结节点）。如果该节点没有子节点，则可以删除。</li><li>递归回溯，如果其 parent 节点在移除该子节点后没有其它子节点并且不是终结节点，也删除。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bool Remove(const std::string &amp;key) &#123;</span><br><span class="line">  latch_.WLock();</span><br><span class="line">  if (key.empty()) &#123;</span><br><span class="line">    latch_.WUnlock();</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  auto cur = &amp;root_;</span><br><span class="line">  bool success = false;</span><br><span class="line">  RemoveInner(key, 0, cur, &amp;success);</span><br><span class="line">  latch_.WUnlock();</span><br><span class="line">  return success;</span><br><span class="line">&#125;</span><br><span class="line">bool RemoveInner(const std::string &amp;key, size_t i, std::unique_ptr&lt;TrieNode&gt; *cur, bool *success) &#123;</span><br><span class="line">  if (i == key.size()) &#123;</span><br><span class="line">    *success = true;</span><br><span class="line">    (*cur)-&gt;SetEndNode(false);</span><br><span class="line">    return !(*cur)-&gt;HasChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  if ((*cur)-&gt;GetChildNode(key[i]) == nullptr) &#123;</span><br><span class="line">    *success = false;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  bool can_remove = RemoveInner(key, i + 1, (*cur)-&gt;GetChildNode(key[i]), success);</span><br><span class="line">  if (!*success) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (can_remove) &#123;</span><br><span class="line">    (*cur)-&gt;RemoveChildNode(key[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return !(*cur)-&gt;HasChildren() &amp;&amp; !(*cur)-&gt;IsEndNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GetValue</strong></p><p>沿 Trie 树查找，如果键不存在，或者节点中存储的值类型与函数调用的类型 T 不一致，将 *success 标识设为 false。<br>类型判断的方式是使用 dynamic_cast。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">  T GetValue(const std::string &amp;key, bool *success) &#123;</span><br><span class="line">    // *success = false;</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">    latch_.RLock();</span><br><span class="line">    if (key.empty()) &#123;</span><br><span class="line">      *success = false;</span><br><span class="line">      latch_.RUnlock();</span><br><span class="line">      return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    auto cur = &amp;root_;</span><br><span class="line">    for (auto &amp;c : key) &#123;</span><br><span class="line">      if (!(*cur)-&gt;HasChild(c)) &#123;</span><br><span class="line">        *success = false;</span><br><span class="line">        latch_.RUnlock();</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = (*cur)-&gt;GetChildNode(c);</span><br><span class="line">    &#125;</span><br><span class="line">    auto ret_value = dynamic_cast&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur-&gt;get());</span><br><span class="line">    if (ret_value == nullptr) &#123;</span><br><span class="line">      *success = false;</span><br><span class="line">      latch_.RUnlock();</span><br><span class="line">      return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    *success = true;</span><br><span class="line">    latch_.RUnlock();</span><br><span class="line">    return ret_value-&gt;GetValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">make starter_trie_test</span><br><span class="line">./test/starter_trie_test</span><br></pre></td></tr></table></figure><h2 id="代码格式化">代码格式化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMU15-445 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU15-445 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARMLinux的启动代码分析</title>
      <link href="/post/2fca3eb1.html"/>
      <url>/post/2fca3eb1.html</url>
      
        <content type="html"><![CDATA[<h2 id="ARMLinux的启动代码分析">ARMLinux的启动代码分析</h2><hr><p>本次所分析的<code>linux</code>版本为<code>linux-4.9.291</code></p><p>为了分析ARM Linux的启动代码，可以先从Linux的链接脚本入手，找到程序的入口。在<code>arch/arm/kernel/vmlinux.lds</code>中，我们可以找到以下代码：</p><p><img src="/img/4.1.png" alt=""></p><p><code>ENTRY(stext)</code>指明了Linux内核入口为<code>stext</code>,而<code>stext</code>在<code>arch/arm/kernel/head.S</code>中定义，因此我们首先分析<strong>arch/arm/kernel/head.S</strong>这个文件。</p><h3 id="一、内核引导阶段">一、内核引导阶段</h3><p>该阶段的主要代码位于<code>arch/arm/kernel/head.S</code> 和 <code>arch/arm/kernel/head-common.S</code>中。主要完成以下工作:</p><p><img src="/img/4.2.png" alt=""></p><p>在<code>arch/arm/kernel/head.S</code>中，分析<code>ENTRY(stext)</code>的代码：</p><ul><li>调用函数 <code>safe_svcmode_maskall</code> 确保 CPU 处于 <strong>SVC</strong> 模式，并且关闭了所有的中断。safe_svcmode_maskall 定义在文件 <code>arch/arm/include/asm/assembler.h</code> 中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line"> ARM_BE8(setendbe )@ ensure we are in BE8 mode</span><br><span class="line"></span><br><span class="line"> THUMB(badrr9, 1f)@ Kernel is always entered in ARM.</span><br><span class="line"> THUMB(bxr9)@ If this is a Thumb-2 kernel,</span><br><span class="line"> THUMB(.thumb)@ switch to Thumb now.</span><br><span class="line"> THUMB(1:)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM_VIRT_EXT</span><br><span class="line">bl__hyp_stub_install</span><br><span class="line">#endif</span><br><span class="line">@ ensure svc mode and all interrupts masked</span><br><span class="line">safe_svcmode_maskall r9</span><br></pre></td></tr></table></figure><ul><li>读处理器 ID，ID 值保存在 r9 寄存器中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrcp15, 0, r9, c0, c0@ get processor id</span><br></pre></td></tr></table></figure><ul><li>调用函数 <code>__lookup_processor_type</code> 检查当前系统是否支持此 CPU，如果支持就获取 procinfo 信息。 procinfo 是 proc_info_list 类 型 的 结 构 体 ，proc_info_list 在文件 <code>arch/arm/include/asm/procinfo.h</code> 中定义。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bl__lookup_processor_type@ r5=procinfo r9=cpuid</span><br><span class="line">movsr10, r5@ invalid processor (r5=0)?</span><br><span class="line"> THUMB( iteq )@ force fixup-able long branch encoding</span><br><span class="line">beq__error_p@ yes, error &#x27;p&#x27;</span><br></pre></td></tr></table></figure><ul><li>调用函数 <code>__create_page_tables</code> 创建页表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl__create_page_tables</span><br></pre></td></tr></table></figure><ul><li>将函数 <code>__mmap_switched</code> 的地址保存到 r13 寄存器中。__mmap_switched 定义在文件 <code>arch/arm/kernel/head-common.S</code>，__mmap_switched 最终会调用 <code>start_kernel</code> 函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldrr13, =__mmap_switched@ address to jump to after</span><br><span class="line">@ mmu has been enabled</span><br><span class="line">badrlr, 1f@ return (PIC) address</span><br></pre></td></tr></table></figure><ul><li>调 用 <code>__enable_mmu</code> 函数使能 MMU。__enable_mmu 最终会通过调用 <code>__turn_mmu_on</code> 来打开 MMU，__turn_mmu_on 最后会执行 r13 里面保存的 <code>__mmap_switched</code> 函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:b__enable_mmu</span><br><span class="line">ENDPROC(stext)</span><br></pre></td></tr></table></figure><p><code>__mmap_switched</code> 函数定义在文件 <code>arch/arm/kernel/head-common.S </code>中，函数代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__mmap_switched:</span><br><span class="line">adrr3, __mmap_switched_data</span><br><span class="line"></span><br><span class="line">ldmiar3!, &#123;r4, r5, r6, r7&#125;</span><br><span class="line">cmpr4, r5@ Copy data segment if needed</span><br><span class="line">1:cmpner5, r6</span><br><span class="line">ldrnefp, [r4], #4</span><br><span class="line">strnefp, [r5], #4</span><br><span class="line">bne1b</span><br><span class="line"></span><br><span class="line">movfp, #0@ Clear BSS (and zero fp)</span><br><span class="line">1:cmpr6, r7</span><br><span class="line">strccfp, [r6],#4</span><br><span class="line">bcc1b</span><br><span class="line"></span><br><span class="line"> ARM(ldmiar3, &#123;r4, r5, r6, r7, sp&#125;)</span><br><span class="line"> THUMB(ldmiar3, &#123;r4, r5, r6, r7&#125;)</span><br><span class="line"> THUMB(ldrsp, [r3, #16])</span><br><span class="line">strr9, [r4]@ Save processor ID</span><br><span class="line">strr1, [r5]@ Save machine type</span><br><span class="line">strr2, [r6]@ Save atags pointer</span><br><span class="line">cmpr7, #0</span><br><span class="line">strner0, [r7]@ Save control register values</span><br><span class="line">bstart_kernel</span><br><span class="line">ENDPROC(__mmap_switched)</span><br></pre></td></tr></table></figure><p><code>__mmap_switched</code> 函数最终调用 <code>start_kernel</code> 来启动 Linux 内核</p><h3 id="二、内核初始化阶段">二、内核初始化阶段</h3><p>该阶段的主要代码位于<code>init/main.c</code>中，主要是三个函数：<code>start_kernel</code>、<code>rest_init</code>和<code>kernel_init</code>。主要任务如下图所示：<br><img src="/img/4.3.png" alt=""></p><p><code>start_kernel</code> 通过调用众多的子函数来完成 Linux 启动之前的一些初始化工作，核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible void __init start_kernel(void)</span><br><span class="line">&#123;</span><br><span class="line">char *command_line;</span><br><span class="line">char *after_dashes;</span><br><span class="line"></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">smp_setup_processor_id();</span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up the the initial canary ASAP:</span><br><span class="line"> */</span><br><span class="line">boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">cgroup_init_early();</span><br><span class="line"></span><br><span class="line">local_irq_disable();</span><br><span class="line">early_boot_irqs_disabled = true;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Interrupts are still disabled. Do necessary setups, then</span><br><span class="line"> * enable them</span><br><span class="line"> */</span><br><span class="line">boot_cpu_init();</span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(&quot;%s&quot;, linux_banner);</span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">mm_init_cpumask(&amp;init_mm);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();/* arch-specific boot-cpu hooks */</span><br><span class="line">boot_cpu_hotplug_init();</span><br><span class="line"></span><br><span class="line">build_all_zonelists(NULL, NULL, false);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line">pr_notice(&quot;Kernel command line: %s\n&quot;, boot_command_line);</span><br><span class="line">/* parameters may set static keys */</span><br><span class="line">jump_label_init();</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(&quot;Booting kernel&quot;,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  -1, -1, NULL, &amp;unknown_bootoption);</span><br><span class="line">if (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(&quot;Setting init args&quot;, after_dashes, NULL, 0, -1, -1,</span><br><span class="line">   NULL, set_init_arg);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * These use large bootmem allocations and must precede</span><br><span class="line"> * kmem_cache_init()</span><br><span class="line"> */</span><br><span class="line">setup_log_buf(0);</span><br><span class="line">pidhash_init();</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();</span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Set up the scheduler prior starting any interrupts (such as the</span><br><span class="line"> * timer interrupt). Full topology setup happens at smp_init()</span><br><span class="line"> * time - but meanwhile we still have a functioning scheduler.</span><br><span class="line"> */</span><br><span class="line">sched_init();</span><br><span class="line">/*</span><br><span class="line"> * Disable preemption - early bootup scheduling is extremely</span><br><span class="line"> * fragile until we cpu_idle() for the first time.</span><br><span class="line"> */</span><br><span class="line">preempt_disable();</span><br><span class="line">if (WARN(!irqs_disabled(),</span><br><span class="line"> &quot;Interrupts were enabled *very* early, fixing it\n&quot;))</span><br><span class="line">local_irq_disable();</span><br><span class="line">idr_init_cache();</span><br><span class="line">rcu_init();</span><br><span class="line"></span><br><span class="line">/* trace_printk() and trace points may be used after this */</span><br><span class="line">trace_init();</span><br><span class="line"></span><br><span class="line">context_tracking_init();</span><br><span class="line">radix_tree_init();</span><br><span class="line">/* init some links before init_ISA_irqs() */</span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_clock_postinit();</span><br><span class="line">printk_nmi_init();</span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), &quot;Interrupts were enabled early\n&quot;);</span><br><span class="line">early_boot_irqs_disabled = false;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span><br><span class="line"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span><br><span class="line"> * this. But we do want output early, in case something goes wrong.</span><br><span class="line"> */</span><br><span class="line">console_init();</span><br><span class="line">if (panic_later)</span><br><span class="line">panic(&quot;Too many boot %s vars at `%s&#x27;&quot;, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_info();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Need to run this when irqs are enabled, because it wants</span><br><span class="line"> * to self-test [hard/soft]-irqs on/off lock inversion bugs</span><br><span class="line"> * too:</span><br><span class="line"> */</span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_BLK_DEV_INITRD</span><br><span class="line">if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((void *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;,</span><br><span class="line">    page_to_pfn(virt_to_page((void *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">page_ext_init();</span><br><span class="line">debug_objects_mem_init();</span><br><span class="line">kmemleak_init();</span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line">if (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line">pidmap_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line">#ifdef CONFIG_X86</span><br><span class="line">if (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_X86_ESPFIX64</span><br><span class="line">/* Should be run before the first non-init thread is created */</span><br><span class="line">init_espfix_bsp();</span><br><span class="line">#endif</span><br><span class="line">thread_stack_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init();</span><br><span class="line">proc_caches_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init();</span><br><span class="line">signals_init();</span><br><span class="line">/* rootfs populating might need page-writeback */</span><br><span class="line">page_writeback_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">nsfs_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">check_bugs();</span><br><span class="line"></span><br><span class="line">acpi_subsystem_init();</span><br><span class="line">sfi_init_late();</span><br><span class="line"></span><br><span class="line">if (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">efi_late_init();</span><br><span class="line">efi_free_boot_services();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ftrace_init();</span><br><span class="line"></span><br><span class="line">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span><br><span class="line">rest_init();</span><br><span class="line"></span><br><span class="line">prevent_tail_call_optimization();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rest_init函数代码如下：</p><ul><li>调用函数 <code>rcu_scheduler_starting</code>，启动 RCU 锁调度器</li><li>调用函数 <code>kernel_thread</code> 创建 <code>kernel_init</code> 进程，也就是 init 内核进程。init 进程的 PID 为 1。</li><li>调用函数 kernel_thread 创建 <code>kthreadd</code> 内核进程，此内核进程的 PID 为 2。<code>kthreadd</code>进程负责所有内核进程的调度和管理。</li><li>最后调用函数 <code>cpu_startup_entry</code> 来进入 <code>idle</code> 进程，cpu_startup_entry 会调用 cpu_idle_loop，cpu_idle_loop 是个 while 循环，也就是 idle 进程代码。idle 进程的 PID 为 0，idle 进程叫做空闲进程。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static noinline void __ref rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">int pid;</span><br><span class="line"></span><br><span class="line">rcu_scheduler_starting();</span><br><span class="line">/*</span><br><span class="line"> * We need to spawn init first so that it obtains pid 1, however</span><br><span class="line"> * the init task will end up wanting to create kthreads, which, if</span><br><span class="line"> * we schedule it before we create kthreadd, will OOPS.</span><br><span class="line"> */</span><br><span class="line">kernel_thread(kernel_init, NULL, CLONE_FS);</span><br><span class="line">numa_default_policy();</span><br><span class="line">pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br><span class="line">rcu_read_lock();</span><br><span class="line">kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The boot idle thread must execute schedule()</span><br><span class="line"> * at least once to get things moving:</span><br><span class="line"> */</span><br><span class="line">init_idle_bootup_task(current);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line">/* Call into cpu_idle with preempt disabled */</span><br><span class="line">cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel_init函数定义了 init 进程具体做的工作，函数代码如下：</p><ul><li><code>kernel_init_freeable</code> 函数用于完成 init 进程的一些其他初始化工作；</li><li><code>ramdisk_execute_command</code> 是一个全局的 char 指针变量，此变量值为“/init”，也就是根目录下的 init 程序。ramdisk_execute_command 也可以通过 uboot 传递，在 bootargs 中使用 “rdinit=xxx” 即可，xxx 为具体的 init 程序名字。</li><li>如果存在 “/init” 程序的话就通过函数 <code>run_init_process</code> 来运行此程序。</li><li>如果 ramdisk_execute_command 为空的话就看 <code>execute_command</code> 是否为空，反正不管如何一定要在根文件系统中找到一个可运行的 init 程序。execute_command 的值是通过 uboot 传递，在 bootargs 中使用“init=xxxx”就可以了，比如“init=/linuxrc”表示根文件系统中的 linuxrc 就是要执行的用户空间 init 程序。</li><li>如果 ramdisk_execute_command 和 execute_command 都为空，那么就依次查找“/sbin/init”、“/etc/init”、“/bin/init”和“/bin/sh”，这四个相当于备用 init 程序，如果这四个也不存在，那么 Linux 启动失败</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">kernel_init_freeable();</span><br><span class="line">/* need to finish all async __init code before freeing the memory */</span><br><span class="line">async_synchronize_full();</span><br><span class="line">free_initmem();</span><br><span class="line">mark_readonly();</span><br><span class="line">system_state = SYSTEM_RUNNING;</span><br><span class="line">numa_default_policy();</span><br><span class="line"></span><br><span class="line">rcu_end_inkernel_boot();</span><br><span class="line"></span><br><span class="line">if (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">if (!ret)</span><br><span class="line">return 0;</span><br><span class="line">pr_err(&quot;Failed to execute %s (error %d)\n&quot;,</span><br><span class="line">       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * We try each of these until one succeeds.</span><br><span class="line"> *</span><br><span class="line"> * The Bourne shell can be used instead of init if we are</span><br><span class="line"> * trying to recover a really broken machine.</span><br><span class="line"> */</span><br><span class="line">if (execute_command) &#123;</span><br><span class="line">ret = run_init_process(execute_command);</span><br><span class="line">if (!ret)</span><br><span class="line">return 0;</span><br><span class="line">panic(&quot;Requested init %s failed (error %d).&quot;,</span><br><span class="line">      execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line">if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||</span><br><span class="line">    !try_to_run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">    !try_to_run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">    !try_to_run_init_process(&quot;/bin/sh&quot;))</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">panic(&quot;No working init found.  Try passing init= option to kernel. &quot;</span><br><span class="line">      &quot;See Linux Documentation/init.txt for guidance.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、总结">三、总结</h3><p>我总结了ARMLinux内核代码的启动流程如下图所示：</p><p><img src="/img/4.4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统经典文献索引与语言实践</title>
      <link href="/post/fff3dd6.html"/>
      <url>/post/fff3dd6.html</url>
      
        <content type="html"><![CDATA[<h1>分布式系统经典文献索引与语言实践</h1><hr><h2 id="一、MapReduce">一、MapReduce</h2><h3 id="1-1-概述">1.1 概述</h3><p><code>MapReduce: Simplified Data Processing on Large Clusters</code>提出了一种针对大数据处理的编程模型和实现，使得编程人员无需并行和分布式系统经验就可以轻松构建大数据处理应用。该模型将大数据处理问题拆解为两步，即 <strong>map</strong>和 <strong>reduce</strong>，<strong>map</strong> 阶段将一组输入的键值对转化为中间结果键值对，<strong>reduce</strong> 阶段对中间结果键值对按照相同的键进行值的合并，从而得到最终的结果。</p><h3 id="1-2-背景">1.2 背景</h3><p>对于 Google 来说，每天运行的系统会产生大量的原始数据，同时又要对这些原始数据进行加工产生各种衍生数据，虽然大部分数据加工的逻辑都较为简单，然而由于数据量过于庞大，为了在合理的时间内完成数据处理，通常需要将待处理的数据分发到几百或几千台机器上并行计算，这就存在几个问题：</p><ul><li><ol><li>如何使计算可并行</li></ol></li><li><ol start="2"><li>如何分发数据</li></ol></li><li><ol start="3"><li>如何处理异常</li></ol></li></ul><p>如果每一个数据加工任务都需要独立去解决上述的问题，一方面会使得原本简单的代码逻辑变得庞大、复杂和难以维护，另一方面也是在重复工作。受 <strong>Lisp</strong> 等其他函数式编程语言中的 <strong>map</strong> 和 <strong>reduce</strong> 函数的启发，Google 的工程师们发现大部分的数据处理遵循如下的模式：</p><ul><li><ol><li>对输入的每一条数据应用一个 <strong>map</strong> 函数产生一组中间结果键值对</li></ol></li><li><ol start="2"><li>对中间结果键值对按照相同的键聚合后，应用 <strong>reduce</strong> 函数生成最终的衍生数据</li></ol></li></ul><p>因此，Google 的工程师们抽象出了 <strong>MapReduce</strong> 框架，使得应用开发人员可以专注于计算逻辑实现而无需关心底层运行细节，统一由框架层处理并行、容错、数据分发和负载均衡等系统问题。现在再来看前面提到的问题是如何解决的：</p><ul><li><ol><li>如何使计算可并行：在 <strong>map</strong> 阶段，对数据分发后，各任务间无依赖，可并行执行；在 <strong>reduce</strong> 阶段，不同 <strong>key</strong> 的数据处理间无依赖，可并行执行</li></ol></li><li><ol start="2"><li>如何分发数据：在 <strong>map</strong> 阶段，可按执行 <strong>map</strong> 任务的节点数量平均分发（这只是一种可能的策略，具体分发策略见后文描述）；在 <strong>reduce</strong> 阶段，可按 key 相同的数据聚合后分发</li></ol></li><li><ol start="3"><li>如何处理异常：重新执行某个节点上失败的 <strong>map</strong> 或 <strong>reduce</strong> 任务作为首要的容错手段</li></ol></li></ul><h3 id="1-3-系统架构与关键流程">1.3 系统架构与关键流程</h3><p>在 <strong>map</strong> 执行阶段，框架会自动将输入数据分为 <strong>M</strong> 片，从而将 <strong>map</strong> 任务分发到多台机器上并行执行，每台机器只处理某一片的数据。同样的，在 <strong>reduce</strong> 阶段，框架首先将中间结果数据根据分片函数（例如 <code>hash(key) mod R</code>）拆分为 <strong>R</strong> 片，然后分发给 <strong>reduce</strong> 任务执行，用户可自行指定 <strong>R</strong> 的值和实现具体的分片函数。</p><p>下图展示了 Google 所实现的 <strong>MapReduce</strong> 框架的整体执行流程：<br><img src="/img/mapreduce.png" alt="alt"></p><ul><li><ol><li>首先 MapReduce 框架将输入数据分为 M 片，每片数据大小一般为 16 MB 至 64 MB（具体大小可由用户入参控制），然后将 MapReduce 程序复制到集群中的一批机器上运行。</li></ol></li><li><ol start="2"><li>在所有的程序拷贝中，某台机器上的程序会成为主节点（master），其余称为工作节点（worker），由主节点向工作节点分派任务，一共有 M 个 map 任务和 R 个 reduce 任务需要分派。主节点会选择空闲的工作节点分派 map 或 reduce 任务。</li></ol></li><li><ol start="3"><li>如果某个工作节点被分派了 map 任务则会读取当前的数据分片，然后将输入数据解析为一组键值对后传递给用户自定义的 map 函数执行。map 函数产生的中间结果键值对会暂存在内存中。</li></ol></li><li><ol start="4"><li>暂存在内存中的中间结果键值对会周期性的写入到本地磁盘中，并根据某个分片函数将这些数据写入到本地磁盘下的 R 个区，这样相同键的中间结果数据在不同的 map 节点下属于同一个区号，就可以在后续将同一个键的中间结果数据全部发给同一个 reduce 节点。同时，这些数据写入后的地址会回传给 master 节点，master 节点会将这些数据的地址发送给相应的 reduce 节点。</li></ol></li><li><ol start="5"><li>当 reduce 节点接收到 master 节点发送的中间结果数据地址通知后，将通过 RPC 请求根据数据地址读取 map 节点生成的数据。在所有中间结果数据都读取完成后，reduce 节点会先将所有中间结果数据按照键进行排序，这样所有键相同的数据就聚合在了一起。之所以要排序是因为一个 reduce 节点会分发处理多个键下的中间结果数据。如果中间结果数据量太大不足以完全载入内存，则需要使用外部排序。</li></ol></li><li><ol start="6"><li>reduce 节点执行时会先遍历排序后的中间结果数据，每遇到一个新的键就会将该键及其对应的所有中间结果数据传递给用户自定义的 reduce 函数执行。reduce 函数执行的结果数据会追加到当前 reduce 节点的最终输出文件里。</li></ol></li><li><ol start="7"><li>当所有 map 任务和 reduce 任务都执行完成后，master 节点会唤醒用户程序，并将控制权交还给用户代码。</li></ol></li></ul><hr><h2 id="二、Raft">二、Raft</h2><h3 id="2-1-概述">2.1 概述</h3><p><strong>Raft</strong>是一种分布式一致性算法，旨在解决分布式系统中的数据一致性和容错性问题。它通过选举机制确保系统中的节点选出一个领导者，领导者负责提交客户端的请求，并将一致性日志复制到其他节点，以保持系统的一致性。<strong>Raft</strong>的设计简单明了，容易理解和实现，使得分布式系统的开发和维护更加可靠和可管理。</p><h3 id="2-2-背景">2.2 背景</h3><p>共识算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，共识算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，<strong>Paxos</strong> 主导了关于共识算法的讨论：大多数共识性的实现都是基于 <strong>Paxos</strong> 或受其影响，<strong>Paxos</strong> 已经成为教授学生关于共识知识的主要工具。</p><p>比较遗憾的是，尽管很多人一直在努力尝试使 <strong>Paxos</strong> 更易懂，<strong>Paxos</strong> 还是太难理解了。此外，<strong>Paxos</strong> 的架构需要复杂的改变来支持实际系统。这导致的结果就是系统开发者和学生在学生和使用 <strong>Paxos</strong> 过程中都很挣扎。</p><p>因此<strong>Raft</strong>应运而生，<strong>Raft</strong>是一种比 Paxos 更适合用于实际工程实现并且更易懂的共识算法，在设计 Raft 时，使用了特定的技术来提高它的可理解性，包括：</p><ul><li><ol><li>分解（<strong>Raft</strong> 分离出三个关键点：<code>leader election、log replication、safety</code>）</li></ol></li><li><ol start="2"><li>减少状态空间（相比于 Paxos，<strong>Raft</strong> 降低了不确定性的程度和服务器之间的不一致）</li></ol></li></ul><p>Raft 在许多方面类似于现有的公式算法，但它有几个新特性：</p><ul><li><ol><li><strong>Strong leader</strong>（强领导性）：相比于其他算法，Raft 使用了更强的领导形式。比如，日志条目只能从 leader 流向 follower（集群中除 leader 外其他的服务器）。这在使 Raft 更易懂的同时简化了日志复制的管理流程。</li></ol></li><li><ol start="2"><li><strong>Leader election</strong>（领导选举）：Raft 使用随机计时器来进行领导选举。任何共识算法都需要心跳机制（heartbeats），Raft 只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li></ol></li><li><ol start="3"><li><strong>Membership changes</strong>（成员变更）：Raft 在更改集群中服务器集的机制中使用了一个 联合共识（<code>joint consensus</code>） 的方法。在联合共识（<code>joint consensus</code>）下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ol></li></ul><h3 id="2-3-系统架构与关键流程">2.3 系统架构与关键流程</h3><p><strong>Raft的系统架构：</strong></p><ul><li><ol><li>节点角色：</li></ol><ul><li><strong>Leader</strong>（领导者）：每个Raft集群中都有一个领导者，负责处理客户端的请求，管理日志复制，以及在需要时发起选举。</li><li><strong>Follower</strong>（跟随者）：跟随者是集群中的其他节点，它们听从领导者的指令并复制领导者的日志。</li><li><strong>Candidate</strong>（候选人）：当没有稳定的领导者时，跟随者可以变成候选人，尝试发起选举以成为新的领导者。</li></ul></li><li><ol start="2"><li>通信方式：节点之间通过<code>RPC（Remote Procedure Call）</code>进行通信，用于发送选票、心跳和日志复制等信息。</li></ol></li></ul><p><strong>Raft的关键流程：</strong><br><img src="/img/raft.png" alt="alt"></p><ul><li><ol><li>领导者选举：</li></ol><ul><li>Raft开始时没有领导者，所有节点都是跟随者状态。</li><li>跟随者定期向其他节点发送心跳，以维持活跃状态。</li><li>如果一个跟随者在一段时间内没有收到心跳，它可以变成候选人并发起选举。</li><li>在选举中，候选人请求其他节点的选票，节点投票给第一个请求选票的候选人。</li><li>候选人获得多数选票后，成为新的领导者。</li></ul></li><li><ol start="2"><li>日志复制：</li></ol><ul><li>客户端的请求首先发送给领导者。</li><li>领导者将请求添加到自己的日志中，并将该日志条目分发给所有跟随者。</li><li>跟随者复制领导者的日志，并在确认成功复制后向领导者发送响应。</li><li>当大多数节点都成功复制了一条日志条目，该条目被视为已提交。</li><li>领导者通知其他节点将已提交的日志条目应用到状态机中，以确保所有节点达成一致的状态。</li></ul></li><li><ol start="3"><li>安全性：</li></ol><ul><li>Raft通过多数派投票来确保安全性。只有大多数节点（超过半数）同意的操作才会被提交，以防止分裂大多数的情况。</li></ul></li><li><ol start="4"><li>故障处理：</li></ol><ul><li>如果领导者崩溃或失去联系，跟随者会在一段时间后发起新的选举，选择新的领导者。</li><li>Raft的设计考虑了网络分区、节点崩溃和消息丢失等各种故障情况，并能够自动适应。</li></ul></li></ul><hr><h2 id="三、Golang语言编程基础实践">三、Golang语言编程基础实践</h2><h3 id="3-1-尝试多种方式实现两个goroutine交替打印数字与字母">3.1 尝试多种方式实现两个goroutine交替打印数字与字母</h3><p>例如：12AB34CD…</p><p><strong>方式一：</strong><br>由于本题不涉及复杂的同步互斥操作，所以我们可以简单的使用全局变量来控制两个goroutine的执行顺序。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">i := <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">false</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d%d&quot;</span>,i,i+<span class="number">1</span>)</span><br><span class="line">i += <span class="number">2</span></span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintAlphabet</span><span class="params">()</span></span>&#123;</span><br><span class="line">c := <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">true</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c%c&quot;</span>,c,c+<span class="number">1</span>)</span><br><span class="line">c += <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>( c &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">c = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> PrintNum()</span><br><span class="line"><span class="keyword">go</span> PrintAlphabet()</span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/img/Distributeddemo1.png" alt="alt"></p><p><strong>方式二：</strong><br>使用Go语言的<code>WaitGroup</code>和<code>channel</code>来协调执行顺序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用一个WaitGroup来等待两个goroutine完成</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个channel来协调两个goroutine的输出</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动第一个goroutine，负责打印数字</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> printNumbers(ch, &amp;wg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动第二个goroutine，负责打印字母</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> printLetters(ch, &amp;wg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个goroutine完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数字的goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">26</span>; i+=<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 发送数字到channel</span></span><br><span class="line">ch &lt;- i</span><br><span class="line"><span class="comment">// 等待从另一个goroutine接收到信号后再继续</span></span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Print(i)</span><br><span class="line">fmt.Print(i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印字母的goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> char := <span class="string">&#x27;A&#x27;</span>; char &lt;= <span class="string">&#x27;Z&#x27;</span>; char+=<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 等待从另一个goroutine接收到信号后再继续</span></span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c&quot;</span>, char)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c&quot;</span>, char+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 发送信号到channel</span></span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/img/Distributeddemo2.png" alt="alt"></p><h3 id="3-2-实现整型堆排序">3.2 实现整型堆排序</h3><p><strong>方法一：借助container/heap包</strong></p><p>见代码注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntHeap 实现了 heap.Interface 接口</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现必要的接口方法（Len、Less、Swap、Push 和 Pop）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 构建最小堆</span></span><br><span class="line">h := &amp;IntHeap&#123;&#125;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, arr...)</span><br><span class="line">heap.Init(h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次从堆中弹出最小值，并存入原数组中</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">arr[i] = heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 待排序的整数切片</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 调用堆排序函数</span></span><br><span class="line">heapSort(arr)</span><br><span class="line"><span class="comment">// 打印排序后的结果</span></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/img/Distributeddemo3.png" alt="alt"></p><p><strong>方法二：数组模拟</strong><br>首先构建一个最大堆，然后逐个将最大元素移到数组的末尾，并在每一步重新构建堆。<code>heapify</code> 函数用于维护堆的性质，将一个节点与其子节点进行比较并交换，以确保根节点是最大元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    heapSort(arr)</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个将最大元素移到数组末尾，然后重新构建堆</span></span><br><span class="line">    <span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="comment">// 将当前根节点（最大元素）移到末尾</span></span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// 重新构建堆，排除已排序的元素</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    largest := i</span><br><span class="line">    left := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    right := <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到左子节点和右子节点中较大的节点</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n &amp;&amp; arr[left] &gt; arr[largest] &#123;</span><br><span class="line">        largest = left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> right &lt; n &amp;&amp; arr[right] &gt; arr[largest] &#123;</span><br><span class="line">        largest = right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果较大的节点不是根节点，则交换它们，并继续向下构建堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i &#123;</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/img/Distributeddemo4.png" alt="alt"></p><h3 id="3-3-Golang总结">3.3 Golang总结</h3><p><code>go</code>与<code>c++</code>的异同点：</p><ul><li><p>相同点：</p><ul><li><ul><li>静态类型：Go和C++都是静态类型语言，编译时检查类型。</li></ul></li><li><ul><li>支持并发：Go和C++都支持并发编程，但它们的并发模型和语法不同。Go使用goroutine和channel来实现并发，而C++可以使用多线程和原生线程库来处理并发。</li></ul></li></ul></li><li><p>不同点：</p><ul><li><ul><li>语法和语言设计：Go和C++的语法和语言设计有很大差异。Go以简洁、清晰和易于阅读的语法著称，而C++则更加复杂和灵活，允许更多底层控制。</li></ul></li><li><ul><li>内存管理：Go具有自动垃圾回收（Garbage Collection）机制，开发者无需手动管理内存。C++需要手动管理内存，这可能导致内存泄漏和悬挂指针等问题。</li></ul></li><li><ul><li>面向对象编程：C++是一种多范式语言，支持面向对象编程（OOP）和其他范式。Go也支持OOP，但其面向对象模型相对简单，没有继承的概念，而是使用接口来实现多态。</li></ul></li><li><ul><li>生态系统：Go拥有强大的标准库和丰富的第三方库，特别适用于构建网络服务和分布式系统。C++有广泛的库和框架，适用于系统编程、游戏开发等领域。</li></ul></li><li><ul><li>编译和运行时间：Go具有快速的编译时间和运行时间，适合开发迅速的应用程序。C++的编译时间可能较长，但可以生成高性能的本机代码。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023上半年总结</title>
      <link href="/post/53d98f9e.html"/>
      <url>/post/53d98f9e.html</url>
      
        <content type="html"><![CDATA[<p>从写下<a href="https://v1per3.github.io/post/20bbe8e4.html">2022总结</a>到现在转眼就过去了半年，之前订的计划有成功也有还没开始似乎就要放弃的，遂想着再订正一下，于是就写一篇博客。</p><h2 id="回顾一下-3">回顾一下</h2><p>首先则是成功上岸，俗话说研究生只有收到通知书的那一刻是快乐的，确实，录取完就开始想以后的路咋走，又有点慌，期间想过找个老师搞学术好了，但是似乎不了了之了，还是得走工程实践的路。今年就业形势又斗转直下，传统开发不知道一年后又是那副模样了，所以就想着要不就转嵌入式得了，至少能有口饭吃。<br>然后则是力扣题，半年刷了400道，大抵是达到了目标，结果这一两个月忙毕设好久没碰感觉又忘完了。<br>最后就是生活上，这方面确实还行，胃好了后，然后又出去玩了玩，感觉轻松了不少。</p><h2 id="展望一下-3">展望一下</h2><p>下半年的主要任务说实话还不明朗，目前的想法则是在暑假学一下stm32和51，开学去合肥再说其他的，尽量保持在正轨上。力扣准备也先放一放，等到以后就业季了再刷，毕竟有一些基础了。生活上的话就是精神富足，ok！</p><h2 id="总结一下-3">总结一下</h2><p>最后就是感谢家人们，源源不断的动力来源，&gt;&lt;<br>然后就是毕业快乐，谢谢这四年来的老师和朋友们，也祝大家端午快乐。</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于shuffle-attention的语音情感识别研究</title>
      <link href="/post/262580a2.html"/>
      <url>/post/262580a2.html</url>
      
        <content type="html"><![CDATA[<p>本文模型是在<a href="https://github.com/lessonxmk/Optimized_attention_for_SER">基于area-attention的模型</a>上改进得到的</p><p>本文模型在github的源码仓库为：<a href="https://github.com/V1per3/shuffle_attention_for_SER">https://github.com/V1per3/shuffle_attention_for_SER</a></p><p>如下图所示：<br><img src="/img/SACNN.png" alt="SACNN"><br>本文模型将<strong>Shuffle Attention</strong>与<strong>卷积神经网络</strong>结合构建了一个新型的语音情感识别模型，该模型通过librosa音频处理库将原始音频文件处理成梅尔频谱图（logMel spectrogram）作为学习的特征，将其送入到两个并行卷积层，分别从时间轴和频率轴提取纹理;结果被送入到五个连续的卷积层，并生成一个128通道的张量。对于这5个连续的卷积层（CNN Block），本文采用残差连接的思想对传统卷积神经网络进行优化改进而得到，之后再将卷积神经网络输出的结果送入到Shuffle Attention注意力层中，捕获频谱图中成对的像素级关系和通道间依赖关系，从通道和空间两个方面来提取特征，最后再送入到全连接层中进行分类。在第一个和第二个CNN Block之后通过Max Pooling进行降采样。</p><p>shuffle attention的具体机理如下图所示：<br><img src="/img/SA.png" alt="SA"><br>首先将输入的特征沿着通道方向分为g组，然后对每一组的特征进行分割（split）操作，对分割后的两个分支分别使用<strong>全局平均池化</strong>和<strong>组归一化</strong>来提取通道注意力和空间注意力，之后分别使用一对参数对张量进行缩放和平移，随后对两种注意力都使用sigmoid进行计算得到对应的权值矩阵，再分别与原始输入特征相乘进而得到想要的特征。接着，将两个分支的结果拼接到一起，然后合并，得到和输入尺寸一致的特征图。最后，用一个Channel Shuffle函数进行处理，融合不同组之间的信息。</p><p>对于语言情感识别任务，引入Shuffle Attention，具有以下意义：<strong>首先</strong>，Shuffle Attention机制能够捕捉语音信号中频谱图像素级的局部关系。情感信息常常体现在语音信号的细微变化和局部区域中，通过对频谱图的局部关系进行建模，Shuffle Attention可以有效地提取关键的情感相关特征。<strong>第二</strong>，Shuffle Attention结合卷积神经网络，能够从通道和空间两个方面提取特征。通过对频谱图中的通道和空间信息进行交叉注意，模型可以更全面地理解语音信号中的情感表达，并提高特征的表达能力。<strong>第三</strong>，通过捕捉局部关系、增强特征学习和优化特征表达能力，Shuffle Attention可以提高模型对情感信息的敏感性和识别准确度，从而提升语音情感识别模型的性能。</p><p>现有的语音情感识别模型大多从空间注意力或者通道注意力某一粒度出发，不能充分提取频谱图中的信息，而本文模型从通道和空间两个方面来提取特征，并且引入残差连接来加深网络深度，增强网络对于语言情感的预测精确度，加权精度(WA)与非加权精度(UA)分别达到了82.21%、80.09%，相较于<a href="https://github.com/lessonxmk/Optimized_attention_for_SER">基准模型</a>提高了约2.87%、2.55%，获得了十分具有竞争力的结果。</p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack入门</title>
      <link href="/post/1f3a274b.html"/>
      <url>/post/1f3a274b.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是webpack">什么是webpack</h2><p>简单来说就是一个<strong>打包工具</strong>，</p><p>可以将互相依赖的html、css、js以及图片字体等资源文件，经过处理打包成一个可执行的项目文件</p><h2 id="环境初始化">环境初始化</h2><p>在需要使用webpack的文件夹下，</p><p>首先执行<code>npm init -y</code>初始化，其中<code>-y</code>表示所有选项使用默认值</p><p>再执行<code>npm add webpack webpack-cli --dev</code>将webpack安装到开发者环境中</p><p>这样我们就能获得初始的开发环境</p><h2 id="配置webpack">配置webpack</h2><p>这里才是学习webpack的重头戏，毕竟在webpack配置完成后，每次只要执行npx webpack便能智能地完成打包</p><h3 id="初步配置">初步配置</h3><p>在根目录下新建一个’webpack.config.js’文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &quot;./src/index.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;dist.js&quot;,</span><br><span class="line">        path: path.resolve(__dirname,&quot;dist&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>mode</code>，选择了开发者模式</li><li><code>entry</code>，选择了相对于config文件的src目录下的index.js作为入口文件</li><li><code>output</code>, 对于输出配置了输出的名字，并且使用了自带的path配置了输出目录</li></ul><p>执行<code>npx webpack</code>，可以看到不仅重新输出了dist.js，其中的内容也和之前的有了不一样</p><h3 id="打包CSS文件和图片">打包CSS文件和图片</h3><p>要先安装 <code>npm add --dev style-loader css-loader</code><br>然后要在webpack.config.js里对需要引入的文件名进行配置，如配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/i,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|svg|jpg|jpeg|gif)$/i,</span><br><span class="line">        type: &quot;asset/resource&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="使用webpack插件自动生成html文件">使用webpack插件自动生成html文件</h3><p>还是安装<br><code>npm add html-webpack-plugin --dev</code><br>然后导入webpack.config.js文件<br><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)</code><br>再进行配置即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &quot;博客列表&quot;,</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>所以这时候再执行打包命令，可以看到输出文件夹下还多了一个index.html</p><p>这个HTML的标题默认为Webpack App</p><p>我们也可以对这个进行配置</p><h3 id="兼容低版本浏览器">兼容低版本浏览器</h3><p>要让新的JavaScript的特性兼容低版本的浏览器，需要用到babel，而webpack也支持相应的loader</p><p>所以首先还是安装<br><code>npm add --dev babel-loader @babel/core @babel/preset-env</code><br>这三个包提供了我们需要的功能<br>然后再进行下面的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: &quot;babel-loader&quot;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      presets: [&quot;@babel/preset-env&quot;],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="压缩打包后的js代码">压缩打包后的js代码</h3><p>同样是两步，先安装<br><code>npm add --dev terser-webpack-plugin</code><br>然后引入和配置<br><code>const TerserPlugin = require(&quot;terser-webpack-plugin&quot;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimize: true,</span><br><span class="line">  minimizer: [new TerserPlugin()],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="无需执行命令自动打包">无需执行命令自动打包</h3><p>现在每次修改了代码后都得重新执行打包命令<br>webpack也提供了一个插件能在保存后自动打包</p><p>还是先安装<br><code>npm add --dev webpack-dev-server</code><br>然后先在webpack.config.js中进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  static: &quot;./dist&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再在package.json中进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack serve --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样在我们执行npm start的时候就会自动执行webpack serve<br>并且通过 npm start 打开的网页能在我们修改保存后自动刷新页面</p><h3 id="避免浏览器缓存js文件">避免浏览器缓存js文件</h3><p>由于现在每次生成的文件名都是dist.js，所以浏览器会对这个文件进行缓存，进而不更新<br>为了避免进行缓存，可以给文件名添加一段随机的字符，每次更新后都生成新的随机字符<br>所以在webpack.config.js中配置输出即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &quot;[name].[contenthash].js&quot;,</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="配置可视化打包工具">配置可视化打包工具</h3><p>这是一个帮助分析的工具，它会可视化地展现打包过程中哪个文件占的体积比较大<br>所以同样的，先是安装这个插件<br><code>npm add --dev webpack-bundle-analyzer</code><br>接着在配置中引入这个插件<br><code>const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;);</code><br>以及在plugins中添加它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    title: &quot;test&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  new BundleAnalyzerPlugin.BundleAnalyzerPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记</title>
      <link href="/post/31ba8457.html"/>
      <url>/post/31ba8457.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="516-最长回文子序列（dp）">516.最长回文子序列（dp）</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。</p><p>用 dp[i][j] 表示字符串 s 的下标范围[i,j] 内的最长回文子序列的长度。假设字符串 s的长度为 n，则只有当0&lt;=i&lt;=j&lt;n时,才会有dp[i][j]&gt;0，否则dp[i][j]=0。</p><p>由于任何长度为 1 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0&lt;=i&lt;n，都有dp[i][i]=1。</p><p>当 i&lt;j 时，计算 dp[i][j] 需要分别考虑 s[i] 和s[j] 相等和不相等的情况：</p><ol><li><p>如果 s[i] = s[j]，则首先得到 s 的下标范围 [i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和s[j]，即可得到 s 的下标范围[i,j] 内的最长回文子序列，因此dp[i][j]=dp[i+1][j−1]+2；</p></li><li><p>如果s[i] !=s[j]，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此dp[i][j]=max(dp[i+1][j],dp[i][j−1])。</p></li></ol><p>由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。</p><p>最终得到 dp[0][n−1] 即为字符串 s 的最长回文子序列的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">//生成二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> dp[n][n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列（dp）">1143.最长公共子序列（dp）</h2><p>给定两个字符串 <code>text1</code> 和<code> text2</code>，返回这两个字符串的最长<strong>公共子序列</strong>的长度。如果不存在<strong>公共子序列</strong>，返回 0 。</p><p>一个字符串的<strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><pre><code>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。</code></pre><p>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p><strong>状态转移方程为</strong>：</p><ol><li>当text1[i−1]==text2[j−1]: dp[i][j]=dp[i−1][j−1]+1;</li><li>当text1[i−1]!=text2[j−1]: dp[i][j]=max(dp[i−1][j],dp[i][j−1]);</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(<span class="type">char</span> * text1, <span class="type">char</span> * text2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(text1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(text2);</span><br><span class="line">    <span class="type">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=fmax(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1312-让字符串成为回文串的最少插入次数（dp）">1312.让字符串成为回文串的最少插入次数（dp）</h2><p>是前两个题的变种，有两种解法</p><ol><li>求字符串与逆序串的最长公共子序列s，然后用n-s即可</li><li>该题的状态转移方程如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == s[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i][j] = fmax(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="405-数字转换为十六进制数（位运算）">405. 数字转换为十六进制数（位运算）</h2><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p>注意:</p><ol><li>十六进制中所有字母(a-f)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。</li><li>给定的数确保在32位有符号整数范围内。</li><li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li></ol><p><strong>C语言动态分配</strong></p><p>malloc函数。其原型void *malloc(unsigned int num_bytes)；<br>num_byte为要申请的空间大小，需要我们手动的去计算，如int *p = (int *)malloc(20 * sizeof(int)),如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。</p><p>calloc函数，其原型void *calloc(size_t n, size_t size)；<br>其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p = (int *)calloc(20, sizeof(int)）,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//主要是通过与操作来实现</span><br><span class="line">char * toHex(int num)&#123;</span><br><span class="line">    char c[16]=&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;</span><br><span class="line">    char * ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*9);</span><br><span class="line">    for(int i=7;i&gt;=0;--i)&#123;</span><br><span class="line">        ans[i]=c[num&amp;0xF];//每位16进制</span><br><span class="line">        num=num&gt;&gt;4;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[8]=&#x27;\0&#x27;;</span><br><span class="line">    while(ans[0]==&#x27;0&#x27;&amp;&amp;*(ans+1)!=&#x27;\0&#x27;)&#123;//剔除前缀0</span><br><span class="line">        ans=ans+1;//指针右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量-（DFS）">200.岛屿数量 （DFS）</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>题解</strong></p><p>一共三种方法，DFS,BFS和并查集，此处只给出DFS的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*dfs:将数组grid中(i,j)元素至0</span><br><span class="line">char ** grid：目标数组</span><br><span class="line">int i：需要至0的位置</span><br><span class="line">int j: 需要至0的位置</span><br><span class="line">int m：数组行数</span><br><span class="line">int n：数组列数</span><br><span class="line">返回值：无</span><br><span class="line">*/</span><br><span class="line">void dfs(char ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i+1, j, m, n);</span><br><span class="line">    dfs(grid, i-1, j, m, n);</span><br><span class="line">    dfs(grid, i, j+1, m, n);</span><br><span class="line">    dfs(grid, i, j-1, m, n);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">*numIslands：计算grid中存在相邻为1的个数</span><br><span class="line">char** grid：数组</span><br><span class="line">int gridSize:数组行数</span><br><span class="line">int* gridColSize:数组列数</span><br><span class="line">返回值：相邻为1的个数</span><br><span class="line">*/</span><br><span class="line">int numIslands(char** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                dfs(grid, i, j, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积-（DFS）">695.岛屿的最大面积 （DFS）</h2><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p><strong>题解</strong></p><p>在200的基础上，在DFS中计算面积即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1+dfs(grid, i+1, j, m, n)+dfs(grid, i-1, j, m, n)+dfs(grid, i, j+1, m, n)+dfs(grid, i, j-1, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int max = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                count = dfs(grid, i, j, m, n);</span><br><span class="line">                max = fmax(max,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串-（hash-滑动窗口）">3.无重复字符的最长子串 （hash+滑动窗口）</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><p><strong>滑动窗口解决</strong></p><p>需要借助hash结构存储重复元素</p><p>此处使用数组模拟hash表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(char * s)&#123;</span><br><span class="line">    int sLen = strlen(s); //获取字符串长度</span><br><span class="line">    int left=0, right = 0; //左右指针</span><br><span class="line">    int res=0, cnt=0; //结果和计数</span><br><span class="line">    int tmp[128] = &#123;0&#125;; //以128位数组记录字串中的字符是否已经出现</span><br><span class="line">    </span><br><span class="line">    while(right &lt; sLen) &#123;           //循环条件为右指针小于字符串长度</span><br><span class="line">        if(tmp[s[right]] == 0) &#123;  //当右指针指向的字符没出现在子串中时</span><br><span class="line">            tmp[ s[right] ]=1;       //使用tmp数组记录右指针指向的字符在ascii码中对应的位置</span><br><span class="line">            right++;                     //右指针右移</span><br><span class="line">            cnt++;                       //计数加1</span><br><span class="line">            res = res &gt; cnt ? res : cnt;   //记录结果</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;                            //当右指针指向的字符出现在子串中时</span><br><span class="line">            tmp[ s[left] ] = 0;     //左指针指向字符的ascii码不再出现在tmp数组中</span><br><span class="line">            left++;                    //左指针右移</span><br><span class="line">            cnt--;                      //计数减1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;          //返回最终无重复字串长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>javascript解法(使用set)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    // 哈希集合，记录每个字符是否出现过</span><br><span class="line">    const occ = new Set();</span><br><span class="line">    const n = s.length;</span><br><span class="line">    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br><span class="line">    let rk = -1, ans = 0;</span><br><span class="line">    for (let i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (i != 0) &#123;</span><br><span class="line">            // 左指针向右移动一格，移除一个字符</span><br><span class="line">            occ.delete(s.charAt(i - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) &#123;</span><br><span class="line">            // 不断地移动右指针</span><br><span class="line">            occ.add(s.charAt(rk + 1));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br><span class="line">        ans = Math.max(ans, rk - i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串-dp">5.最长回文子串 (dp)</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>动态规划</strong></p><p>状态转移方程：<br>P(i,j)=P(i+1,j−1)∧(Si==Sj​)</p><p>也就是说，只有s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j]才会是回文串。</p><p>动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：</p><ol><li>P(i,i)=true</li><li>P(i,i+1)=(Si==Si+1)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//C</span><br><span class="line">char * longestPalindrome(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n&lt;2)&#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxLen = 1;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    // dp[i][j] 表示 s[i..j] 是否是回文串</span><br><span class="line">    int dp[n][n];</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j=1 ; j &lt; n; j++) &#123;</span><br><span class="line">        // 左下角先填</span><br><span class="line">        for (int i = 0; i &lt; j; i++) &#123;</span><br><span class="line">            if (s[i] != s[j]) &#123;</span><br><span class="line">                dp[i][j] = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (j - i &lt; 3) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                maxLen = j - i + 1;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char *ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*(maxLen+1));</span><br><span class="line">    for(int i=0; i&lt;maxLen; i++)&#123;</span><br><span class="line">        ans[i]=s[begin+i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[maxLen]=&#x27;\0&#x27;;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-回文数">9.回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><pre><code>例如，121 是回文，而 123 不是。</code></pre><p>将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于int.MAX，我们将遇到整数溢出问题。</p><p>为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        // 特殊情况：</span><br><span class="line">        // 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br><span class="line">        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br><span class="line">        // 则其第一位数字也应该是 0</span><br><span class="line">        // 只有 0 满足这一属性</span><br><span class="line">        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int revertedNumber = 0;</span><br><span class="line">        while (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * 10 + x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br><span class="line">        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br><span class="line">        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br><span class="line">        return x == revertedNumber || x == revertedNumber / 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-整数反转">7.整数反转</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)&#123;</span><br><span class="line">     int rev = 0;</span><br><span class="line">        while (x != 0) &#123;</span><br><span class="line">            if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            int digit = x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">            rev = rev * 10 + digit;</span><br><span class="line">        &#125;</span><br><span class="line">    return rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和（快排-双指针）">15.三数之和（快排+双指针）</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p><strong>使用快排+双指针</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void *a,const void *b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int*)a - *(int*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if(numsSize &lt; 3)</span><br><span class="line">        return NULL;</span><br><span class="line">    qsort(nums,numsSize,sizeof(int),cmp);</span><br><span class="line">    int **ans = (int **)malloc(sizeof(int *) * numsSize  *numsSize);</span><br><span class="line">    *returnColumnSizes = (int *)malloc(sizeof(int) * numsSize * numsSize);</span><br><span class="line">    int i,j,k,sum;</span><br><span class="line"></span><br><span class="line">    int indexLeft   = 0;</span><br><span class="line">    int indexMiddle = 0;</span><br><span class="line">    int indexRight  = 0;</span><br><span class="line">    //快排过后，使用三指针 遍历</span><br><span class="line">    //左边遍历到倒数第三位即可</span><br><span class="line">    for(indexLeft = 0; indexLeft&lt; numsSize - 2; indexLeft++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[indexLeft] &gt; 0) </span><br><span class="line">        &#123;</span><br><span class="line">            //因为是快排的结果，所以如果出现大零的</span><br><span class="line">            //后面的值都是大于0的</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果值相同 则不需要遍历</span><br><span class="line">        if(indexLeft &gt; 0 &amp;&amp; nums[indexLeft] == nums[indexLeft-1])</span><br><span class="line">            continue;</span><br><span class="line">        indexMiddle = indexLeft + 1;</span><br><span class="line">        indexRight  = numsSize - 1;</span><br><span class="line"></span><br><span class="line">        //双指遍历 找到所有的可能</span><br><span class="line">        while(indexMiddle &lt; indexRight)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = nums[indexLeft] + nums[indexMiddle] + nums[indexRight];</span><br><span class="line"></span><br><span class="line">            if(sum == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[*returnSize] = (int*)malloc(sizeof(int)*3);</span><br><span class="line">                (*returnColumnSizes)[*returnSize] = 3;</span><br><span class="line">                ans[*returnSize][0] = nums[indexLeft];</span><br><span class="line">                ans[*returnSize][1] = nums[indexMiddle];</span><br><span class="line">                ans[*returnSize][2] = nums[indexRight];</span><br><span class="line">                *returnSize += 1;</span><br><span class="line">                //过滤相等的值</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexMiddle] == nums[++indexMiddle]);</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexRight] == nums[--indexRight]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //左边递减</span><br><span class="line">                indexRight--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //右边递增</span><br><span class="line">                indexMiddle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器（双指针）">11.盛最多水的容器（双指针）</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>使用双指针解决</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxArea(int* height, int heightSize)&#123;</span><br><span class="line">    int marea = 0;</span><br><span class="line">    int carea = 0;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = heightSize-1;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        carea = (right-left)*fmin(height[left],height[right]);</span><br><span class="line">        marea = fmax(carea,marea);</span><br><span class="line">        if(height[left]&lt;=height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return marea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号（栈）">20.有效的括号（栈）</h2><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>用栈解决</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool isValid(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n%2!=0) return 0;</span><br><span class="line">    char *stack = (char *)malloc(sizeof(char)*n);</span><br><span class="line">    int top = -1;</span><br><span class="line">    for(int i = 0; i&lt;n ;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;||s[i]==&#x27;&#123;&#x27;||s[i]==&#x27;[&#x27;)&#123;</span><br><span class="line">            stack[++top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;(&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;&#125;&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;&#123;&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;]&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;[&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(top==-1) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个结点（快慢指针）">19.删除链表的倒数第N个结点（快慢指针）</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>官方题解，使用哑结点dummy避免头结点的讨论</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    struct ListNode* dummy = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;//构造虚拟节点，避免头节点的讨论</span><br><span class="line"></span><br><span class="line">    struct ListNode* first = head;</span><br><span class="line">    struct ListNode* second = dummy;//定义快慢指针</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;//快指针先走</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (first) &#123;//慢指针跟上</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;//删除慢指针指向的下一个元素</span><br><span class="line">    struct ListNode* ans = dummy-&gt;next;</span><br><span class="line">    free(dummy);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自己的想法</strong></p><p>利用两个指针，一个在前，一个在后，相差n；让p1先走n步。</p><ol><li>如果p1为空，说明n正好为链表长度，所以删除倒数第n个就是删除第一个；</li><li>如果p1不为空，p2从头开始和p1一起移动，此时二者相差n个，当p1的下一个为空，说明p1正好是最后一个，倒数第n就正好是p2的下一个，所以删除p2的下一个即可；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct ListNode *p1=head,*p2=head;</span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL)&#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p1==NULL) head=head-&gt;next;</span><br><span class="line">    else p2-&gt;next=p2-&gt;next-&gt;next;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表（迭代）">21.合并两个有序链表（迭代）</h2><p>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>迭代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;</span><br><span class="line">    struct ListNode * preHead = malloc(sizeof(struct ListNode));</span><br><span class="line">    struct ListNode* prev = preHead;</span><br><span class="line">        while (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">            if (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br><span class="line">        prev-&gt;next = list1 == NULL ? list2 : list1;</span><br><span class="line"></span><br><span class="line">        return preHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-括号生成（回溯-模板）">22.括号生成（回溯 模板）</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是不停选括号，要么选左括号，要么选右括号。<br>并有这些约束的：</p><ol><li><p>只要(有剩，就可以选(。(((((这么选，都还不能判定为非法。</p></li><li><p>当剩下的)比(多时，才可以选)，否则，)不能选，选了就非法。因为：剩下的)比(少，即，使用的)比(多，不能成双成对。</p></li></ol><p>描述节点的状态有：当前构建的字符串，和左右括号所剩的数量。</p><p><strong>选择</strong></p><p>在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树。<br>用 DFS 遍历这棵树，找出所有的解，这个过程叫回溯。</p><p><strong>约束条件：</strong></p><p>即，什么情况下可以选左括号，什么情况下可以选右括号。<br>利用约束做“剪枝”，即，去掉不会产生解的选项，即，剪去不会通往合法解的分支。<br>比如()，现在左右括号各剩一个，再选)就成了())，不能让这个错的选择成为选项（不落入递归）：</p><p>if (right &gt; left) { // 右括号剩的比较多，才能选右括号<br>dfs(str + ‘)’, left, right - 1);<br>}</p><p><strong>目标：</strong></p><p>构建出一个用尽 n 对括号的合法括号串。<br>意味着，当构建的长度达到 2 * n，就可以结束递归（不用继续选了）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void generate(int left,int right,int size,char* str,int n, int* returnSize,char** result)</span><br><span class="line">//left代表左括号数量，right代表右括号数量，str代表储存几组有效组合，returnsize表示返回数量</span><br><span class="line">&#123;</span><br><span class="line">if (left == n &amp;&amp; right == n) </span><br><span class="line">&#123; // 满足题意的题解</span><br><span class="line">result[(*returnSize)] = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">strcpy(result[(*returnSize)++], str);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 如果左括号数量不大于 n，可以放一个左括号</span><br><span class="line">if (left &lt; n) </span><br><span class="line">&#123;</span><br><span class="line">str[size] = &#x27;(&#x27;;</span><br><span class="line">generate(left + 1, right, size + 1, str, n,  returnSize, result);</span><br><span class="line">&#125;</span><br><span class="line">// 如果右括号数量小于左括号的数量，可以放一个右括号</span><br><span class="line">if (right &lt; left) </span><br><span class="line">&#123;</span><br><span class="line">str[size] = &#x27;)&#x27;;</span><br><span class="line">generate(left , right+1, size + 1, str, n, returnSize, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">char ** generateParenthesis(int n, int* returnSize)</span><br><span class="line">&#123;</span><br><span class="line">char *str = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">char **result = (char**)malloc(sizeof(char*) * 1430); </span><br><span class="line">// 卡特兰数: 1, 2, 5, 14, 42, 132, 429, 1430，题目中最多生成1430组</span><br><span class="line">*returnSize = 0;</span><br><span class="line">generate(0, 0, 0, str, n, returnSize, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//卡特兰数的一个递推函数</span><br><span class="line">int catalan(n) &#123;</span><br><span class="line">  int i, j, h[n + 1];</span><br><span class="line">  h[0] = h[1] = 1;</span><br><span class="line">  for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    h[i] = 0;</span><br><span class="line">    for (j = 0; j &lt; i; j++)</span><br><span class="line">      h[i] = h[i] + h[j] * h[i - j - 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return h[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-找出字符串中第一个匹配项的下标（KMP）">28.找出字符串中第一个匹配项的下标（KMP）</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p><strong>KMP算法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int strStr(char* haystack, char* needle) &#123;</span><br><span class="line">    int n = strlen(haystack), m = strlen(needle);</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int next[m];</span><br><span class="line">    //求next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    for (int i = 1, j = 0; i &lt; m; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //求第一个匹配项下标</span><br><span class="line">    for (int i = 0, j = 0; i &lt; n; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == m) &#123;</span><br><span class="line">            return i - m + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组成（回溯）">17.电话号码的字母组成（回溯）</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string temp;<span class="comment">//存储一个个字符串</span></span><br><span class="line">    vector&lt;string&gt; res;<span class="comment">//结果字符串列表</span></span><br><span class="line">    vector&lt;string&gt; map = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string digits,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//回溯</span></span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(pos == len)&#123;<span class="comment">//如果pos+1后的结果与len相等，说明上轮循环已经把所有长度的字符都压进去了，是一个结果字符串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);<span class="comment">//所以压该字符串进列表</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//该层不进行循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//转换为数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map[num].<span class="built_in">size</span>(); i++)&#123;<span class="comment">//把该数字所对应的所有字母一个个循环遍历</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(map[num][i]);<span class="comment">//压该字符</span></span><br><span class="line">            <span class="built_in">DFS</span>(digits,pos+<span class="number">1</span>);<span class="comment">//进入深层，去压下一位上的字符，直至pos到len</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();<span class="comment">//需要压出最后一个字符，压入一个新轮循环的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">DFS</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置（二分查找）">34.在排序数组中查找元素的第一个和最后一个位置（二分查找）</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int findmid(int *nums, int low , int high , int target)&#123;</span><br><span class="line">    //递归实现二分查找</span><br><span class="line">    //if(low &gt; high) return -1; </span><br><span class="line">    //int mid = (low + high)/2;</span><br><span class="line">    //if(nums[mid]==target) return mid;</span><br><span class="line">    //else if(nums[mid]&gt;target) return findmid(nums,low,mid-1,target);</span><br><span class="line">    //else return findmid(nums,mid+1,high,target);</span><br><span class="line">    //迭代实现</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = (low + high)/2;</span><br><span class="line">        if(nums[mid]==target) return mid;</span><br><span class="line">        else if(nums[mid]&gt;target)high = mid -1;</span><br><span class="line">        else low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int* searchRange(int* nums, int numsSize, int target, int* returnSize)&#123;</span><br><span class="line">    *returnSize=2;</span><br><span class="line">    int *result = (int*)malloc(sizeof(int)*2);</span><br><span class="line">    if(numsSize == 0)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = findmid(nums,0,numsSize-1,target);</span><br><span class="line">    if(ans == -1)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int low=ans,high=ans;</span><br><span class="line">        while((low-1)&gt;=0&amp;&amp;nums[low-1]==target) low--;</span><br><span class="line">        while((high+1)&lt;numsSize&amp;&amp;nums[high+1]==target) high++;</span><br><span class="line">        result[0]=low;result[1]=high;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result[0]=-1;result[1]=-1;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和（dp-贪心）">53.最大子数组和（dp||贪心）</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//dp解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int pre = 0, maxAns = nums[0];</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        pre = fmax(pre + nums[i], nums[i]);</span><br><span class="line">        maxAns = fmax(maxAns, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//贪心解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int result = INT_MIN;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            result = fmax(tmp, result);</span><br><span class="line">            if(tmp &lt; 0) tmp = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列（回溯）">46.全排列（回溯）</h2><p>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以按任意顺序返回答案。</p><p><strong>回溯</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void swap(int * nums,int indexA,int indexB)</span><br><span class="line">&#123;</span><br><span class="line">    int temp    = nums[indexA];</span><br><span class="line">    nums[indexA]= nums[indexB];</span><br><span class="line">    nums[indexB]= temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void prem(int* nums, int numsSize, int* returnSize, int** returnColumnSizes,int** returnNums,int offset)</span><br><span class="line">&#123;</span><br><span class="line">    if(offset == numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历到末尾了</span><br><span class="line">        //申请returnNums</span><br><span class="line">        returnNums[*returnSize] = (int *)malloc(sizeof(int ) * numsSize);</span><br><span class="line">        //拷贝内容到returnNums</span><br><span class="line">        memcpy(returnNums[*returnSize],nums,sizeof(int) * numsSize );</span><br><span class="line">        //记录当前拷贝内容的长度</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = numsSize;</span><br><span class="line">        *returnSize = *returnSize + 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //回溯算法的核心</span><br><span class="line">        int i;</span><br><span class="line">        for(i = offset; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">            prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,offset+1);</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    //不重复的数字的全排序</span><br><span class="line">    //组合次数为 n！= n *( n - 1) *( n - 2) ...... 2 * 1</span><br><span class="line">    //这样的方法适合回溯的方法</span><br><span class="line">    //取值范围1 &lt;= nums.length &lt;= 6  = 6 * 5 * 4 * 3 *2 * 1 = 720中可能</span><br><span class="line">    int **returnNums = (int **)malloc(sizeof(int *) * 721);</span><br><span class="line">    *returnColumnSizes= (int *)malloc(sizeof(int ) * 721);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,0);</span><br><span class="line">    return returnNums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏（贪心）">55.跳跃游戏（贪心）</h2><p>给定一个非负整数数组 nums ，你最初位于数组的<strong>第一个下标</strong>。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>题解</strong></p><p>对于每一个可以到达的位置 i，它使得 i+1, i+2,···,i+nums[i] 这些连续的位置都可以到达。</p><p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 i+nums[i] 更新 最远可以到达的位置。</p><p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool canJump(int* nums, int numsSize)&#123;</span><br><span class="line">    int mostf = 0;</span><br><span class="line">    for(int i=0;i&lt;numsSize;i++)&#123;</span><br><span class="line">        if(i&lt;=mostf)&#123;</span><br><span class="line">            mostf =fmax(mostf,i+nums[i]);</span><br><span class="line">            if(mostf&gt;=numsSize-1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍（dp）">198.打家劫舍（dp）</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>对于第 i(i&gt;2) 间房屋，有两个选项：</p><p>偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋，偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和。</p><p>不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额。</p><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 i 间房屋能偷窃到的最高总金额。</p><p>用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><pre><code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code></pre><p>边界条件为：</p><ol><li>只有一间房屋，则偷窃该房屋：dp[0]=nums[0]</li><li>只有两间房屋，选择其中金额较高的房屋进行偷窃：dp[1]=max(nums[0],nums[1])</li></ol><p>最终的答案即为 dp[n−1]，其中 n 是数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int rob(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    if(numsSize==0) return 0;</span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line">    if(numsSize&gt;=2)&#123;</span><br><span class="line">        dp[1] = fmax(nums[0],nums[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 2 ; i &lt; numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = fmax(dp[i-1],dp[i-2]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[numsSize-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Z字形变化">6.Z字形变化</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：<br>P * A * H * N<br>A P L S I I G<br>Y * I * R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“PAHNAPLSIIGYIR”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;              <span class="comment">// 给定行数为 1 时结果与原字符串一样</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(numRows)</span></span>;            <span class="comment">// 创建 res 保存每行结果</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;                              <span class="comment">// 行数标志</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">-1</span>;                          <span class="comment">// 往上走还是往下走的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;ch : s) &#123;                    <span class="comment">// 遍历 s</span></span><br><span class="line">            res[i] += ch;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;   <span class="comment">// 行首行尾变向</span></span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            i += flag;                          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;     <span class="comment">// 将每行接起来就是结果</span></span><br><span class="line">            res[<span class="number">0</span>] += res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机II（dp-贪心）">122.买卖股票的最佳时机II（dp||贪心）</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润 。</p><p><strong>题解</strong></p><p><strong>贪心</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        ans += fmax(0, prices[i] - prices[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dp</strong><br>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p><p>定义状态 dp[i][0] 表示第 ii 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p><p>考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p><p>dp[i][0]=max{dp[i−1][0],dp[i−1][1]+prices[i]}</p><p>再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：</p><p>dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}</p><p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][1]=−prices[0]。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。</p><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1][0] 和 dp[i−1][1] 存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        int newDp0 = fmax(dp0, dp1 + prices[i]);</span><br><span class="line">        int newDp1 = fmax(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = newDp0;</span><br><span class="line">        dp1 = newDp1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="300-最长递增子序列（dp）">300.最长递增子序列（dp）</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>题解</strong></p><p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p><p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：</p><p>dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p><p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p><p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    int maxans = 1;</span><br><span class="line">    for(int i = 1; i&lt;numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = fmax(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxans = fmax(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78-子集（回溯-迭代-递归）">78.子集（回溯 迭代 递归）</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>记原序列中元素的总数为 n。原序列中的每个数字 a_i 的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n 的 0/1 序列，第 i 位表示a_i是否在子集中。</p><p>可以发现 0/1 序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0,2n−1]，mask 的二进制表示是一个 0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。</p><p><strong>迭代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnSize = 1 &lt;&lt; numsSize;</span><br><span class="line">    int t[numsSize];</span><br><span class="line">    for (int mask = 0; mask &lt; (1 &lt;&lt; numsSize); ++mask) &#123;</span><br><span class="line">        int tSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">//&lt;&lt;表示向左移位，1 &lt;&lt; i 表示第i位为1，其他位为0的整型值，Mask &amp; ( 1 &lt;&lt; i )表示检验标志变量Mask的第i位是否为1</span><br><span class="line">                t[tSize++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * tSize);</span><br><span class="line">        memcpy(tmp, t, sizeof(int) * tSize);</span><br><span class="line">        (*returnColumnSizes)[mask] = tSize;</span><br><span class="line">        ans[mask] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 记录答案</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码中，dfs(cur,n) 参数表示当前位置是 cur，原序列总长度为 n。原序列的每个位置在答案序列中的状态有被选中和不被选中两种，我们用 t 数组存放已经被选出的数字。在进入 dfs(cur,n) 之前 [0,cur−1] 位置的状态是确定的，而 [cur,n−1] 内位置的状态是不确定的，dfs(cur,n) 需要确定 cur 位置的状态，然后求解子问题 dfs(cur+1,n)。对于 cur 位置，我们需要考虑 a[cur] 取或者不取，如果取，我们需要把 a[cur] 放入一个临时的答案数组中（即上面代码中的 t），再执行 dfs(cur+1,n)，执行结束后需要对 t 进行回溯；如果不取，则直接执行 dfs(cur+1,n)。在整个递归调用的过程中，cur 是从小到大递增的，当 cur 增加到 n 的时候，记录答案并终止递归。可以看出二进制枚举的时间复杂度是 O(2 ^ n)。</p><h2 id="62-不同路径（dp）">62.不同路径（dp）</h2><p>一个机器人位于一个 m x n 网格的左上角。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n)&#123;</span><br><span class="line">    int dp[m][n];</span><br><span class="line">    for(int i = 0 ; i&lt; m ; i++)&#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0 ; i&lt; n ; i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =1 ; i&lt;m ; i++)&#123;</span><br><span class="line">        for(int j = 1 ; j&lt;n ; j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II（模拟）">59. 螺旋矩阵 II（模拟）</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 nxn 正方形矩阵 matrix 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;</span><br><span class="line">    int left = 0, right = n-1, top = 0, bottom = n-1;</span><br><span class="line">    int count = 1, target = n * n;</span><br><span class="line">    int** matrix = malloc(sizeof(int*) * n);</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        matrix[i] = malloc(sizeof(int) * n);</span><br><span class="line">        memset(matrix[i], 0, sizeof(int) * n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    while(count &lt;= target)&#123;</span><br><span class="line">            //从左到右填充，相当于缩小上边界</span><br><span class="line">            for(int j = left; j &lt;= right; j++) matrix[top][j] = count++;</span><br><span class="line">            //缩小上边界</span><br><span class="line">            top++;</span><br><span class="line">            //从上向下填充，相当于缩小右边界</span><br><span class="line">            for(int i = top; i &lt;=bottom; i++) matrix[i][right] = count++;</span><br><span class="line">            //缩小右边界</span><br><span class="line">            right--;</span><br><span class="line">            //从右向左填充，相当于缩小下边界</span><br><span class="line">            for(int j = right; j &gt;= left; j--) matrix[bottom][j] = count++;</span><br><span class="line">            //缩小下边界</span><br><span class="line">            bottom--;</span><br><span class="line">            //从下向上填充，相当于缩小左边界</span><br><span class="line">            for(int i = bottom; i &gt;= top; i--) matrix[i][left] = count++;</span><br><span class="line">            //缩小左边界</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    return matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II">92. 反转链表 II</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void reverseLinkedList(struct ListNode *head) &#123;</span><br><span class="line">    // 也可以使用递归反转一个链表</span><br><span class="line">    struct ListNode *pre = NULL;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        struct ListNode *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;</span><br><span class="line">    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span><br><span class="line">    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = -1;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyNode;</span><br><span class="line">    for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *cur = pre-&gt;next;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换（dp）">322. 零钱兑换（dp）</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>题解</strong><br>我们定义一个dp数组，大小 amount+1 ,dp[i]表示整数金额 i 需要dp[i]个银币<br>所以dp[i] = dp[i - coins[j]] + 1 -&gt; 表示当前金额 i 需要 i - coins[j]需要的银币加 1<br>所以遍历整个coins 更新dp[i] 寻找最小的银币数<br>在dp初始化时，我们将其附最大值，如果 dp[i - coins[j]] == 最大值，表示当前金额 i - coins[j] ，在coins中不存在 也保存最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void * a, const void * b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int *)a - *(int *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define MIN(a , b) ((a) &lt; (b) ? (a) : (b))</span><br><span class="line">int coinChange(int* coins, int coinsSize, int amount)&#123;</span><br><span class="line">    qsort(coins, coinsSize, sizeof(coins[0]), cmp);//升序</span><br><span class="line">    int dp[amount + 1];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 1; i &lt;= amount; i++)//遍历dp数组</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = amount + 1;//初始化最大值</span><br><span class="line">        for(int j = 0; j &lt; coinsSize; j++)//动态更新dp[i]</span><br><span class="line">        &#123;</span><br><span class="line">            if(coins[j] &gt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = MIN(dp[i] , dp[i - coins[j]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] == (amount+1) ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串-滑动窗口-hash">76.最小覆盖子串(滑动窗口+hash)</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><ol><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">r</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-跳跃游戏II（贪心）">45.跳跃游戏II（贪心）</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ol><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ol><p>返回到达 nums[n - 1] 的最小跳跃次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int jump(int* nums, int numsSize)&#123;</span><br><span class="line">    int maxPos = 0, end = 0, step = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize - 1; ++i) &#123;</span><br><span class="line">        if (maxPos &gt;= i) &#123;</span><br><span class="line">            maxPos = fmax(maxPos, i + nums[i]);</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列">31. 下一个排列</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ol><li>例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</li><li>类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</li><li>而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li></ol><p>给你一个整数数组 nums ，找出 nums 的下一个排列。必须原地修改，只允许使用额外常数空间。</p><p><strong>题解</strong><br>对于长度为 n 的排列 a：</p><ol><li>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</li><li>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</li><li>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    int t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line">void reverse(int *nums, int left, int right) &#123;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        swap(nums + left, nums + right);</span><br><span class="line">        left++, right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nextPermutation(int *nums, int numsSize) &#123;</span><br><span class="line">    int i = numsSize - 2;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        int j = numsSize - 1;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums + i, nums + j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + 1, numsSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="61-旋转链表（闭合为环）">61. 旋转链表（闭合为环）</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p><strong>题解</strong><br><strong>闭合为环</strong><br>思路及算法：</p><p>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第  (n−1)−(k mod n) 个节点（从 0 开始计数）。</p><p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p><p>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p><p>特别地，当链表长度不大于 1 ，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* rotateRight(struct ListNode* head, int k) &#123;</span><br><span class="line">    if (k == 0 || head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = 1;</span><br><span class="line">    struct ListNode* iter = head;</span><br><span class="line">    while (iter-&gt;next != NULL) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    int add = n - k % n;</span><br><span class="line">    if (add == n) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;next = head;</span><br><span class="line">    while (add--) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* ret = iter-&gt;next;</span><br><span class="line">    iter-&gt;next = NULL;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合（回溯）">77. 组合（回溯）</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int* temp;</span><br><span class="line">int tempSize;</span><br><span class="line"></span><br><span class="line">int** ans;</span><br><span class="line">int ansSize;</span><br><span class="line"></span><br><span class="line">void dfs(int cur, int n, int k) &#123;</span><br><span class="line">    // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span><br><span class="line">    if (tempSize + (n - cur + 1) &lt; k) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录合法的答案</span><br><span class="line">    if (tempSize == k) &#123;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * k);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 考虑选择当前位置</span><br><span class="line">    temp[tempSize++] = cur;</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">    tempSize--;</span><br><span class="line">    // 考虑不选择当前位置</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** combine(int n, int k, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    temp = malloc(sizeof(int) * k);</span><br><span class="line">    ans = malloc(sizeof(int*) * 10001);</span><br><span class="line">    tempSize = ansSize = 0;</span><br><span class="line">    dfs(1, n, k);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * ansSize);</span><br><span class="line">    for (int i = 0; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度-单调栈">739. 每日温度(单调栈)</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:<br>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p><p><strong>题解</strong><br>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p><p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="116-填充每个节点的下一个右侧节点指针（链表）">116. 填充每个节点的下一个右侧节点指针（链表）</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><strong>迭代 使用next指针 两种连接方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从根节点开始</span><br><span class="line">    struct Node* leftmost = root;</span><br><span class="line"></span><br><span class="line">    while (leftmost-&gt;left != NULL) &#123;</span><br><span class="line">        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span><br><span class="line">        struct Node* head = leftmost;</span><br><span class="line"></span><br><span class="line">        while (head != NULL) &#123;</span><br><span class="line">            // CONNECTION 1 连接同一个父节点的两个子节点</span><br><span class="line">            head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line"></span><br><span class="line">            // CONNECTION 2 在不同父亲的子节点之间建立连接</span><br><span class="line">            if (head-&gt;next != NULL) &#123;</span><br><span class="line">                head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 指针向后移动</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 去下一层的最左的节点</span><br><span class="line">        leftmost = leftmost-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归 使用层序遍历和队列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化队列同时将第一层节点加入队列中，即根节点</span><br><span class="line">    struct Node* Q[5000];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    Q[right++] = root;</span><br><span class="line"></span><br><span class="line">    // 外层的 while 循环迭代的是层数</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        // 记录当前队列大小</span><br><span class="line">        int size = right - left;</span><br><span class="line"></span><br><span class="line">        // 遍历这一层的所有节点</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            // 从队首取出元素</span><br><span class="line">            struct Node* node = Q[left++];</span><br><span class="line"></span><br><span class="line">            // 连接</span><br><span class="line">            if (i &lt; size - 1) &#123;</span><br><span class="line">                node-&gt;next = Q[left];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 拓展下一层节点</span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回根节点</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="139-单词拆分（dp）">139. 单词拆分（dp）</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const wordBreak = (s, wordDict) =&gt; &#123;</span><br><span class="line">  const wordSet = new Set(wordDict);</span><br><span class="line">  const len = s.length;</span><br><span class="line">  const dp = new Array(len + 1).fill(false);</span><br><span class="line">  dp[0] = true;</span><br><span class="line"></span><br><span class="line">  for (let i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;    // j去划分成两部分</span><br><span class="line">      const suffix = s.slice(j, i);       // 后缀部分 s[j: i-1]</span><br><span class="line">      if (wordSet.has(suffix) &amp;&amp; dp[j]) &#123; // 后缀部分是单词，且左侧子串[0,j-1]的dp[j]为真</span><br><span class="line">        dp[i] = true;</span><br><span class="line">        break;  // dp[i] = true了，i长度的子串已经可以拆成单词了，不需要j继续划分子串了</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列（双指针-滑动窗口）">567. 字符串的排列（双指针+滑动窗口）</h2><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>初始时，仅统计 s1 ​中的字符，则 cnt 的值均不为正，且元素值之和为<br>−n。</p><p>然后用两个指针 left 和 right 表示考察的区间 [left,right]。right 每向右移动一次，就统计一次进入区间的字符 x。</p><p>为保证 cnt 的值不为正，若此时 cnt[x]&gt;0，则向右移动左指针，减少离开区间的字符的 cnt 值直到 cnt[x]≤0。</p><p>注意到 [left,right] 的长度每增加 1，cnt 的元素值之和就增加 1。当<br>[left,right] 的长度恰好为 n 时，就意味着 cnt 的元素值之和为 0。由于 cnt 的值不为正，元素值之和为 0 就意味着所有元素均为 0，这样我们就找到了一个目标子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool checkInclusion(char* s1, char* s2) &#123;</span><br><span class="line">    int n = strlen(s1), m = strlen(s2);</span><br><span class="line">    if (n &gt; m) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt[26];</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        --cnt[s1[i] - &#x27;a&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">    int left = 0;</span><br><span class="line">    for (int right = 0; right &lt; m; ++right) &#123;</span><br><span class="line">        int x = s2[right] - &#x27;a&#x27;;</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        while (cnt[x] &gt; 0) &#123;</span><br><span class="line">            --cnt[s2[left] - &#x27;a&#x27;];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right - left + 1 == n) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="128-最长连续序列-哈希表-js-set">128. 最长连续序列(哈希表 js:set)</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 +1 ,+2,⋯x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var longestConsecutive = function(nums) &#123;</span><br><span class="line">    let num_set = new Set();</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        num_set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    let longestStreak = 0;</span><br><span class="line">    for (const num of num_set) &#123;</span><br><span class="line">        if (!num_set.has(num - 1)) &#123;</span><br><span class="line">            let currentNum = num;</span><br><span class="line">            let currentStreak = 1;</span><br><span class="line"></span><br><span class="line">            while (num_set.has(currentNum + 1)) &#123;</span><br><span class="line">                currentNum += 1;</span><br><span class="line">                currentStreak += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码">394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure><p>数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。就是逆波兰式那种题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">const decodeString = (s) =&gt; &#123;</span><br><span class="line">    let numStack = [];        // 存倍数的栈</span><br><span class="line">    let strStack = [];        // 存 待拼接的str 的栈</span><br><span class="line">    let num = 0;              // 倍数的“搬运工”</span><br><span class="line">    let result = &#x27;&#x27;;          // 字符串的“搬运工”</span><br><span class="line">    for (const char of s) &#123;   // 逐字符扫描</span><br><span class="line">        if (!isNaN(char)) &#123;   // 遇到数字</span><br><span class="line">            num = num * 10 + Number(char); // 算出倍数</span><br><span class="line">        &#125; else if (char == &#x27;[&#x27;) &#123;  // 遇到 [</span><br><span class="line">            strStack.push(result); // result串入栈</span><br><span class="line">            result = &#x27;&#x27;;           // 入栈后清零</span><br><span class="line">            numStack.push(num);    // 倍数num进入栈等待</span><br><span class="line">            num = 0;               // 入栈后清零</span><br><span class="line">        &#125; else if (char == &#x27;]&#x27;) &#123;  // 遇到 ]，两个栈的栈顶出栈</span><br><span class="line">            let repeatTimes = numStack.pop(); // 获取拷贝次数</span><br><span class="line">            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串</span><br><span class="line">        &#125; else &#123;                   </span><br><span class="line">            result += char;        // 遇到字母，追加给result串</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-两数相除">29. 两数相除</h2><p>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p><p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p><p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p><p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−2^31,  2^31 − 1] 。本题中，如果商 严格大于 2^31 − 1 ，则返回 2^31 − 1 ；如果商 严格小于 -2^31 ，则返回 -2^31 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123; // 被除数 除数</span><br><span class="line">        if(divisor == -1 &amp;&amp; dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE; // 溢出</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if((dividend &gt; 0 &amp;&amp; divisor &lt; 0)||(dividend &lt; 0 &amp;&amp; divisor &gt; 0))</span><br><span class="line">            sign = -1;</span><br><span class="line">       // if(divisor == 1) return dividend;</span><br><span class="line">        // if(divisor == -1) return -dividend;</span><br><span class="line">        int a = dividend&gt;0 ? -dividend : dividend;</span><br><span class="line">        int b = divisor&gt;0 ? -divisor : divisor;</span><br><span class="line">        // 都改为负号是因为int 的范围是[2^31, 2^31-1]，如果a是-2^32，转为正数时将会溢出</span><br><span class="line">        //System.out.println(a + &quot; &quot; + b);</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int ans = div(a,b);</span><br><span class="line">        return sign == -1 ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int div(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int tb = b;</span><br><span class="line">        while(tb+tb &gt;= a &amp;&amp; tb+tb &lt; 0)&#123; // 溢出之后不再小于0</span><br><span class="line">            tb += tb;</span><br><span class="line">            count += count;</span><br><span class="line">            //System.out.println(tb + &quot; &quot; + count + &quot; &quot; + count*b);</span><br><span class="line">        &#125;</span><br><span class="line">        return count+div(a-tb,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-12-矩阵中的路径（回溯-visited使用-）">剑指 Offer 12. 矩阵中的路径（回溯[visited使用]）</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>思路与算法</strong></p><p>设函数 check(i,j,k) 表示判断以网格的 (i,j) 位置出发，能否搜索到单词 word[k…]，其中 word[k…] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。函数 check(i,j,k) 的执行步骤如下：</p><p>如果 board[i][j] =s[k]，当前字符不匹配，直接返回 false。</p><p>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。</p><p>否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 word[k+1…]，则返回 true，否则返回 false。</p><p>这样，我们对每一个位置 (i,j) 都调用函数 check(i,j,0) 进行检查：只要有一处返回 true，就说明网格中能够找到相应的单词，否则说明不能找到。</p><p>为了防止重复遍历相同的位置，需要额外维护一个与 board 等大的 visited 数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var exist = function(board, word) &#123;</span><br><span class="line">    const h = board.length, w = board[0].length;</span><br><span class="line">    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];</span><br><span class="line">    const visited = new Array(h);</span><br><span class="line">    for (let i = 0; i &lt; visited.length; ++i) &#123;</span><br><span class="line">        visited[i] = new Array(w).fill(false);</span><br><span class="line">    &#125;</span><br><span class="line">    const check = (i, j, s, k) =&gt; &#123;</span><br><span class="line">        if (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (k == s.length - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        let result = false;</span><br><span class="line">        for (const [dx, dy] of directions) &#123;</span><br><span class="line">            let newi = i + dx, newj = j + dy;</span><br><span class="line">            if (newi &gt;= 0 &amp;&amp; newi &lt; h &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; w) &#123;</span><br><span class="line">                if (!visited[newi][newj]) &#123;</span><br><span class="line">                    const flag = check(newi, newj, s, k + 1);</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        result = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; h; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; w; j++) &#123;</span><br><span class="line">            const flag = check(i, j, word, 0);</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void backtrace(char** rec , int * recSize, int* vis, char * s , int i , int n , char* perm)&#123;</span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        char* tmp = malloc(sizeof(char) * (n+1));</span><br><span class="line">        strcpy(tmp,perm);</span><br><span class="line">        rec[(*recSize)++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=0 ; j&lt;n ; j++)&#123;</span><br><span class="line">        if(vis[j] || (j&gt;0&amp;&amp;!vis[j-1]&amp;&amp;s[j-1]==s[j]))&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[j] = true;</span><br><span class="line">        perm[i] = s[j];</span><br><span class="line">        backtrace(rec, recSize, vis, s, i + 1, n, perm);</span><br><span class="line">        vis[j] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(char* a,char *b)&#123;</span><br><span class="line">    return *a-*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char** permutation(char* s, int* returnSize)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    int recMaxSize = 1;</span><br><span class="line">    for(int i =2 ; i&lt;=n ; i++)&#123;</span><br><span class="line">        recMaxSize*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    char **rec = malloc(sizeof(char*)*recMaxSize);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int vis[n];</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    char perm[n+1];</span><br><span class="line">    perm[n] = &#x27;\0&#x27;;</span><br><span class="line">    qsort(s,n,sizeof(char),cmp);</span><br><span class="line">    backtrace(rec, returnSize, vis, s, 0, n, perm);</span><br><span class="line">    return rec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-51-数组中的逆序对-归并排序">剑指 Offer 51. 数组中的逆序对(归并排序)</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>merge_sort() 归并排序与逆序对统计：</p><ol><li><p>终止条件： 当 l≥r 时，代表子数组长度为 1 ，此时终止划分；</p></li><li><p>递归划分： 计算数组中点 m ，递归划分左子数组 merge_sort(l, m) 和右子数组 merge_sort(m + 1, r);</p></li><li><p>合并与逆序对统计：</p><ol><li>暂存数组 nums 闭区间 [i,r] 内的元素至辅助数组 tmp ；</li><li>循环合并： 设置双指针 i , j 分别指向左 / 右子数组的首元素；<ol><li>当 i=m+1 时： 代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j=j+1 ；</li><li>否则，当 j=r+1 时： 代表右子数组已合并完，因此添加左子数组当前元素 tmp[i] ，并执行 i=i+1 ；</li><li>否则，当 tmp[i]≤tmp[j] 时： 添加左子数组当前元素 tmp[i] ，并执行 i=i+1；</li><li>否则（即 tmp[i]&gt;tmp[j]）时： 添加右子数组当前元素 tmp[j] ，并执行 j=j+1 ；此时构成 m−i+1 个「逆序对」，统计添加至 res ；</li></ol></li></ol></li><li><p>返回值： 返回直至目前的逆序对总数 res ；</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int mergeSort(int l, int r , int* nums, int* tmp)&#123;</span><br><span class="line">     // 终止条件</span><br><span class="line">    if(l&gt;=r) return 0;</span><br><span class="line">     // 递归划分</span><br><span class="line">    int m = (l+r)/2;</span><br><span class="line">    int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp);</span><br><span class="line">     // 合并阶段</span><br><span class="line">    int i = l, j = m + 1;</span><br><span class="line">        for (int k = l; k &lt;= r; k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            if (i == m + 1)</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            else if (j == r + 1 || tmp[i] &lt;= tmp[j])</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            else &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += m - i + 1; // 统计逆序对</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int reversePairs(int* nums, int numsSize)&#123;</span><br><span class="line">    int * tmp = malloc(sizeof(int) * numsSize);</span><br><span class="line">    return mergeSort(0,numsSize-1,nums,tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    struct TreeNode* ancestor = root;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;left;</span><br><span class="line">        &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先">剑指 Offer 68 - II. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    /* 当前节点为p、q、NULL都返回本身即可 */</span><br><span class="line">    if (root == q || root == p || !root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 递归处理左子树 */</span><br><span class="line">    struct TreeNode* left  = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    /* 递归处理右子树 */</span><br><span class="line">    struct TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    /* 处理当前根节点 */</span><br><span class="line">    /* 当前节点左右子树均不为NULL，则找到公共祖先 */</span><br><span class="line">    if (left != NULL &amp;&amp; right != NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left == NULL &amp;&amp; right != NULL) &#123;    /* 左子树未发现p、q、右子树发现p、q */</span><br><span class="line">        return right;</span><br><span class="line">    &#125; else if (left != NULL &amp;&amp; right == NULL) &#123; /* 右子树未发现p、q、左子树发现p、q */</span><br><span class="line">        return left;</span><br><span class="line">    &#125; else  &#123;   /* 左、右子树均未发现p、q */</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1019-链表中的下一个更大节点-单调栈">1019. 链表中的下一个更大节点(单调栈)</h2><p>给定一个长度为 n 的链表 head</p><p>对于列表中的每个节点，查找下一个 更大节点 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。</p><p>返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextLargerNodes = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> idx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        ++idx;</span><br><span class="line">        ans.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; stack[stack.<span class="property">length</span> - <span class="number">1</span>][<span class="number">0</span>] &lt; cur.<span class="property">val</span>) &#123;</span><br><span class="line">            ans[stack.<span class="title function_">pop</span>()[<span class="number">1</span>]] = cur.<span class="property">val</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">push</span>([cur.<span class="property">val</span>, idx]);</span><br><span class="line">        cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1388-3n-块披萨-dp">1388. 3n 块披萨(dp)</h2><p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p><p>你挑选<strong>任意</strong>一块披萨。<br>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。<br>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。<br>重复上述过程直到没有披萨剩下。<br>每一块披萨的大小按顺时针方向由循环数组 slices 表示。</p><p>请你返回你可以获得的披萨大小总和的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [1,2,3,4,5,6]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>本题可以转化成如下问题：</p><ul><li>给一个长度为 3n 的环状序列，你可以在其中选择 n 个数，并且任意两个数不能相邻，求这 n 个数的最大值。</li></ul><p>用 dp[i][j] 表示在前 i 个数中选择了 j 个不相邻的数的最大和:</p><ol><li>当 i&lt;2 或 j=0 时:<ul><li>当 j = 0 , dp = 0;</li><li>当 i = 0, j = 1, dp = slices[0];</li><li>当 i = 1, j = 1, dp = max(slices[0], slices[1]);</li><li>当 i &lt; 2, j &gt;= 2, dp = -∞;</li></ul></li><li>当 i≥2 且 j&gt;0 时:<ul><li>dp[i][j]=max(dp[i−2][j−1]+slices[i],dp[i−1][j]);</li></ul></li></ol><p>环状序列相较于普通序列，相当于添加了一个限制：普通序列中的第一个和最后一个数不能同时选。这样一来，我们只需要对普通序列进行两遍动态即可得到答案，第一遍动态规划中我们删去普通序列中的第一个数，表示我们不会选第一个数；第二遍动态规划中我们删去普通序列中的最后一个数，表示我们不会选最后一个数。将这两遍动态规划得到的结果去较大值，即为在环状序列上的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = slices.<span class="built_in">size</span>(), n = (N + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MIN));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = slices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(slices[<span class="number">0</span>], slices[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">2</span>][j - <span class="number">1</span>] + slices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N - <span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSizeSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(slices.begin() + <span class="number">1</span>, slices.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(slices.begin(), slices.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans1 = <span class="built_in">calculate</span>(v1);</span><br><span class="line">        <span class="type">int</span> ans2 = <span class="built_in">calculate</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2512-奖励最顶尖的-K-名学生-哈希">2512. 奖励最顶尖的 K 名学生(哈希)</h2><p>给你两个字符串数组 <code>positive_feedback</code> 和 <code>negative_feedback</code> ，分别包含表示正面的和负面的词汇。<strong>不会</strong>有单词同时是正面的和负面的。</p><p>一开始，每位学生分数为 0 。每个正面的单词会给学生的分数<strong>加</strong> 3 分，每个负面的词会给学生的分数<strong>减</strong>  1 分。</p><p>给你 n 个学生的评语，用一个下标从 0 开始的字符串数组 <code>report</code> 和一个下标从 0 开始的整数数组 <code>student_id </code>表示，其中 <code>student_id[i]</code> 表示这名学生的 ID ，这名学生的评语是 <code>report[i]</code> 。每名学生的 ID<strong>互不相同</strong>。</p><p>给你一个整数 k ，请你返回按照得分<strong>从高到低</strong>最顶尖的 k 名学生。如果有多名学生分数相同，ID 越小排名越前。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：</span><br><span class="line">两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topStudents</span><span class="params">(vector&lt;string&gt;&amp; positive_feedback, vector&lt;string&gt;&amp; negative_feedback, vector&lt;string&gt;&amp; report, vector&lt;<span class="type">int</span>&gt;&amp; student_id, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;std::string, <span class="type">int</span>&gt; words;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : positive_feedback) &#123;</span><br><span class="line">            words[word] = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : negative_feedback) &#123;</span><br><span class="line">            words[word] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; report.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            stringstream ss; <span class="comment">//stream根据空格分词</span></span><br><span class="line">            string w;</span><br><span class="line">            <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">            ss &lt;&lt; report[i];</span><br><span class="line">            <span class="keyword">while</span> (ss &gt;&gt; w) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words.<span class="built_in">count</span>(w)) &#123;</span><br><span class="line">                    score += words[w];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            A.<span class="built_in">push_back</span>(&#123;-score, student_id[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; top_k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            top_k.<span class="built_in">push_back</span>(A[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8026-构造乘积矩阵">8026. 构造乘积矩阵</h2><p>给你一个下标从 0 开始、大小为 n * m 的二维整数矩阵 grid ，定义一个下标从 0 开始、大小为 n * m 的的二维矩阵 p。如果满足以下条件，则称 p 为 grid 的 乘积矩阵 ：</p><p>对于每个元素 p[i][j] ，它的值等于除了 grid[i][j] 外所有元素的乘积。乘积对 12345 取余数。<br>返回 grid 的乘积矩阵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2],[3,4]]</span><br><span class="line">输出：[[24,12],[8,6]]</span><br><span class="line">解释：p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24</span><br><span class="line">p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12</span><br><span class="line">p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8</span><br><span class="line">p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6</span><br><span class="line">所以答案是 [[24,12],[8,6]] 。</span><br><span class="line"></span><br><span class="line">1 &lt;= n == grid.length &lt;= 105</span><br><span class="line">1 &lt;= m == grid[i].length &lt;= 105</span><br><span class="line">2 &lt;= n * m &lt;= 105</span><br><span class="line">1 &lt;= grid[i][j] &lt;= 109</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; constructProductMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">        const int MOD = 12345;</span><br><span class="line">        int n = grid.size(), m = grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; p(n, vector&lt;int&gt;(m));</span><br><span class="line"></span><br><span class="line">        long long suf = 1; // 后缀乘积</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            for (int j = m - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                p[i][j] = suf; // p[i][j] 先初始化成后缀乘积</span><br><span class="line">                suf = suf * grid[i][j] % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long long pre = 1; // 前缀乘积</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                p[i][j] = p[i][j] * pre % MOD; // 然后再乘上前缀乘积</span><br><span class="line">                pre = pre * grid[i][j] % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2530-执行-K-次操作后的最大分数-优先队列">2530. 执行 K 次操作后的最大分数 (优先队列)</h2><p>给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。</p><p>在一步 操作 中：</p><p>选出一个满足 0 &lt;= i &lt; nums.length 的下标 i ，<br>将你的 分数 增加 nums[i] ，并且<br>将 nums[i] 替换为 ceil(nums[i] / 3) 。<br>返回在 恰好 执行 k 次操作后，你可能获得的最大分数。</p><p>向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,10,10,10,10], k = 5</span><br><span class="line">输出：50</span><br><span class="line">解释：对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxKelements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">0</span>; _ &lt; k; ++_) &#123;</span><br><span class="line">            <span class="type">int</span> x = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans += x;</span><br><span class="line">            q.<span class="built_in">push</span>((x + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; size; k = <span class="number">2</span> * k + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 父节点 (k - 1) / 2，左子节点 k，右子节点 k + 1</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; size &amp;&amp; nums[k] &lt; nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &lt; nums[(k - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, k, (k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        down(nums, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    nums[size] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt; <span class="number">0</span> &amp;&amp; nums[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; nums[i]; i = (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        swap(nums, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    swap(nums, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">    down(nums, size - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nums[size - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">maxKelements</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Init(nums, numsSize);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = Pop(nums, numsSize);</span><br><span class="line">        ans += x;</span><br><span class="line">        Push(nums, numsSize - <span class="number">1</span>, (x + <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2316-统计无向图中无法互相到达点对数-并查集-or-DFS">2316. 统计无向图中无法互相到达点对数(并查集 or DFS)</h2><p>给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。</p><p>请你返回 无法互相到达 的不同 点对数目 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]</span><br><span class="line">输出：14</span><br><span class="line">解释：总共有 14 个点对互相无法到达：</span><br><span class="line">[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]</span><br><span class="line">所以我们返回 14 。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int dfs(int x ,vector&lt;bool&gt;&amp; visited,vector&lt;vector&lt;int&gt;&gt;&amp; graph)&#123;</span><br><span class="line">        visited[x] = true;</span><br><span class="line">        long long count = 1;</span><br><span class="line">        for(int y : graph[x])&#123;</span><br><span class="line">            if (!visited[y]) &#123;</span><br><span class="line">                count += dfs(y,visited,graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; graph(n);</span><br><span class="line">        for (const auto &amp;edge : edges) &#123;</span><br><span class="line">            int  x = edge[0], y = edge[1];</span><br><span class="line">            graph[x].emplace_back(y);</span><br><span class="line">            graph[y].emplace_back(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;bool&gt; visited(n,false);</span><br><span class="line"></span><br><span class="line">        long long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if(!visited[i])&#123;</span><br><span class="line">                long long count = dfs(i,visited,graph);</span><br><span class="line">                res += count * (n - count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class UnionFind &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; parents;</span><br><span class="line">    vector&lt;int&gt; sizes;</span><br><span class="line">public:</span><br><span class="line">    UnionFind(int n) : parents(n), sizes(n, 1) &#123;</span><br><span class="line">        iota(parents.begin(), parents.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">    int Find(int x) &#123;</span><br><span class="line">        if (parents[x] == x) &#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">        return parents[x] = Find(parents[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    void Union(int x, int y) &#123;</span><br><span class="line">        int rx = Find(x), ry = Find(y);</span><br><span class="line">        if (rx != ry) &#123;</span><br><span class="line">            if (sizes[rx] &gt; sizes[ry]) &#123;</span><br><span class="line">                parents[ry] = rx;</span><br><span class="line">                sizes[rx] += sizes[ry];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                parents[rx] = ry;</span><br><span class="line">                sizes[ry] += sizes[rx];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int GetSize(int x) &#123;</span><br><span class="line">        return sizes[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    long long countPairs(int n, vector&lt;vector&lt;int&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        UnionFind uf(n);</span><br><span class="line">        for (const auto &amp;edge : edges) &#123;</span><br><span class="line">            uf.Union(edge[0], edge[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        long long res = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            res += n - uf.GetSize(uf.Find(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="146-LRU-缓存-哈希表-双向链表">146. LRU 缓存(哈希表+双向链表)</h2><p>请你设计并实现一个满足  <strong>LRU (最近最少使用)</strong> 缓存 约束的数据结构。<br>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以<strong>正整数</strong>作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 逐出 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以<code>O(1)</code>的平均时间复杂度运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="421-数组中两个数的最大异或值-字典树-前缀树">421. 数组中两个数的最大异或值(字典树/前缀树)</h2><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">struct Trie &#123;</span><br><span class="line">    // 左子树指向表示 0 的子节点</span><br><span class="line">    Trie* left = nullptr;</span><br><span class="line">    // 右子树指向表示 1 的子节点</span><br><span class="line">    Trie* right = nullptr;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    // 字典树的根节点</span><br><span class="line">    Trie* root = new Trie();</span><br><span class="line">    // 最高位的二进制位编号为 30</span><br><span class="line">    static constexpr int HIGH_BIT = 30;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void add(int num) &#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                if (!cur-&gt;left) &#123;</span><br><span class="line">                    cur-&gt;left = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                if (!cur-&gt;right) &#123;</span><br><span class="line">                    cur-&gt;right = new Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int check(int num) &#123;</span><br><span class="line">        Trie* cur = root;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int k = HIGH_BIT; k &gt;= 0; --k) &#123;</span><br><span class="line">            int bit = (num &gt;&gt; k) &amp; 1;</span><br><span class="line">            if (bit == 0) &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走</span><br><span class="line">                if (cur-&gt;right) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走</span><br><span class="line">                if (cur-&gt;left) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                    x = x * 2 + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    x = x * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中</span><br><span class="line">            add(nums[i - 1]);</span><br><span class="line">            // 将 nums[i] 看作 ai，找出最大的 x 更新答案</span><br><span class="line">            x = max(x, check(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022总结</title>
      <link href="/post/20bbe8e4.html"/>
      <url>/post/20bbe8e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下">回顾一下</h2><p>从8月份开始博客就停摆了，期间一直在图书馆准备考研，结果在考前两天又阳了，发挥的很一般，只能说今年是有那么一点不顺利了。<br>回顾整个2022，感觉还是不太满意的，很多自己想学的想干的都因为种种原因而搁浅，从去年12月到上半年的4月份，自己其实是没有读研的想法的，一直想着找份工作先干几年再考虑读研的问题。而这个计划胎死腹中则是因为在腾讯面试的过程中根本没有给我去总部的机会，而是直接将我的简历分到了腾讯云那边，我自己又有点眼高手低，觉得还是读个研究生再来找工作可能会好一点随后就放弃了找工作的计划(现在想想还是有那么一点后悔，毕竟2年后的形式可能会更差，春招也得搏一搏了)<br>2022感觉自己没有做成什么事情，最后的初试也不知道能不能通过，只是在整个2022种下了一系列的因，希望在2023能结一些好的果吧。</p><h2 id="展望一下">展望一下</h2><p>2023当然最想的就是上岸了，说实话想一想科软的培养方案，我就很心动，如果今年失利，后面肯定还会继续尝试。然后呢，则是给自己再定几个目标：一个是先把力扣刷明白，明年至少做500题吧；二是把开发搞明白，然后再学一点高并发和图形学的东西，都是我很感兴趣但是因为各种原因搁置的知识；三是过的轻松点吧，指的是心态上，别逼自己太紧了，感觉最后这一个月保持的就还不错，虽然临近考研，还有毕设开题，阳了，胃病，莫名其妙头晕等一系列乱七八糟的东西，但是心态一直不错，希望2023不顺的事少一点，心态也放平一点。</p><h2 id="总结一下">总结一下</h2><p>最后，还是想感谢家人朋友和同学吧，生活为啥是生活，就来源于身边人的力量吧，谢谢大家，希望2023大家都越来越好。</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http的8种请求方法</title>
      <link href="/post/1e0e1e64.html"/>
      <url>/post/1e0e1e64.html</url>
      
        <content type="html"><![CDATA[<h2 id="http方法">http方法</h2><p><strong>8种：GET、HEAD、POST、PUT、DELETE、OPTIONS、TRACE、PATCH</strong><br>根据RFC2616第九章说明，http方法的定义有两点：safe and Idempotent，即安全性和幂等性，可以结合这两点对以上方法进行说明。</p><h2 id="详细说明">详细说明</h2><h3 id="GET">GET</h3><p>特点：安全、幂等。<br>说明：从服务器端获取数据，请求body在地址栏上。<br>作用：获取资源。</p><h3 id="HEAD">HEAD</h3><p>特点：安全、幂等。<br>说明：与get方法类似，但不返回message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）。<br>作用：restful框架中较少使用。</p><h3 id="POST">POST</h3><p>特点：非安全、非幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据要重新新创建。<br>作用：用于创建子资源。创建、更新、删除、查询资源均可使用。</p><h3 id="PUT">PUT</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据更新（全部更新）。<br>作用：用于创建、更新资源。</p><h3 id="DELETE">DELETE</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个删除数据的请求。<br>作用：删除资源。</p><h3 id="OPTIONS">OPTIONS</h3><p>特点：安全、幂等。<br>作用：用于url验证，验证接口服务是否正常。</p><h3 id="TRACE">TRACE</h3><p>特点：安全、幂等。<br>说明：维基百科“回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现。”<br>作用：restful框架中较少使用。</p><h3 id="PATCH">PATCH</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>与PUT类似，发送一个修改数据的请求，区别在于PATCH代表部分更新；<br>后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；<br>作用：用于创建、更新资源。局部更新，比如：user对象，只更改了name属性，那么他的其他属性值是不会变的，如果用post，那么其他属性值会被设置为null（全局更新）</p><h2 id="幂等性">幂等性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</span><br><span class="line">比如:GET http://www.bank.com/account/123456,不会改变资源的状态，不论调用一次还是N次都没有副作用。</span><br><span class="line">请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</span><br><span class="line">GET http://www.news.com/latestnews这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</span><br><span class="line"></span><br><span class="line">HTTP DELETE方法用于删除资源，有副作用,但它应该满足幂等性。比如: DELETE http://www.forum.com/article/4231,</span><br><span class="line">调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子;因此，调用者可以多次调用或刷新页面而不必担心引起错误。</span><br><span class="line"></span><br><span class="line">重点来了：比较容易混淆的是HTTP的 POST和PUT。POST和PUT的区别容易被简单地误认为&quot;POST表示创建资源，PUT表示更新资源”;</span><br><span class="line">而实际上,二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的:</span><br><span class="line">POST所对应的URI并非创建的资源本身，而是资源的接收者。</span><br><span class="line">比如: POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。</span><br><span class="line">两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI; 所以，POST方法不具备幂等性。</span><br><span class="line">而PUT所对应的URI是要创建或更新的资源本身。</span><br><span class="line">比如: PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。</span><br><span class="line">对同一URI进行多次PUT的副作用和一次PUT是相同的;因比，PUT方法具有幕等性。</span><br><span class="line"></span><br><span class="line">在介绍了几种操作的语义和幂等性之后,我们来看看如何通过Web API的形式实现前面所提到的取款功能。</span><br><span class="line">很简单，POST /tickets来实现create_ticket;用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent _withdraw。</span><br><span class="line">值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_ id/ticket_id,而amount应该放在请求的body中。</span><br><span class="line">这种模式可以应用于很多场合，比如:论坛网站中防止意外的重复发帖。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extra-bbs开发项目</title>
      <link href="/post/9a9a747.html"/>
      <url>/post/9a9a747.html</url>
      
        <content type="html"><![CDATA[<h3 id="项目总述">项目总述</h3><p>一个社区论坛形式的项目，有点类似贴吧，知乎。分为web应用前端live，后端sever以及后台管理系统admin。<br><img src="img/extrabbs.png" alt="extra_bbs"></p><h3 id="前端">前端</h3><blockquote><p>前端技术栈</p></blockquote><p><code>vue</code> <code>vuex</code> <code>vue-router</code></p><p>其中也涉及到一些依赖，比如sweetalert等等<br>repository: <a href="https://github.com/V1per3/Extra-BBS-live">https://github.com/V1per3/Extra-BBS-live</a></p><h4 id="构建步骤">构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="后端">后端</h3><blockquote><p>技术栈</p></blockquote><p><code>node</code> + <code>koa2</code> + <code>koa-router</code> + <code>ES6</code> + <code>mysql</code> + <code>mongodb</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-server">https://github.com/V1per3/Extra-BBS-server</a></p><h4 id="工程结构">工程结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">└── PPAP.server</span><br><span class="line">    ├── config <span class="comment"># 配置文件</span></span><br><span class="line">    │   └── index.js  </span><br><span class="line">    ├── controller <span class="comment"># 操作层 验证视图层用户输入，调用业务层方法，json接口返回数据</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── model <span class="comment"># 数据模型层 执行数据操作</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── router <span class="comment"># 路由层 控制路由</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── service <span class="comment"># 业务层 操作数据层，对业务逻辑进行处理，将结果返回控制层</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── sql <span class="comment"># 数据表sql</span></span><br><span class="line">    │   └── init.sql</span><br><span class="line">    ├── util <span class="comment"># 工具函数</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── app.js <span class="comment"># 入口文件</span></span><br><span class="line">    ├── package.json </span><br><span class="line">    ├── README.md</span><br><span class="line">    └── yarn.lock</span><br></pre></td></tr></table></figure><h4 id="构建步骤-2">构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><h3 id="后台管理系统">后台管理系统</h3><blockquote><p>技术栈</p></blockquote><p><code>react</code> + <code>ant-design UI</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-admin">https://github.com/V1per3/Extra-BBS-admin</a></p><h4 id="构建步骤-3">构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 线性表</title>
      <link href="/post/aeec3311.html"/>
      <url>/post/aeec3311.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性表的定义与基本操作">线性表的定义与基本操作</h2><h3 id="线性表的定义">线性表的定义</h3><ol><li>线性表是具有<strong>相同</strong>数据类型的n(n&gt;=0)个数据元素的<strong>有限序列</strong>，其中n为表长，当n=0时线性表是一个空表。</li><li>若用L命名线性表，则其一般表示为L=(a1,a2,…,ai,ai+1,…an)</li><li>表达式中a1是唯一<strong>第一个</strong>数据元素，又称为表头元素；an是唯一的<strong>最后一个</strong>数据元素，又称为表尾元素。</li><li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后驱。<br><strong>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆</strong></li></ol><h3 id="线性表的基本操作">线性表的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L): 初始化表。构造一个空的线性表。</span><br><span class="line">Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定元素e。</span><br><span class="line">ListDelete(&amp;L,i,&amp;e): 删除操作。删除表中L中第i个位置的元素，并用e返回删除的元素。</span><br><span class="line">PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</span><br><span class="line">DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><p><strong>注意：基本操作的具体实现取决于采用哪种存储结构（见下图）,存储结构不同，算法的实现也不同.&quot;&amp;&quot;表示C++语言中的引用调用,在c语言中采用指针也可以达到相同的效果.后续文章中两种方式都会使用.</strong></p><p><img src="/img/sujgxxb1.png" alt=""></p><h2 id="顺序表">顺序表</h2><h3 id="顺序表的定义">顺序表的定义</h3><p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p><p>假定线性表的元素类型为ElemType,则线性表的顺序存储类型描述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 10  //定义顺序表的最大长度，在声明数组时使用</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];//顺序表的数据元素</span><br><span class="line">    int length;//顺序表的当前长度</span><br><span class="line">&#125;Sqlist;//顺序表的类型定义</span><br></pre></td></tr></table></figure><p>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定好，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序奔溃甚至引起其他未知异常。</p><p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦存储空间占满，就另外开辟一块更大的存储区间，将原来的元素复制过去，从而达到扩充存储数组空间的目的，而不需要一次性分配很大的空间。<br>C语言的初始动态分配语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure><p>C++语言的初始化动态分配语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data=new ElemType[InitSize];</span><br></pre></td></tr></table></figure><p><strong>注意：动态存储并不是链式存储，它同样属于顺序存储，物理结构没有变化，还是和逻辑结构一样保持相邻，只是分配的空间不再是编译器决定，而是运行时分配。</strong></p><h3 id="顺序表的特点">顺序表的特点</h3><p>随机访问：可通过首地址和元素序号在单位时间O(1)内找到指定的元素。</p><p>存储密度高：存储密度高是因为每个结点存储空间指用来存储数据元素，没有别的额外开销。</p><p>物理位置相邻：物理位置和逻辑位置一样，保持相邻，因此插入和删除元素需要移动大量元素，比较耗时。这是物理结构相邻的所有数据结构的通病，虽然访问快，但是如果有频繁的增删移动操作，就会效率很低。</p><h3 id="顺序表上的基本操作">顺序表上的基本操作</h3><p>仅展示查、增、删三种操作，其余的在线性表中较为简单，在后续更复杂的链表中展示。</p><h4 id="插入操作">插入操作</h4><p>在顺序表L的第i（1&lt;=i&lt;=L.length+1）位插入新元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length + 1)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    if (L.length &gt;= MaxSize)   //判断是否超出存储空间</span><br><span class="line">        return false;</span><br><span class="line">    for (int j = L.length; j &gt;= i; j--)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j - 1];</span><br><span class="line">    L.data[i - 1] = e;   //在第i位插入元素e</span><br><span class="line">    L.length++;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：在表尾插入（即i=n+1）,原本的元素不移动，时间复杂度为O(1)。</p><p>最坏情况：在表头插入（即i=1），所有元素需要后移一位，元素后移语句执行n次，时间复杂度为O(n)。</p><p>平均情况：假设Pi(Pi=1/(n+1))是在第i个位置上插入一个结点的概率，则在长度为n的顺序表中插入一个结点时，所需要移动结点的平均次数为n/2，时间复杂度为O(n)。</p><h4 id="删除操作">删除操作</h4><p>删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    e = L.data[i - 1];     //保存要删除的数据到e</span><br><span class="line">    for (int j = i-1; j &lt;= L.length; ++j)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j + 1];</span><br><span class="line">    L.length--;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度与插入一样（平均时间复杂度上，插入始终每一步比删除多一次操作，即插入操作，但是不会引起量级变化，所以平均时间复杂度依旧为O(N)）</p><h4 id="按值查找（顺序查找）操作">按值查找（顺序查找）操作</h4><p>在顺序表中查找第一个元素值等于e的元素的位置，未查找到返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L,const ElemType &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; L.length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if (L.data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：在表头找到（即i=1）,时间复杂度为O(1)。</p><p>最坏情况：在表尾插入（即i=n），时间复杂度为O(n)。</p><p>平均情况：时间复杂度为O(n)。</p><h2 id="线性表的链式表示">线性表的链式表示</h2><p>逻辑上相邻的元素在物理位置上不一定相邻。<br>优点：</p><ol><li>没有了顺序存储所具有的弱点（也就是说：插入和删除不需要移动元素，而只需要修改指针。）</li><li>同时，由于不借助数组实现，在定义链表时，无需指定它的长度。</li></ol><p>缺点：<br>也失去了顺序存储的优点</p><ol><li>非随机存取（不能直接找到某个特定序号的结点，需要从表头开始遍历）</li><li>存储密度降低（除了存储本身信息外链表还要存储指针）</li></ol><h3 id="单链表的定义">单链表的定义</h3><p>线性表的链式存储又称为单链表，它是指通过一组任意的存储单位来存储线性表中的元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素的自身信息外，还需要存放一个指向其后继的指针。</p><p>由于逻辑上相邻的元素在物理位置上不一定相邻，那么我们如何确定下一个元素的存储位置呢？<br><strong>解决办法，增加一个变量。用来存储一个指示其后继位置的指针。</strong><br>我们把这两部分的信息组成数据元素a的存储映像，称为<strong>结点</strong>。它包含两个域，其中存储数据元素信息的域称为<strong>数据域</strong>，存储直接后继存储位置的域称为<strong>指针域</strong>。</p><p>单链表中结点定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123; //定义单链表节点类型</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct LNode *next;//指针域</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>头指针</strong><br>整个链表的存储<strong>必须从头指针开始</strong><br>头指针指示链表中第一个结点的存储位置<br>同时，由于最后一个数据元素没有直接后继，则单链表中最后一个一个结点的指针为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//头指针定义1</span><br><span class="line">LinkList L;</span><br><span class="line">//头指针定义2</span><br><span class="line">LNode *L;</span><br></pre></td></tr></table></figure><p><strong>头结点</strong><br>在单链表的第一个结点之前附设一个结点，称为头结点。<br>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度之类的附加信息。<br>头结点的指向第一个结点的指针（即第一个元素结点的存储位置）<br>此时，单链表的头指针指向头结点。<br><img src="/img/sujgxxb2.png" alt=""></p><p><strong>空表</strong><br>含头结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L-&gt;next==NULL时为空表</span><br></pre></td></tr></table></figure><p>不含头结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L==NULL时为空表；</span><br></pre></td></tr></table></figure><h3 id="单链表上具体操作的实现和时间复杂度">单链表上具体操作的实现和时间复杂度</h3><h4 id="初始化表">初始化表</h4><p>构造一个空表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int InitList_Link(LinkList *L)&#123;</span><br><span class="line">    *L=(LinkList)malloc(sizeof(LNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(1)</span><br></pre></td></tr></table></figure><h4 id="根据数组创建单链表">根据数组创建单链表</h4><h5 id="含头结点的单链表">含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点指向第一个结点</span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        r=s;//r移动到链表尾端</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不含头结点的单链表">不含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line">    *L=NULL;</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            *L=s;//头指针指向插入结点</span><br><span class="line">            s-&gt;next=NULL;//倒序插入，最后一个结点的指针域赋值为NULL</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            s-&gt;next=*(L);//新插入的结点指向第一个结点</span><br><span class="line">            *(L)=s;//头指针指向新的插入节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    (*L)=NULL;</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            (*L)=s;//头指针指向第一个结点</span><br><span class="line">            r=s;//尾指针移动到最后一个结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">            r=s;//r移动到链表尾端</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-5">总结</h5><p>含头结点优点：</p><ol><li>使得链表第一个结点的操作和其他位置一样，无需特殊处理。</li></ol><p>含头结点缺点：</p><ol><li>头结点的数据域一般不存储数据，该空间被浪费。</li></ol><p>时间复杂度：</p><ol><li>每个结点插入的时间为O(1),设表长为n，所有方式的时间复杂度均为O(n)</li></ol><h4 id="求表长">求表长</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Length_Link(LinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        L=L-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：设表长为n,时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="插入操作-2">插入操作</h4><p>在表L中的第i个位置上插入指定元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert_Link(LinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="删除操作-2">删除操作</h4><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete_Link(LinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="按位查找操作">按位查找操作</h4><p>获取表L中第i个位置的元素的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int GetElem_List(LinkList L,int i,ElemType *e)&#123;</span><br><span class="line">    LNode *p=L; //p指向头结点</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (p&amp;&amp;j&lt;i)&#123;//找到第i个位置</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(p)||i&lt;1)  return FALSE; //i不在有效范围内</span><br><span class="line">    *e=p-&gt;data; //把第i个结点的值用e返回</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="按值查找操作">按值查找操作</h4><p>在表L中查找具有给定关键字值的元素,返回序号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_List(LinkList L,ElemType e,int *i)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历链表</span><br><span class="line">        L=L-&gt;next;//向后移动</span><br><span class="line">        j++;//序号加一</span><br><span class="line">        if (L-&gt;data.id==e.id)&#123;//这里我们只用id来判断元素的值是否相等，假设id唯一</span><br><span class="line">            *i=j;//如果相等，用i返回序号</span><br><span class="line">            return TRUE;//查找成功</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="销毁表">销毁表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(LinkList *L)&#123;</span><br><span class="line">    while((*L)-&gt;next!=NULL) &#123;//遍历链表</span><br><span class="line">    LNode *p=(*L)-&gt;next;//p指示头结点的下一个，要被删除的结点</span><br><span class="line">    (*L)-&gt;next=p-&gt;next;//让头结点指向p的下一个，把p从链表断开</span><br><span class="line">    free(p);//删除p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><p>单链表结点中只有一个指向其后继结点的指针，使得单链表只能从头结点依次顺序地向后遍历。<br>要访问某个结点的前驱结点，只能从头开始遍历。<br>也就是说：访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)</p><p><strong>为了克服单链表的上述缺点，引入了双链表。</strong><br><strong>双链表中有两个指针prior和next，分别指向其前驱结点和后继结点</strong></p><h4 id="双链表的定义">双链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DNode&#123;</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct DNode *prior;//前驱指针</span><br><span class="line">    struct DNode *next;//后继指针</span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure><p><img src="/img/sujgxxb3.png" alt=""></p><h4 id="双链表上具体操作的实现和时间复杂度">双链表上具体操作的实现和时间复杂度</h4><p>使用含头结点的双链表</p><h5 id="初始化表-2">初始化表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitList_DLink(DLinkList *L)&#123;</span><br><span class="line">    *L=(DLinkList)malloc(sizeof(DNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;prior=NULL;//头结点的prior永远指向NULL</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(1)</span><br></pre></td></tr></table></figure><h5 id="根据数组创建双链表">根据数组创建双链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*头插法创建双链表*/</span><br><span class="line">int create_HeadInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于D头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点的后继指向第一个结点</span><br><span class="line">        if((*L)-&gt;next!=NULL) (*L)-&gt;next-&gt;prior=s;//第一个结点的前驱指向该结点</span><br><span class="line">        s-&gt;prior=(*L);//让该结点的前驱指向头结点   </span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该D结点（该结点成为第一个结点）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*尾插法创建双链表*/</span><br><span class="line">int create_TailInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        s-&gt;prior=r;//该结点的前驱指向r指向的结点</span><br><span class="line">        r=s;//r移动到链表尾端o</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每个结点插入的时间为O(1),设表长为n,所有方式的时间复杂度均为O(n)</span><br></pre></td></tr></table></figure><h5 id="插入操作-3">插入操作</h5><p>在表L中的第i个位置上插入指定元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_DLink(DLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    if (p-&gt;next!=NULL) p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前D驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h5 id="删除操作-3">删除操作</h5><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">int ListDelete_DLink(DLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    if(q-&gt;next!=NULL)q-&gt;next-&gt;prior=p;</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><p>其他操作与单链表一样，不展示</p><h3 id="循环链表">循环链表</h3><p>特点：表中最后一个结点的指针域指向头结点，整个链表形成一个环。<br>既然是环的话，那就不难想象，从表中任意一个结点出发都可以找到表中其他结点。</p><h4 id="循环单链表">循环单链表</h4><p>循环单链表与单链表唯一的区别就是多了一个由尾结点指向头结点的指针。<br>所以循环链表的操作与单链表基本一致<br>唯一的差别就是<strong>循环的条件不是p或p-&gt;next是否为空，而是它们是否等于头指针</strong><br>($p==L或p-&gt;next==L$)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int Length_CLink(CLinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    CNode *s=L;</span><br><span class="line">    while (s-&gt;next!=L)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        s=s-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环双链表">循环双链表</h4><p>循环双链表与循环单链表唯一的区别就是多了一个指向前驱的指针。<br>所以循环双链表的操作与循环单链表也基本一致<br>就是<strong>对结点操作时，需要多操作一步，让p-&gt;prior指向前驱结点。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_CDLink(CDLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(p==(*L)||(i-j)&gt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(CDLinkList)malloc(sizeof(CDNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*删除*/</span><br><span class="line">int ListDelete_CDLink(CDLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((p-&gt;next)==(*L)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    q-&gt;next-&gt;prior=p;//让删除结点的下一个结点的前驱指向p；</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表">静态链表</h3><p>众所周知，指针是c语言的灵魂，指针使得链表的实现简单明了起来。但是问题来了，在c语言还没有的时代，又想描述链表，怎么办呢？<br>这就有了静态链表</p><h4 id="静态链表的设计">静态链表的设计</h4><p>首先，我们来解决一个最重要的问题，没有指针，怎么表示下一个元素的位置呢？</p><p>当时的人们想出来的办法便是，用数组的下标来代替指针。我们把这个数组的下标叫做游标。</p><p>第二个问题，当我们要往数组里插入元素时，如何确定数组里哪些分量未被使用，要插到哪个位置上呢？当我们删除一个元素的时候，要把这个删除后已经不存放数据的数组分量链接到哪里去，然后再次被使用呢？</p><p>解决办法是将所有未被使用过的以及被删除的分量用一个游标链成一个备用链表。<br>每当进行插入的使用便从备用链表上取得第一个结点作为待插入的新结点。<br>反之，在删除时将从链表中删除下来结点链接到备用链表上。</p><p>有没有觉得上面的描述特别熟悉，这实际上就是C语言里面malloc函数和free函数做的事情，在静态链表中，我们得自己实现，不过操作起来也不复杂。</p><p>最后一个问题，我们现在已经知道了我们把静态链表分为两部分，一部分存放数据，一部分不存放数据，我们称之为备用链表。那么我们如何标识这两部分呢？</p><p>解决办法，我们这里把数组下标为0位置的游标用来存放备用链表的第一个元素（也就是数组中第一个不存放数据的元素）的下标<br>我们这里把数组下标为1的位置游标用来存放第一个数据不为空的元素的下标<br>这里还有个细节就是我们把游标为0设为这两部分的结束。</p><h4 id="静态链表的定义">静态链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ElemType char//这里我们使用的例子，采取字符</span><br><span class="line">#define MaxSize 10  //链表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;//存储的数据元素</span><br><span class="line">    int next;//游标，用来指示下一个数组分量的下标</span><br><span class="line">&#125;SLinkList[MaxSize];//静态链表</span><br></pre></td></tr></table></figure><h4 id="静态链表的操作">静态链表的操作</h4><h5 id="初始化">初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitSpace_SL(SLinkList space)&#123; </span><br><span class="line">  int i;</span><br><span class="line">  for (i = 2; i &lt; MaxSize-1; i++)&#123;</span><br><span class="line">      space[i].data=&#x27; &#x27;;</span><br><span class="line">      space[i].next=i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  space[0].next=2;</span><br><span class="line">  space[0].data=&#x27; &#x27;;</span><br><span class="line">  space[1].next=0;</span><br><span class="line">  space[1].data=&#x27; &#x27;;</span><br><span class="line">  space[MaxSize-1].next=0;</span><br><span class="line">  space[MaxSize-1].data=&#x27; &#x27;;</span><br><span class="line">  return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求表长-2">求表长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int ListLength(SLinkList space)&#123;</span><br><span class="line">    int length=0;//空表长度为0</span><br><span class="line">    int i=space[1].next;//指向第一个有数据的位置</span><br><span class="line">    while (i!=0)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        i=space[i].next;//相当于指针的p=p-&gt;next</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的操作便是遍历表：<br>这里的i=space[i].next;相当于指针的p=p-&gt;next</p><h4 id="总结-6">总结</h4><p>尽管我们现在有了单链表，也不再会使用静态链表了，但是它的思想还是挺神奇的。<br>总的来说，它和单链表很像，插入删除不需要移动元素，所有我们称之为静态链表。<br>但是它不仅有单链表不能随机存取的缺点，也没有解决连续分配（数组）带来的表长难以确定的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 绪论</title>
      <link href="/post/146816a0.html"/>
      <url>/post/146816a0.html</url>
      
        <content type="html"><![CDATA[<p><strong>程序=数据结构+算法</strong><br><img src="/img/sujgxl.png" alt=""></p><h3 id="数据结构">数据结构</h3><h4 id="基本概念">基本概念</h4><p>数据 数据元素和数据项<br>数据对象：具有相同性质的数据元素的集合，是数据的一个子集<br>数据结构：相互之间存在一种或多种特定关系的数据元素的集合<br>数据类型：值的集合和定义在此集合上的一组操作的总称（原子类型和结构类型）<br>抽象数据类型（Abstract Data Type）：是抽象数据组织及与之相关的操作，数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。</p><h4 id="数据结构三要素">数据结构三要素</h4><p>逻辑结构 存储结构 运算</p><h5 id="逻辑结构">逻辑结构</h5><p>线性结构：线性表、栈、队列、数组<br>非线性结构：集合、树、图</p><h5 id="物理结构">物理结构</h5><p>指数据结构在计算机中的表示或映像。存储结构会影响数据运算的速度、存储空间分配的方便与否<br><strong>常用存储结构：</strong><br>顺序存储（下面三种为非顺序存储）<br>链式存储<br>索引存储：附加一个索引表（索引项=关键字+地址）<br>散列存储（哈希存储）：根据元素的关键字计算该元素的存储地址</p><h5 id="数据运算">数据运算</h5><p>每个逻辑结构都有自己的基本的数据运算<br><strong>运算的定义是针对逻辑结构的，指出运算的功能</strong><br><strong>运算的实现是针对存储结构的，指出运算的具体操作步骤（即不同存储结构有着不同的实现）</strong></p><h3 id="算法">算法</h3><h4 id="基本概念-2">基本概念</h4><h5 id="五个特性">五个特性</h5><p>有穷性：算法必须是有穷的，而程序可以是无穷的<br>确定性：相同的输入只能得出相同的输出<br>可行性：能通过基本操作实现算法<br>输入<br>输出：算法处理的结果</p><h5 id="优秀算法的标准">优秀算法的标准</h5><p>正确性<br>可读性<br>健壮性：能处理异常状况<br>高效率与低存储</p><h4 id="算法效率量度">算法效率量度</h4><h5 id="时间复杂度分析">时间复杂度分析</h5><p>事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”）<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>助记：常对幂指阶</strong><br><strong>一般只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层循环循环了几次</strong><br><strong>存在不同情况讨论时，平均时间复杂度=各个情况的循环次数与概率的加权和</strong><br>可以只考虑阶数高的部分<br>问题规模足够大时，常数项可以忽略<br>大O表示“同阶”，同等数量级<br>多项相加，只保留最高阶项；多项相乘都保留</p><h5 id="空间复杂度分析">空间复杂度分析</h5><p>空间开销(内存开销)与问题规模n的关系<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>普通程序</strong><br>内存装入程序代码和数据，一般程序代码与问题规模无关，而数据格式：<br>单一变量 $O(1)$<br>一维数组 $O(n)$<br>k维数组  $O(n^k)$<br><strong>递归程序：空间复杂度=递归调用的深度×数据格式</strong></p><h5 id="master公式">master公式</h5><p>递归函数可表示成$T(N) = a * T(N/b) + O(N^d)$<br>$log_ba &gt; d时，时间复杂度为O(N^{log_ba})$<br>$log_ba &lt; d时，时间复杂度为O(N^d)$<br>$log_ba = d时，时间复杂度为O(N^d * log_2N)$</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百囚徒问题</title>
      <link href="/post/5a05dd41.html"/>
      <url>/post/5a05dd41.html</url>
      
        <content type="html"><![CDATA[<p>这两天偶然刷到了一个油管博主讲解百囚徒问题，感觉非常有意思，思路非常好，所以决定记录下来。<br>本文内容来自Eugene Curtin，Max Warshauer. The locker puzzle，The Mathematical Intelligencer（2006）：28-31<br>参考知乎 凉拌苦瓜 博主的文章：<a href="https://zhuanlan.zhihu.com/p/410614948">https://zhuanlan.zhihu.com/p/410614948</a></p><h4 id="问题描述">问题描述</h4><p>在某个法制不健全的国家， 监狱中有编号1到100的100名死刑犯。监狱长给了他们最后一次机会：</p><p>一个房间里有100个抽屉，监狱长随意地把1到100这100个号码放入1号到100号抽屉中，每个抽屉一张。囚犯们逐个进入房间，每人可以任意打开50个抽屉，之后关上。如果每名囚犯都在这50个抽屉中发现了他的号码，那么所有的犯人都会被赦免；如果有人没有找到他的号码，那么所有的囚犯都会被处死。在第一个囚犯进入房间之前，囚犯们允许一起讨论开抽屉的“策略”，但一旦第一个囚犯进入房间，他们之间就被禁止交流。</p><h4 id="寻找思路">寻找思路</h4><p>如果<strong>纯粹随机</strong>开抽屉，那么所有人都被赦免的概率只有：<br>$(\frac{1}{2})^{100}\approx0.000000000000000000000000000000008$<br>这个概率相当于两个人在地球上找到同一粒沙子的概率，根本不可能</p><p>寻找线索，以原文为框架，尽量给出了一个正向寻找最佳策略的思路。但要注意最佳策略未必本来就是一个被正向找到的过程。<br>为了简化问题，我们先把囚徒成员数简化为10个，每个成员可以检查5个抽屉，这时随机策略的成功概率也只有$(\frac{1}{2})^{10}=(\frac{1}{1024})$了。</p><p>提高成功概率的一个思路是给每个人分配固定的5个抽屉去检查，我们可以先来验证一下这个猜测。假设我们制定的策略1为：1-5号成员检查1-5号抽屉，6-10号成员检查6-10号抽屉。那么他们成功的概率等于1-5号码牌刚好被分配到了1-5号抽屉中，概率为：<br>$(\frac{5}{10})(\frac{4}{9})(\frac{3}{8})(\frac{2}{7})(\frac{1}{6})=(\frac{1}{242})$</p><p>该策略成功的概率比随机策略提高了，但成功的概率仍然比较小。值得注意的是，prisoner1如果在该策略中找到了自己的号码，则prisoner6找到自己号码的概率为5/9，prisoner2找到自己号码的概率为4/9，即prisoner1是否成功与其他成员是否成功具有相关性。</p><p>那么我们猜想，在策略中提高不同成员检查结果的相关性可能会提高团队的成功概率。理想的策略是如果prisoner1成功，那么其他所有成员也会成功，这时团队成功的概率为1/2，当然很难实现（实际上无法实现），但我们可以找到一个使prisoner1与一部分成员成功的概率相同的策略，并验证在该策略下团队成功的概率。</p><h4 id="完美策略方案-单向循环链表的运用">完美策略方案 单向循环链表的运用</h4><p>每个囚徒的策略，就是首先打开与自己编号相同的抽屉，从中取出号码牌，并打开号码牌所对应的抽屉。之后，重复此过程，直到找到自己的号码牌，或者50个抽屉的机会用完。 <strong>实际就是看抽屉是否存在大于51个元素的链表，如果都小于50，那么所有囚徒一定都可以存活。</strong><br><img src="/img/loop1.png" alt="loop"><br>例如，29号囚徒首先打开了29号抽屉，里面放着51号的号码牌，于是他打开51号抽屉，里面放着18号的号码牌，于是他打开18号的抽屉，里面放着29号的号码牌，他完成了任务。</p><h5 id="计算概率">计算概率</h5><p>比起计算“所有循环链表的长度不超过50”的概率，“有一个循环链表长度超过50”的概率更容易计算。因为“有一个循环链表的长度是51”和“有一个循环链表的长度是52”之类的事件是彼此互斥的（循环链表的长度总和是100，所以如果有大于50的链表，也只会存在一个），所以总概率就是它们的和。而对于$m&gt;=51$，只需先选出$m$个元素，将它们构成一个环，之后再将剩下的元素随机打乱即可唯一地得到一种分布。</p><p>具体地说，所有形成长度为m环的映射种类为：<br>$C^m_{100}(m-1)!(100-m)!=100!/m$</p><p>全排列个数为$100!$</p><p>因此这个概率等于$P(m)=1/m$</p><p>综上，所有圆环长度不超过50的概率等于<br>$P=1-\sum_{m=51}^{100}\frac{1}{m}\approx0.312$</p><p>这个概率就是囚徒被释放的概率。当囚徒人数趋于无穷大时，概率趋向于：<br>$P=1-\sum_{m=N+1}^{2N}\frac{1}{m}\rightarrow1-ln2$</p><h4 id="总结-4">总结</h4><p>不那么严密地说，这个策略的关键点在于让所有囚徒尽可能地一起成功或者一起失败，因此所有玩家的任务不再是独立的，一旦有一个人成功，他所翻出的号码牌对应的人也一定会成功，同时只要有一半的人成功，剩下的人都一定成功。</p><p>通过计算可得，在之前所有人都成功的条件下，下一个人成功的概率依次为<br>50%,75.25%,89.26%,95.63%,…</p><p>这个策略被证明最优。</p><h5 id="一些感悟">一些感悟</h5><p>我觉得这个问题精彩在于对于概率本质的理解，收获很多，也再一次感受到了数学的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex基础知识</title>
      <link href="/post/3acd2553.html"/>
      <url>/post/3acd2553.html</url>
      
        <content type="html"><![CDATA[<h4 id="什么是vuex">什么是vuex</h4><p>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>总结：<strong>vuex是一个集中式管理组件依赖的共享数据的工具，可以解决不同组件数据共享问题。</strong></p><h4 id="vue的引入">vue的引入</h4><p>可以在使用脚手架手动创建项目的时候就选中vuex，会自动引入。或者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save    //安装</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27; </span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//注册vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数 </span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><h4 id="vuex核心模块">vuex核心模块</h4><p>vuex核心: state，mutations，actions，getters，modules<br><img src="/img/vuex.png" alt="vuex"></p><h5 id="state">state</h5><p><strong>state是放置所有公共状态的属性，如果你有一个公共状态数据，你只需要定义在 state对象中。下面就是定义了一个存储数字的count。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    // 管理数据</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们怎样在其他组件使用state里面的值呢？<br>主要是两种方式：<br>1.原始形式<br>组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过this.$store.state.count使用 --&gt;</span><br><span class="line">&lt;!-- 使用插值表达式获取，省略this --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数 mapState<br>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapState&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">//利用展开运算符将导出的状态映射给计算属性</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接当作计算属性使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用插值表达式获取 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们怎么修改count的值呢？</p><h5 id="mutations">mutations</h5><p><strong>使用mutations修改state里面的数据。state数据的修改只能通过mutations，并且一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">//定义一个让count增加的方法，每次增加多少要传递参数</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">//定义一个让count减少的方法，每次减少多少要传递参数，以对象的形式传递。</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>mutations里面存放修改state数据的方法。方法的第一个参数是store里面的state属性。我们可以在state上面找到我们存放的数据；方法的第二个参数是payload（参数名字也可以自己重命名），载荷，调用mutaiions的时候，可以传递参数，任何形式的参数都可以。官方推荐大多数情况下payload应该是一个对象，因为包含多个字段时使用对象形式更清晰已读。</strong></p><p>然后我们在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;add&#x27;,2)&quot;&gt;点击每次count增加2&lt;/div&gt;</span><br><span class="line">&lt;div @click=&quot;$store.commit(&#x27;sub&#x27;,&#123;num:1&#125;)&quot;&gt;点击每次count减少1。参数以对象形式传递&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数  mapMutations<br>和mapState很像，把位于mutations中的方法提取了出来，我们可以将它导入。mapMutations将组件中的 methods 映射为 store.commit调用。用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState, mapMutations&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">//然后当作普通方法使用</span><br><span class="line">    ...mapMutations([&#x27;add&#x27;, &#x27;sub&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例如</span><br><span class="line"> &lt;div @click=&quot;add(2)&quot;&gt;+&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="actions">actions</h5><p><strong>state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作。比如异步请求数据和定时器等操作。官方介绍：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。所以我们在addAsync 中使用context.commit(‘add’, num)使用了mutations的add方法。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改state的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">//一秒后增加count的值</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.dispatch(&#x27;addAsync&#x27;,2)&quot;&gt;点击后等待一秒再增加2&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数  mapActions</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    //当作普通方法调用就好</span><br><span class="line">    ...mapActions([&#x27;addAsync&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getters">getters</h5><p><strong>有时我们还需要从state中派生出一些状态，这些状态是依赖state的，然后我们就会用到getters</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改statement的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  getters: &#123;</span><br><span class="line">    handeleCount: (state) =&gt; &#123;</span><br><span class="line">      return `$&#123;state.count&#125;只小鸡`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;$store.getters.handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">   //然后当作计算属性使用即可</span><br><span class="line">    ...mapGetters([&#x27;handeleCount&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//例如</span><br><span class="line">&lt;div&gt;&#123;&#123;handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="总结-3">总结</h4><p><strong>1.state定义数据，使用$store.state获取<br>2.mutations修改数据，同步操作，使用$store.commit提交修改。<br>3.actions主要用于异步操作，通过mutations间接修改state数据，使用$store.dispatch提交修改。<br>4.getters主要用于派生依赖state的数据，使用$store.getters获取</strong><br>此文章介绍的是vuex最基础的使用，更多用法和更详细的介绍指路官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次型</title>
      <link href="/post/33cf95bf.html"/>
      <url>/post/33cf95bf.html</url>
      
        <content type="html"><![CDATA[<h4 id="二次型基本概念">二次型基本概念</h4><p>对于二次齐多项式:<br>$f(x1,x2,x3,…,xn)=a_{11}x_1^2+2a_{12}x_1x_3+…+2a_{1n}x_1x_n+…+…+a_{nn}x_n^2$<br>可以写成矩阵形式：<br>$\left[\begin{array}{c}x_1&amp;x_2&amp;…x_n\end{array}\right]<br>\left[\begin{array}{cc}a_{11}&amp;a_{12}&amp;…a_{1n} \\<br>a_{21}&amp;a_{22}&amp;…a_{2n}  \\<br>a_{n1}&amp;a_{n2}&amp;…a_{nn}\end{array}\right]<br>\left[\begin{array}{}x_1  \\<br>x_2  \\<br>…  \\<br>x_n\end{array}\right]=x^TAx$</p><h4 id="一些要点">一些要点</h4><p>标准型与规范型<br>标准型：没有混合项   规范型：平方项系数只有1，-1, 0<br>若存在可逆矩阵C使得C^TAC=B,则称A与B合同<br>二次型化为标准型后得到的$\Lambda$与A合同并且其对角线的值是A的特征值</p><h4 id="变换二次型为标准型的方法">变换二次型为标准型的方法</h4><p>配方法与正交法</p><h5 id="正交法">正交法</h5><ol><li>写出二次型矩阵A</li><li>求出A的特征值</li><li>求出对应特征向量</li><li>将特征向量正交化，组合到一起即可得到正交矩阵Q $x=Qy$</li></ol><h4 id="正定二次型">正定二次型</h4><p>3个重要的充要条件：</p><ol><li>正惯性指数$p=n$</li><li>特征值都大于0</li><li>全部顺序主子式大于</li></ol><p>必要条件：A的行列式|A|&gt;0,所有主对角线元素大于0</p><hr><p>考研复习的进度有点慢，自己要抓紧了<br>实习生活还挺舒服的，之前学的前端开发知识有了用武之地<br>千里之行始于这一篇blog，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建站感想</title>
      <link href="/post/134cee24.html"/>
      <url>/post/134cee24.html</url>
      
        <content type="html"><![CDATA[<hr><p>blog正式成型是2022年6月28号，正值繁忙的小学期，也离考研仅5个月了，希望自己能够越来越好吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better than better</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
