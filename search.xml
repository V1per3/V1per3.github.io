<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack入门</title>
      <link href="/post/1f3a274b.html"/>
      <url>/post/1f3a274b.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>简单来说就是一个<strong>打包工具</strong>，</p><p>可以将互相依赖的html、css、js以及图片字体等资源文件，经过处理打包成一个可执行的项目文件</p><h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p>在需要使用webpack的文件夹下，</p><p>首先执行<code>npm init -y</code>初始化，其中<code>-y</code>表示所有选项使用默认值</p><p>再执行<code>npm add webpack webpack-cli --dev</code>将webpack安装到开发者环境中</p><p>这样我们就能获得初始的开发环境</p><h2 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h2><p>这里才是学习webpack的重头戏，毕竟在webpack配置完成后，每次只要执行npx webpack便能智能地完成打包</p><h3 id="初步配置"><a href="#初步配置" class="headerlink" title="初步配置"></a>初步配置</h3><p>在根目录下新建一个’webpack.config.js’文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &quot;./src/index.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;dist.js&quot;,</span><br><span class="line">        path: path.resolve(__dirname,&quot;dist&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>mode</code>，选择了开发者模式</li><li><code>entry</code>，选择了相对于config文件的src目录下的index.js作为入口文件</li><li><code>output</code>, 对于输出配置了输出的名字，并且使用了自带的path配置了输出目录</li></ul><p>执行<code>npx webpack</code>，可以看到不仅重新输出了dist.js，其中的内容也和之前的有了不一样</p><h3 id="打包CSS文件和图片"><a href="#打包CSS文件和图片" class="headerlink" title="打包CSS文件和图片"></a>打包CSS文件和图片</h3><p>要先安装 <code>npm add --dev style-loader css-loader</code><br>然后要在webpack.config.js里对需要引入的文件名进行配置，如配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/i,</span><br><span class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|svg|jpg|jpeg|gif)$/i,</span><br><span class="line">        type: &quot;asset/resource&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="使用webpack插件自动生成html文件"><a href="#使用webpack插件自动生成html文件" class="headerlink" title="使用webpack插件自动生成html文件"></a>使用webpack插件自动生成html文件</h3><p>还是安装<br><code>npm add html-webpack-plugin --dev</code><br>然后导入webpack.config.js文件<br><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)</code><br>再进行配置即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &quot;博客列表&quot;,</span><br><span class="line">  &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>所以这时候再执行打包命令，可以看到输出文件夹下还多了一个index.html</p><p>这个HTML的标题默认为Webpack App</p><p>我们也可以对这个进行配置</p><h3 id="兼容低版本浏览器"><a href="#兼容低版本浏览器" class="headerlink" title="兼容低版本浏览器"></a>兼容低版本浏览器</h3><p>要让新的JavaScript的特性兼容低版本的浏览器，需要用到babel，而webpack也支持相应的loader</p><p>所以首先还是安装<br><code>npm add --dev babel-loader @babel/core @babel/preset-env</code><br>这三个包提供了我们需要的功能<br>然后再进行下面的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.js$/,</span><br><span class="line">  exclude: /node_modules/,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: &quot;babel-loader&quot;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      presets: [&quot;@babel/preset-env&quot;],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="压缩打包后的js代码"><a href="#压缩打包后的js代码" class="headerlink" title="压缩打包后的js代码"></a>压缩打包后的js代码</h3><p>同样是两步，先安装<br><code>npm add --dev terser-webpack-plugin</code><br>然后引入和配置<br><code>const TerserPlugin = require(&quot;terser-webpack-plugin&quot;)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimize: true,</span><br><span class="line">  minimizer: [new TerserPlugin()],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="无需执行命令自动打包"><a href="#无需执行命令自动打包" class="headerlink" title="无需执行命令自动打包"></a>无需执行命令自动打包</h3><p>现在每次修改了代码后都得重新执行打包命令<br>webpack也提供了一个插件能在保存后自动打包</p><p>还是先安装<br><code>npm add --dev webpack-dev-server</code><br>然后先在webpack.config.js中进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  static: &quot;./dist&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>再在package.json中进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack serve --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样在我们执行npm start的时候就会自动执行webpack serve<br>并且通过 npm start 打开的网页能在我们修改保存后自动刷新页面</p><h3 id="避免浏览器缓存js文件"><a href="#避免浏览器缓存js文件" class="headerlink" title="避免浏览器缓存js文件"></a>避免浏览器缓存js文件</h3><p>由于现在每次生成的文件名都是dist.js，所以浏览器会对这个文件进行缓存，进而不更新<br>为了避免进行缓存，可以给文件名添加一段随机的字符，每次更新后都生成新的随机字符<br>所以在webpack.config.js中配置输出即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: &quot;[name].[contenthash].js&quot;,</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="配置可视化打包工具"><a href="#配置可视化打包工具" class="headerlink" title="配置可视化打包工具"></a>配置可视化打包工具</h3><p>这是一个帮助分析的工具，它会可视化地展现打包过程中哪个文件占的体积比较大<br>所以同样的，先是安装这个插件<br><code>npm add --dev webpack-bundle-analyzer</code><br>接着在配置中引入这个插件<br><code>const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;);</code><br>以及在plugins中添加它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    title: &quot;test&quot;,</span><br><span class="line">  &#125;),</span><br><span class="line">  new BundleAnalyzerPlugin.BundleAnalyzerPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题笔记</title>
      <link href="/post/31ba8457.html"/>
      <url>/post/31ba8457.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="516-最长回文子序列（dp）"><a href="#516-最长回文子序列（dp）" class="headerlink" title="516.最长回文子序列（dp）"></a>516.最长回文子序列（dp）</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。</p><p>用 dp[i][j] 表示字符串 s 的下标范围[i,j] 内的最长回文子序列的长度。假设字符串 s的长度为 n，则只有当0&lt;&#x3D;i&lt;&#x3D;j&lt;n时,才会有dp[i][j]&gt;0，否则dp[i][j]&#x3D;0。</p><p>由于任何长度为 1 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0&lt;&#x3D;i&lt;n，都有dp[i][i]&#x3D;1。</p><p>当 i&lt;j 时，计算 dp[i][j] 需要分别考虑 s[i] 和s[j] 相等和不相等的情况：</p><ol><li><p>如果 s[i] &#x3D; s[j]，则首先得到 s 的下标范围 [i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i] 和s[j]，即可得到 s 的下标范围[i,j] 内的最长回文子序列，因此dp[i][j]&#x3D;dp[i+1][j−1]+2；</p></li><li><p>如果s[i] !&#x3D;s[j]，则 s[i] 和 s[j] 不可能同时作为同一个回文子序列的首尾，因此dp[i][j]&#x3D;max(dp[i+1][j],dp[i][j−1])。</p></li></ol><p>由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。</p><p>最终得到 dp[0][n−1] 即为字符串 s 的最长回文子序列的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascript</span></span><br><span class="line"><span class="keyword">var</span> longestPalindromeSubseq = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)); <span class="comment">//生成二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> dp[n][n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c1 = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">char</span> c2 = s[j];</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = fmax(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列（dp）"><a href="#1143-最长公共子序列（dp）" class="headerlink" title="1143.最长公共子序列（dp）"></a>1143.最长公共子序列（dp）</h2><p>给定两个字符串 <code>text1</code> 和<code> text2</code>，返回这两个字符串的最长<strong>公共子序列</strong>的长度。如果不存在<strong>公共子序列</strong>，返回 0 。</p><p>一个字符串的<strong>子序列</strong>是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><pre><code>例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。</code></pre><p>两个字符串的公共子序列是这两个字符串所共同拥有的子序列。</p><p><strong>状态转移方程为</strong>：</p><ol><li>当text1[i−1]&#x3D;&#x3D;text2[j−1]: dp[i][j]&#x3D;dp[i−1][j−1]+1;</li><li>当text1[i−1]!&#x3D;text2[j−1]: dp[i][j]&#x3D;max(dp[i−1][j],dp[i][j−1]);</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(<span class="type">char</span> * text1, <span class="type">char</span> * text2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">strlen</span>(text1);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">strlen</span>(text2);</span><br><span class="line">    <span class="type">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=fmax(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c1 = text1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c2 = text2[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c1 === c2) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1312-让字符串成为回文串的最少插入次数（dp）"><a href="#1312-让字符串成为回文串的最少插入次数（dp）" class="headerlink" title="1312.让字符串成为回文串的最少插入次数（dp）"></a>1312.让字符串成为回文串的最少插入次数（dp）</h2><p>是前两个题的变种，有两种解法</p><ol><li>求字符串与逆序串的最长公共子序列s，然后用n-s即可</li><li>该题的状态转移方程如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] == s[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i][j] = fmax(dp[i + 1][j], dp[i][j - 1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="405-数字转换为十六进制数（位运算）"><a href="#405-数字转换为十六进制数（位运算）" class="headerlink" title="405. 数字转换为十六进制数（位运算）"></a>405. 数字转换为十六进制数（位运算）</h2><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p>注意:</p><ol><li>十六进制中所有字母(a-f)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li><li>给定的数确保在32位有符号整数范围内。</li><li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li></ol><p><strong>C语言动态分配</strong></p><p>malloc函数。其原型void *malloc(unsigned int num_bytes)；<br>num_byte为要申请的空间大小，需要我们手动的去计算，如int *p &#x3D; (int *)malloc(20 * sizeof(int)),如果编译器默认int为4字节存储的话，那么计算结果是80Byte，一次申请一个80Byte的连续空间，并将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。</p><p>calloc函数，其原型void *calloc(size_t n, size_t size)；<br>其比malloc函数多一个参数，并不需要人为的计算空间的大小，比如如果他要申请20个int类型空间，会int *p &#x3D; (int *)calloc(20, sizeof(int)）,这样就省去了人为空间计算的麻烦。但这并不是他们之间最重要的区别，malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//主要是通过与操作来实现</span><br><span class="line">char * toHex(int num)&#123;</span><br><span class="line">    char c[16]=&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;</span><br><span class="line">    char * ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*9);</span><br><span class="line">    for(int i=7;i&gt;=0;--i)&#123;</span><br><span class="line">        ans[i]=c[num&amp;0xF];//每位16进制</span><br><span class="line">        num=num&gt;&gt;4;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[8]=&#x27;\0&#x27;;</span><br><span class="line">    while(ans[0]==&#x27;0&#x27;&amp;&amp;*(ans+1)!=&#x27;\0&#x27;)&#123;//剔除前缀0</span><br><span class="line">        ans=ans+1;//指针右移</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量-（DFS）"><a href="#200-岛屿数量-（DFS）" class="headerlink" title="200.岛屿数量 （DFS）"></a>200.岛屿数量 （DFS）</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>题解</strong></p><p>一共三种方法，DFS,BFS和并查集，此处只给出DFS的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*dfs:将数组grid中(i,j)元素至0</span><br><span class="line">char ** grid：目标数组</span><br><span class="line">int i：需要至0的位置</span><br><span class="line">int j: 需要至0的位置</span><br><span class="line">int m：数组行数</span><br><span class="line">int n：数组列数</span><br><span class="line">返回值：无</span><br><span class="line">*/</span><br><span class="line">void dfs(char ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i+1, j, m, n);</span><br><span class="line">    dfs(grid, i-1, j, m, n);</span><br><span class="line">    dfs(grid, i, j+1, m, n);</span><br><span class="line">    dfs(grid, i, j-1, m, n);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">*numIslands：计算grid中存在相邻为1的个数</span><br><span class="line">char** grid：数组</span><br><span class="line">int gridSize:数组行数</span><br><span class="line">int* gridColSize:数组列数</span><br><span class="line">返回值：相邻为1的个数</span><br><span class="line">*/</span><br><span class="line">int numIslands(char** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == &#x27;1&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                dfs(grid, i, j, m, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积-（DFS）"><a href="#695-岛屿的最大面积-（DFS）" class="headerlink" title="695.岛屿的最大面积 （DFS）"></a>695.岛屿的最大面积 （DFS）</h2><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p><strong>题解</strong></p><p>在200的基础上，在DFS中计算面积即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int ** grid, int i, int j, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(grid[i][j] == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        grid[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1+dfs(grid, i+1, j, m, n)+dfs(grid, i-1, j, m, n)+dfs(grid, i, j+1, m, n)+dfs(grid, i, j-1, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxAreaOfIsland(int** grid, int gridSize, int* gridColSize)&#123;</span><br><span class="line">    int m = gridSize;</span><br><span class="line">    int n = gridColSize[0];</span><br><span class="line">    int max = 0;</span><br><span class="line">    int i,j;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(i = 0; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(grid[i][j] == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                count = dfs(grid, i, j, m, n);</span><br><span class="line">                max = fmax(max,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-无重复字符的最长子串-（hash-滑动窗口）"><a href="#3-无重复字符的最长子串-（hash-滑动窗口）" class="headerlink" title="3.无重复字符的最长子串 （hash+滑动窗口）"></a>3.无重复字符的最长子串 （hash+滑动窗口）</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><p><strong>滑动窗口解决</strong></p><p>需要借助hash结构存储重复元素</p><p>此处使用数组模拟hash表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstring(char * s)&#123;</span><br><span class="line">    int sLen = strlen(s); //获取字符串长度</span><br><span class="line">    int left=0, right = 0; //左右指针</span><br><span class="line">    int res=0, cnt=0; //结果和计数</span><br><span class="line">    int tmp[128] = &#123;0&#125;; //以128位数组记录字串中的字符是否已经出现</span><br><span class="line">    </span><br><span class="line">    while(right &lt; sLen) &#123;           //循环条件为右指针小于字符串长度</span><br><span class="line">        if(tmp[s[right]] == 0) &#123;  //当右指针指向的字符没出现在子串中时</span><br><span class="line">            tmp[ s[right] ]=1;       //使用tmp数组记录右指针指向的字符在ascii码中对应的位置</span><br><span class="line">            right++;                     //右指针右移</span><br><span class="line">            cnt++;                       //计数加1</span><br><span class="line">            res = res &gt; cnt ? res : cnt;   //记录结果</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;                            //当右指针指向的字符出现在子串中时</span><br><span class="line">            tmp[ s[left] ] = 0;     //左指针指向字符的ascii码不再出现在tmp数组中</span><br><span class="line">            left++;                    //左指针右移</span><br><span class="line">            cnt--;                      //计数减1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;          //返回最终无重复字串长度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>javascript解法(使用set)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    // 哈希集合，记录每个字符是否出现过</span><br><span class="line">    const occ = new Set();</span><br><span class="line">    const n = s.length;</span><br><span class="line">    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br><span class="line">    let rk = -1, ans = 0;</span><br><span class="line">    for (let i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (i != 0) &#123;</span><br><span class="line">            // 左指针向右移动一格，移除一个字符</span><br><span class="line">            occ.delete(s.charAt(i - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        while (rk + 1 &lt; n &amp;&amp; !occ.has(s.charAt(rk + 1))) &#123;</span><br><span class="line">            // 不断地移动右指针</span><br><span class="line">            occ.add(s.charAt(rk + 1));</span><br><span class="line">            ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br><span class="line">        ans = Math.max(ans, rk - i + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串-dp"><a href="#5-最长回文子串-dp" class="headerlink" title="5.最长回文子串 (dp)"></a>5.最长回文子串 (dp)</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>动态规划</strong></p><p>状态转移方程：<br>    P(i,j)&#x3D;P(i+1,j−1)∧(Si&#x3D;&#x3D;Sj​)</p><p>也就是说，只有s[i+1:j−1] 是回文串，并且 s 的第 i 和 j 个字母相同时，s[i:j]才会是回文串。</p><p>动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：</p><ol><li>P(i,i)&#x3D;true</li><li>P(i,i+1)&#x3D;(Si&#x3D;&#x3D;Si+1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//C</span><br><span class="line">char * longestPalindrome(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n&lt;2)&#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxLen = 1;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    // dp[i][j] 表示 s[i..j] 是否是回文串</span><br><span class="line">    int dp[n][n];</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j=1 ; j &lt; n; j++) &#123;</span><br><span class="line">        // 左下角先填</span><br><span class="line">        for (int i = 0; i &lt; j; i++) &#123;</span><br><span class="line">            if (s[i] != s[j]) &#123;</span><br><span class="line">                dp[i][j] = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (j - i &lt; 3) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j - 1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br><span class="line">            if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                maxLen = j - i + 1;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    char *ans;</span><br><span class="line">    ans=(char *)malloc(sizeof(char)*(maxLen+1));</span><br><span class="line">    for(int i=0; i&lt;maxLen; i++)&#123;</span><br><span class="line">        ans[i]=s[begin+i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[maxLen]=&#x27;\0&#x27;;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><pre><code>例如，121 是回文，而 123 不是。</code></pre><p>将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于int.MAX，我们将遇到整数溢出问题。</p><p>为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        // 特殊情况：</span><br><span class="line">        // 如上所述，当 x &lt; 0 时，x 不是回文数。</span><br><span class="line">        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span><br><span class="line">        // 则其第一位数字也应该是 0</span><br><span class="line">        // 只有 0 满足这一属性</span><br><span class="line">        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int revertedNumber = 0;</span><br><span class="line">        while (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * 10 + x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span><br><span class="line">        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span><br><span class="line">        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span><br><span class="line">        return x == revertedNumber || x == revertedNumber / 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int reverse(int x)&#123;</span><br><span class="line">     int rev = 0;</span><br><span class="line">        while (x != 0) &#123;</span><br><span class="line">            if (rev &lt; INT_MIN / 10 || rev &gt; INT_MAX / 10) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            int digit = x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">            rev = rev * 10 + digit;</span><br><span class="line">        &#125;</span><br><span class="line">    return rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和（快排-双指针）"><a href="#15-三数之和（快排-双指针）" class="headerlink" title="15.三数之和（快排+双指针）"></a>15.三数之和（快排+双指针）</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p><p>你返回所有和为 0 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p><strong>使用快排+双指针</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void *a,const void *b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int*)a - *(int*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    if(numsSize &lt; 3)</span><br><span class="line">        return NULL;</span><br><span class="line">    qsort(nums,numsSize,sizeof(int),cmp);</span><br><span class="line">    int **ans = (int **)malloc(sizeof(int *) * numsSize  *numsSize);</span><br><span class="line">    *returnColumnSizes = (int *)malloc(sizeof(int) * numsSize * numsSize);</span><br><span class="line">    int i,j,k,sum;</span><br><span class="line"></span><br><span class="line">    int indexLeft   = 0;</span><br><span class="line">    int indexMiddle = 0;</span><br><span class="line">    int indexRight  = 0;</span><br><span class="line">    //快排过后，使用三指针 遍历</span><br><span class="line">    //左边遍历到倒数第三位即可</span><br><span class="line">    for(indexLeft = 0; indexLeft&lt; numsSize - 2; indexLeft++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[indexLeft] &gt; 0) </span><br><span class="line">        &#123;</span><br><span class="line">            //因为是快排的结果，所以如果出现大零的</span><br><span class="line">            //后面的值都是大于0的</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果值相同 则不需要遍历</span><br><span class="line">        if(indexLeft &gt; 0 &amp;&amp; nums[indexLeft] == nums[indexLeft-1])</span><br><span class="line">            continue;</span><br><span class="line">        indexMiddle = indexLeft + 1;</span><br><span class="line">        indexRight  = numsSize - 1;</span><br><span class="line"></span><br><span class="line">        //双指遍历 找到所有的可能</span><br><span class="line">        while(indexMiddle &lt; indexRight)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = nums[indexLeft] + nums[indexMiddle] + nums[indexRight];</span><br><span class="line"></span><br><span class="line">            if(sum == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[*returnSize] = (int*)malloc(sizeof(int)*3);</span><br><span class="line">                (*returnColumnSizes)[*returnSize] = 3;</span><br><span class="line">                ans[*returnSize][0] = nums[indexLeft];</span><br><span class="line">                ans[*returnSize][1] = nums[indexMiddle];</span><br><span class="line">                ans[*returnSize][2] = nums[indexRight];</span><br><span class="line">                *returnSize += 1;</span><br><span class="line">                //过滤相等的值</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexMiddle] == nums[++indexMiddle]);</span><br><span class="line">                while(indexMiddle &lt; indexRight &amp;&amp; nums[indexRight] == nums[--indexRight]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                //左边递减</span><br><span class="line">                indexRight--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //右边递增</span><br><span class="line">                indexMiddle++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-盛最多水的容器（双指针）"><a href="#11-盛最多水的容器（双指针）" class="headerlink" title="11.盛最多水的容器（双指针）"></a>11.盛最多水的容器（双指针）</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>使用双指针解决</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int maxArea(int* height, int heightSize)&#123;</span><br><span class="line">    int marea = 0;</span><br><span class="line">    int carea = 0;</span><br><span class="line">    int left = 0;</span><br><span class="line">    int right = heightSize-1;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        carea = (right-left)*fmin(height[left],height[right]);</span><br><span class="line">        marea = fmax(carea,marea);</span><br><span class="line">        if(height[left]&lt;=height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return marea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号（栈）"><a href="#20-有效的括号（栈）" class="headerlink" title="20.有效的括号（栈）"></a>20.有效的括号（栈）</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>用栈解决</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bool isValid(char * s)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    if(n%2!=0) return 0;</span><br><span class="line">    char *stack = (char *)malloc(sizeof(char)*n);</span><br><span class="line">    int top = -1;</span><br><span class="line">    for(int i = 0; i&lt;n ;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;(&#x27;||s[i]==&#x27;&#123;&#x27;||s[i]==&#x27;[&#x27;)&#123;</span><br><span class="line">            stack[++top] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;(&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;&#125;&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;&#123;&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s[i]==&#x27;]&#x27;)&#123;</span><br><span class="line">            if(top==-1) return 0;</span><br><span class="line">            if(stack[top]==&#x27;[&#x27;)&#123;</span><br><span class="line">                top -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(top==-1) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个结点（快慢指针）"><a href="#19-删除链表的倒数第N个结点（快慢指针）" class="headerlink" title="19.删除链表的倒数第N个结点（快慢指针）"></a>19.删除链表的倒数第N个结点（快慢指针）</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p><strong>官方题解，使用哑结点dummy避免头结点的讨论</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    struct ListNode* dummy = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;//构造虚拟节点，避免头节点的讨论</span><br><span class="line"></span><br><span class="line">    struct ListNode* first = head;</span><br><span class="line">    struct ListNode* second = dummy;//定义快慢指针</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;//快指针先走</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (first) &#123;//慢指针跟上</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    second-&gt;next = second-&gt;next-&gt;next;//删除慢指针指向的下一个元素</span><br><span class="line">    struct ListNode* ans = dummy-&gt;next;</span><br><span class="line">    free(dummy);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自己的想法</strong></p><p>利用两个指针，一个在前，一个在后，相差n；让p1先走n步。</p><ol><li>如果p1为空，说明n正好为链表长度，所以删除倒数第n个就是删除第一个；</li><li>如果p1不为空，p2从头开始和p1一起移动，此时二者相差n个，当p1的下一个为空，说明p1正好是最后一个，倒数第n就正好是p2的下一个，所以删除p2的下一个即可；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct ListNode *p1=head,*p2=head;</span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    while(p1!=NULL&amp;&amp;p1-&gt;next!=NULL)&#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p1==NULL) head=head-&gt;next;</span><br><span class="line">    else p2-&gt;next=p2-&gt;next-&gt;next;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表（迭代）"><a href="#21-合并两个有序链表（迭代）" class="headerlink" title="21.合并两个有序链表（迭代）"></a>21.合并两个有序链表（迭代）</h2><p>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>迭代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)&#123;</span><br><span class="line">    struct ListNode * preHead = malloc(sizeof(struct ListNode));</span><br><span class="line">    struct ListNode* prev = preHead;</span><br><span class="line">        while (list1 != NULL &amp;&amp; list2 != NULL) &#123;</span><br><span class="line">            if (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                prev-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prev-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br><span class="line">        prev-&gt;next = list1 == NULL ? list2 : list1;</span><br><span class="line"></span><br><span class="line">        return preHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-括号生成（回溯-模板）"><a href="#22-括号生成（回溯-模板）" class="headerlink" title="22.括号生成（回溯 模板）"></a>22.括号生成（回溯 模板）</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是不停选括号，要么选左括号，要么选右括号。<br>并有这些约束的：</p><ol><li><p>只要(有剩，就可以选(。(((((这么选，都还不能判定为非法。</p></li><li><p>当剩下的)比(多时，才可以选)，否则，)不能选，选了就非法。因为：剩下的)比(少，即，使用的)比(多，不能成双成对。</p></li></ol><p>描述节点的状态有：当前构建的字符串，和左右括号所剩的数量。</p><p><strong>选择</strong></p><p>在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树。<br>用 DFS 遍历这棵树，找出所有的解，这个过程叫回溯。</p><p><strong>约束条件：</strong></p><p>即，什么情况下可以选左括号，什么情况下可以选右括号。<br>利用约束做“剪枝”，即，去掉不会产生解的选项，即，剪去不会通往合法解的分支。<br>比如()，现在左右括号各剩一个，再选)就成了())，不能让这个错的选择成为选项（不落入递归）：</p><p>if (right &gt; left) { &#x2F;&#x2F; 右括号剩的比较多，才能选右括号<br>    dfs(str + ‘)’, left, right - 1);<br>}</p><p><strong>目标：</strong></p><p>构建出一个用尽 n 对括号的合法括号串。<br>意味着，当构建的长度达到 2 * n，就可以结束递归（不用继续选了）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void generate(int left,int right,int size,char* str,int n, int* returnSize,char** result)</span><br><span class="line">//left代表左括号数量，right代表右括号数量，str代表储存几组有效组合，returnsize表示返回数量</span><br><span class="line">&#123;</span><br><span class="line">if (left == n &amp;&amp; right == n) </span><br><span class="line">&#123; // 满足题意的题解</span><br><span class="line">result[(*returnSize)] = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">strcpy(result[(*returnSize)++], str);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 如果左括号数量不大于 n，可以放一个左括号</span><br><span class="line">if (left &lt; n) </span><br><span class="line">&#123;</span><br><span class="line">str[size] = &#x27;(&#x27;;</span><br><span class="line">generate(left + 1, right, size + 1, str, n,  returnSize, result);</span><br><span class="line">&#125;</span><br><span class="line">// 如果右括号数量小于左括号的数量，可以放一个右括号</span><br><span class="line">if (right &lt; left) </span><br><span class="line">&#123;</span><br><span class="line">str[size] = &#x27;)&#x27;;</span><br><span class="line">generate(left , right+1, size + 1, str, n, returnSize, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">char ** generateParenthesis(int n, int* returnSize)</span><br><span class="line">&#123;</span><br><span class="line">char *str = (char*)calloc((2 * n + 1), sizeof(char));</span><br><span class="line">char **result = (char**)malloc(sizeof(char*) * 1430); </span><br><span class="line">// 卡特兰数: 1, 2, 5, 14, 42, 132, 429, 1430，题目中最多生成1430组</span><br><span class="line">*returnSize = 0;</span><br><span class="line">generate(0, 0, 0, str, n, returnSize, result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//卡特兰数的一个递推函数</span><br><span class="line">int catalan(n) &#123;</span><br><span class="line">  int i, j, h[n + 1];</span><br><span class="line">  h[0] = h[1] = 1;</span><br><span class="line">  for (i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    h[i] = 0;</span><br><span class="line">    for (j = 0; j &lt; i; j++)</span><br><span class="line">      h[i] = h[i] + h[j] * h[i - j - 1];</span><br><span class="line">  &#125;</span><br><span class="line">  return h[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-找出字符串中第一个匹配项的下标（KMP）"><a href="#28-找出字符串中第一个匹配项的下标（KMP）" class="headerlink" title="28.找出字符串中第一个匹配项的下标（KMP）"></a>28.找出字符串中第一个匹配项的下标（KMP）</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p><p><strong>KMP算法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int strStr(char* haystack, char* needle) &#123;</span><br><span class="line">    int n = strlen(haystack), m = strlen(needle);</span><br><span class="line">    if (m == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int next[m];</span><br><span class="line">    //求next数组</span><br><span class="line">    next[0] = 0;</span><br><span class="line">    for (int i = 1, j = 0; i &lt; m; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (needle[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    //求第一个匹配项下标</span><br><span class="line">    for (int i = 0, j = 0; i &lt; n; i++) &#123;</span><br><span class="line">        while (j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">            j = next[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        if (haystack[i] == needle[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == m) &#123;</span><br><span class="line">            return i - m + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组成（回溯）"><a href="#17-电话号码的字母组成（回溯）" class="headerlink" title="17.电话号码的字母组成（回溯）"></a>17.电话号码的字母组成（回溯）</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string temp;<span class="comment">//存储一个个字符串</span></span><br><span class="line">    vector&lt;string&gt; res;<span class="comment">//结果字符串列表</span></span><br><span class="line">    vector&lt;string&gt; map = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(string digits,<span class="type">int</span> pos)</span></span>&#123;<span class="comment">//回溯</span></span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(pos == len)&#123;<span class="comment">//如果pos+1后的结果与len相等，说明上轮循环已经把所有长度的字符都压进去了，是一个结果字符串</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);<span class="comment">//所以压该字符串进列表</span></span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//该层不进行循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[pos] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//转换为数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; map[num].<span class="built_in">size</span>(); i++)&#123;<span class="comment">//把该数字所对应的所有字母一个个循环遍历</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(map[num][i]);<span class="comment">//压该字符</span></span><br><span class="line">            <span class="built_in">DFS</span>(digits,pos+<span class="number">1</span>);<span class="comment">//进入深层，去压下一位上的字符，直至pos到len</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();<span class="comment">//需要压出最后一个字符，压入一个新轮循环的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">DFS</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置（二分查找）"><a href="#34-在排序数组中查找元素的第一个和最后一个位置（二分查找）" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置（二分查找）"></a>34.在排序数组中查找元素的第一个和最后一个位置（二分查找）</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int findmid(int *nums, int low , int high , int target)&#123;</span><br><span class="line">    //递归实现二分查找</span><br><span class="line">    //if(low &gt; high) return -1; </span><br><span class="line">    //int mid = (low + high)/2;</span><br><span class="line">    //if(nums[mid]==target) return mid;</span><br><span class="line">    //else if(nums[mid]&gt;target) return findmid(nums,low,mid-1,target);</span><br><span class="line">    //else return findmid(nums,mid+1,high,target);</span><br><span class="line">    //迭代实现</span><br><span class="line">    while(low&lt;=high)&#123;</span><br><span class="line">        int mid = (low + high)/2;</span><br><span class="line">        if(nums[mid]==target) return mid;</span><br><span class="line">        else if(nums[mid]&gt;target)high = mid -1;</span><br><span class="line">        else low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int* searchRange(int* nums, int numsSize, int target, int* returnSize)&#123;</span><br><span class="line">    *returnSize=2;</span><br><span class="line">    int *result = (int*)malloc(sizeof(int)*2);</span><br><span class="line">    if(numsSize == 0)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = findmid(nums,0,numsSize-1,target);</span><br><span class="line">    if(ans == -1)&#123;</span><br><span class="line">        result[0]=-1;result[1]=-1;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int low=ans,high=ans;</span><br><span class="line">        while((low-1)&gt;=0&amp;&amp;nums[low-1]==target) low--;</span><br><span class="line">        while((high+1)&lt;numsSize&amp;&amp;nums[high+1]==target) high++;</span><br><span class="line">        result[0]=low;result[1]=high;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result[0]=-1;result[1]=-1;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子数组和（dp-贪心）"><a href="#53-最大子数组和（dp-贪心）" class="headerlink" title="53.最大子数组和（dp||贪心）"></a>53.最大子数组和（dp||贪心）</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//dp解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int pre = 0, maxAns = nums[0];</span><br><span class="line">    for (int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">        pre = fmax(pre + nums[i], nums[i]);</span><br><span class="line">        maxAns = fmax(maxAns, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxAns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//贪心解</span><br><span class="line">int maxSubArray(int* nums, int numsSize) &#123;</span><br><span class="line">    int result = INT_MIN;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        for(int i = 0; i &lt; numsSize; i++) &#123;</span><br><span class="line">            tmp += nums[i];</span><br><span class="line">            result = fmax(tmp, result);</span><br><span class="line">            if(tmp &lt; 0) tmp = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列（回溯）"><a href="#46-全排列（回溯）" class="headerlink" title="46.全排列（回溯）"></a>46.全排列（回溯）</h2><p>给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以按任意顺序返回答案。</p><p><strong>回溯</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void swap(int * nums,int indexA,int indexB)</span><br><span class="line">&#123;</span><br><span class="line">    int temp    = nums[indexA];</span><br><span class="line">    nums[indexA]= nums[indexB];</span><br><span class="line">    nums[indexB]= temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void prem(int* nums, int numsSize, int* returnSize, int** returnColumnSizes,int** returnNums,int offset)</span><br><span class="line">&#123;</span><br><span class="line">    if(offset == numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        //遍历到末尾了</span><br><span class="line">        //申请returnNums</span><br><span class="line">        returnNums[*returnSize] = (int *)malloc(sizeof(int ) * numsSize);</span><br><span class="line">        //拷贝内容到returnNums</span><br><span class="line">        memcpy(returnNums[*returnSize],nums,sizeof(int) * numsSize );</span><br><span class="line">        //记录当前拷贝内容的长度</span><br><span class="line">        (*returnColumnSizes)[*returnSize] = numsSize;</span><br><span class="line">        *returnSize = *returnSize + 1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //回溯算法的核心</span><br><span class="line">        int i;</span><br><span class="line">        for(i = offset; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">            prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,offset+1);</span><br><span class="line">            swap(nums,i,offset);//i 和 offset 交换</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)</span><br><span class="line">&#123;</span><br><span class="line">    //不重复的数字的全排序</span><br><span class="line">    //组合次数为 n！= n *( n - 1) *( n - 2) ...... 2 * 1</span><br><span class="line">    //这样的方法适合回溯的方法</span><br><span class="line">    //取值范围1 &lt;= nums.length &lt;= 6  = 6 * 5 * 4 * 3 *2 * 1 = 720中可能</span><br><span class="line">    int **returnNums = (int **)malloc(sizeof(int *) * 721);</span><br><span class="line">    *returnColumnSizes= (int *)malloc(sizeof(int ) * 721);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    prem(nums,numsSize,returnSize,returnColumnSizes,returnNums,0);</span><br><span class="line">    return returnNums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏（贪心）"><a href="#55-跳跃游戏（贪心）" class="headerlink" title="55.跳跃游戏（贪心）"></a>55.跳跃游戏（贪心）</h2><p>给定一个非负整数数组 nums ，你最初位于数组的<strong>第一个下标</strong>。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>题解</strong></p><p>对于每一个可以到达的位置 i，它使得 i+1, i+2,···,i+nums[i] 这些连续的位置都可以到达。</p><p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 i+nums[i] 更新 最远可以到达的位置。</p><p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool canJump(int* nums, int numsSize)&#123;</span><br><span class="line">    int mostf = 0;</span><br><span class="line">    for(int i=0;i&lt;numsSize;i++)&#123;</span><br><span class="line">        if(i&lt;=mostf)&#123;</span><br><span class="line">            mostf =fmax(mostf,i+nums[i]);</span><br><span class="line">            if(mostf&gt;=numsSize-1)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍（dp）"><a href="#198-打家劫舍（dp）" class="headerlink" title="198.打家劫舍（dp）"></a>198.打家劫舍（dp）</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>题解</strong></p><p>对于第 i(i&gt;2) 间房屋，有两个选项：</p><p>偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋，偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和。</p><p>不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额。</p><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 i 间房屋能偷窃到的最高总金额。</p><p>用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><pre><code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code></pre><p>边界条件为：</p><ol><li>只有一间房屋，则偷窃该房屋：dp[0]&#x3D;nums[0]</li><li>只有两间房屋，选择其中金额较高的房屋进行偷窃：dp[1]&#x3D;max(nums[0],nums[1])</li></ol><p>最终的答案即为 dp[n−1]，其中 n 是数组的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int rob(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    if(numsSize==0) return 0;</span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line">    if(numsSize&gt;=2)&#123;</span><br><span class="line">        dp[1] = fmax(nums[0],nums[1]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 2 ; i &lt; numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = fmax(dp[i-1],dp[i-2]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[numsSize-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Z字形变化"><a href="#6-Z字形变化" class="headerlink" title="6.Z字形变化"></a>6.Z字形变化</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：<br>P * A * H * N<br>A P L S I I G<br>Y * I * R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;              <span class="comment">// 给定行数为 1 时结果与原字符串一样</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">res</span><span class="params">(numRows)</span></span>;            <span class="comment">// 创建 res 保存每行结果</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;                              <span class="comment">// 行数标志</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">-1</span>;                          <span class="comment">// 往上走还是往下走的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> &amp;ch : s) &#123;                    <span class="comment">// 遍历 s</span></span><br><span class="line">            res[i] += ch;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;   <span class="comment">// 行首行尾变向</span></span><br><span class="line">                flag = -flag;</span><br><span class="line">            &#125;</span><br><span class="line">            i += flag;                          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;     <span class="comment">// 将每行接起来就是结果</span></span><br><span class="line">            res[<span class="number">0</span>] += res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机II（dp-贪心）"><a href="#122-买卖股票的最佳时机II（dp-贪心）" class="headerlink" title="122.买卖股票的最佳时机II（dp||贪心）"></a>122.买卖股票的最佳时机II（dp||贪心）</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。</p><p>返回你能获得的最大利润 。</p><p><strong>题解</strong></p><p><strong>贪心</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        ans += fmax(0, prices[i] - prices[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dp</strong><br>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p><p>定义状态 dp[i][0] 表示第 ii 天交易完后手里没有股票的最大利润，dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。</p><p>考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出，并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程：</p><p>dp[i][0]&#x3D;max{dp[i−1][0],dp[i−1][1]+prices[i]}</p><p>再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 dp[i−1][1]，或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。可以列出如下的转移方程：</p><p>dp[i][1]&#x3D;max{dp[i−1][1],dp[i−1][0]−prices[i]}</p><p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][1]&#x3D;−prices[0]。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。</p><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 dp[i−1][0] 和 dp[i−1][1] 存放在两个变量中，通过它们计算出 dp[i][0] 和 dp[i][1] 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int maxProfit(int* prices, int pricesSize) &#123;</span><br><span class="line">    int dp0 = 0, dp1 = -prices[0];</span><br><span class="line">    for (int i = 1; i &lt; pricesSize; ++i) &#123;</span><br><span class="line">        int newDp0 = fmax(dp0, dp1 + prices[i]);</span><br><span class="line">        int newDp1 = fmax(dp1, dp0 - prices[i]);</span><br><span class="line">        dp0 = newDp0;</span><br><span class="line">        dp1 = newDp1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="300-最长递增子序列（dp）"><a href="#300-最长递增子序列（dp）" class="headerlink" title="300.最长递增子序列（dp）"></a>300.最长递增子序列（dp）</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p><strong>题解</strong></p><p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</p><p>我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：</p><p>dp[i]&#x3D;max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</p><p>即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列，所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]，才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。</p><p>最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(int* nums, int numsSize)&#123;</span><br><span class="line">    int dp[numsSize];</span><br><span class="line">    dp[0]=1;</span><br><span class="line">    int maxans = 1;</span><br><span class="line">    for(int i = 1; i&lt;numsSize ; i++)&#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = fmax(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxans = fmax(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78-子集（回溯-迭代-递归）"><a href="#78-子集（回溯-迭代-递归）" class="headerlink" title="78.子集（回溯 迭代 递归）"></a>78.子集（回溯 迭代 递归）</h2><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>记原序列中元素的总数为 n。原序列中的每个数字 a_i 的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n 的 0&#x2F;1 序列，第 i 位表示a_i是否在子集中。</p><p>可以发现 0&#x2F;1 序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0,2n−1]，mask 的二进制表示是一个 0&#x2F;1 序列，我们可以按照这个 0&#x2F;1 序列在原集合当中取数。当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。</p><p><strong>迭代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    int** ans = malloc(sizeof(int*) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * (1 &lt;&lt; numsSize));</span><br><span class="line">    *returnSize = 1 &lt;&lt; numsSize;</span><br><span class="line">    int t[numsSize];</span><br><span class="line">    for (int mask = 0; mask &lt; (1 &lt;&lt; numsSize); ++mask) &#123;</span><br><span class="line">        int tSize = 0;</span><br><span class="line">        for (int i = 0; i &lt; numsSize; ++i) &#123;</span><br><span class="line">            if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">//&lt;&lt;表示向左移位，1 &lt;&lt; i 表示第i位为1，其他位为0的整型值，Mask &amp; ( 1 &lt;&lt; i )表示检验标志变量Mask的第i位是否为1</span><br><span class="line">                t[tSize++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * tSize);</span><br><span class="line">        memcpy(tmp, t, sizeof(int) * tSize);</span><br><span class="line">        (*returnColumnSizes)[mask] = tSize;</span><br><span class="line">        ans[mask] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 记录答案</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑选择当前位置</span></span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// 考虑不选择当前位置</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码中，dfs(cur,n) 参数表示当前位置是 cur，原序列总长度为 n。原序列的每个位置在答案序列中的状态有被选中和不被选中两种，我们用 t 数组存放已经被选出的数字。在进入 dfs(cur,n) 之前 [0,cur−1] 位置的状态是确定的，而 [cur,n−1] 内位置的状态是不确定的，dfs(cur,n) 需要确定 cur 位置的状态，然后求解子问题 dfs(cur+1,n)。对于 cur 位置，我们需要考虑 a[cur] 取或者不取，如果取，我们需要把 a[cur] 放入一个临时的答案数组中（即上面代码中的 t），再执行 dfs(cur+1,n)，执行结束后需要对 t 进行回溯；如果不取，则直接执行 dfs(cur+1,n)。在整个递归调用的过程中，cur 是从小到大递增的，当 cur 增加到 n 的时候，记录答案并终止递归。可以看出二进制枚举的时间复杂度是 O(2 ^ n)。</p><h2 id="62-不同路径（dp）"><a href="#62-不同路径（dp）" class="headerlink" title="62.不同路径（dp）"></a>62.不同路径（dp）</h2><p>一个机器人位于一个 m x n 网格的左上角。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p><strong>题解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int uniquePaths(int m, int n)&#123;</span><br><span class="line">    int dp[m][n];</span><br><span class="line">    for(int i = 0 ; i&lt; m ; i++)&#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0 ; i&lt; n ; i++)&#123;</span><br><span class="line">        dp[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i =1 ; i&lt;m ; i++)&#123;</span><br><span class="line">        for(int j = 1 ; j&lt;n ; j++)&#123;</span><br><span class="line">            dp[i][j]=dp[i-1][j]+dp[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="59-螺旋矩阵-II（模拟）"><a href="#59-螺旋矩阵-II（模拟）" class="headerlink" title="59. 螺旋矩阵 II（模拟）"></a>59. 螺旋矩阵 II（模拟）</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 nxn 正方形矩阵 matrix 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int** generateMatrix(int n, int* returnSize, int** returnColumnSizes)&#123;</span><br><span class="line">    int left = 0, right = n-1, top = 0, bottom = n-1;</span><br><span class="line">    int count = 1, target = n * n;</span><br><span class="line">    int** matrix = malloc(sizeof(int*) * n);</span><br><span class="line">    *returnSize = n;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * n);</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        matrix[i] = malloc(sizeof(int) * n);</span><br><span class="line">        memset(matrix[i], 0, sizeof(int) * n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">    while(count &lt;= target)&#123;</span><br><span class="line">            //从左到右填充，相当于缩小上边界</span><br><span class="line">            for(int j = left; j &lt;= right; j++) matrix[top][j] = count++;</span><br><span class="line">            //缩小上边界</span><br><span class="line">            top++;</span><br><span class="line">            //从上向下填充，相当于缩小右边界</span><br><span class="line">            for(int i = top; i &lt;=bottom; i++) matrix[i][right] = count++;</span><br><span class="line">            //缩小右边界</span><br><span class="line">            right--;</span><br><span class="line">            //从右向左填充，相当于缩小下边界</span><br><span class="line">            for(int j = right; j &gt;= left; j--) matrix[bottom][j] = count++;</span><br><span class="line">            //缩小下边界</span><br><span class="line">            bottom--;</span><br><span class="line">            //从下向上填充，相当于缩小左边界</span><br><span class="line">            for(int i = bottom; i &gt;= top; i--) matrix[i][left] = count++;</span><br><span class="line">            //缩小左边界</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    return matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void reverseLinkedList(struct ListNode *head) &#123;</span><br><span class="line">    // 也可以使用递归反转一个链表</span><br><span class="line">    struct ListNode *pre = NULL;</span><br><span class="line">    struct ListNode *cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != NULL) &#123;</span><br><span class="line">        struct ListNode *next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *reverseBetween(struct ListNode *head, int left, int right) &#123;</span><br><span class="line">    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span><br><span class="line">    struct ListNode *dummyNode = malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyNode-&gt;val = -1;</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyNode;</span><br><span class="line">    for (int i = 0; i &lt; left - 1; i++) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *cur = pre-&gt;next;</span><br><span class="line">    struct ListNode *next;</span><br><span class="line">    for (int i = 0; i &lt; right - left; i++) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        next-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换（dp）"><a href="#322-零钱兑换（dp）" class="headerlink" title="322. 零钱兑换（dp）"></a>322. 零钱兑换（dp）</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>题解</strong><br>我们定义一个dp数组，大小 amount+1 ,dp[i]表示整数金额 i 需要dp[i]个银币<br>所以dp[i] &#x3D; dp[i - coins[j]] + 1 -&gt; 表示当前金额 i 需要 i - coins[j]需要的银币加 1<br>所以遍历整个coins 更新dp[i] 寻找最小的银币数<br>在dp初始化时，我们将其附最大值，如果 dp[i - coins[j]] &#x3D;&#x3D; 最大值，表示当前金额 i - coins[j] ，在coins中不存在 也保存最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int cmp(const void * a, const void * b)</span><br><span class="line">&#123;</span><br><span class="line">    return *(int *)a - *(int *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define MIN(a , b) ((a) &lt; (b) ? (a) : (b))</span><br><span class="line">int coinChange(int* coins, int coinsSize, int amount)&#123;</span><br><span class="line">    qsort(coins, coinsSize, sizeof(coins[0]), cmp);//升序</span><br><span class="line">    int dp[amount + 1];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    for(int i = 1; i &lt;= amount; i++)//遍历dp数组</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = amount + 1;//初始化最大值</span><br><span class="line">        for(int j = 0; j &lt; coinsSize; j++)//动态更新dp[i]</span><br><span class="line">        &#123;</span><br><span class="line">            if(coins[j] &gt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = MIN(dp[i] , dp[i - coins[j]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount] == (amount+1) ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="76-最小覆盖子串-滑动窗口-hash"><a href="#76-最小覆盖子串-滑动窗口-hash" class="headerlink" title="76.最小覆盖子串(滑动窗口+hash)"></a>76.最小覆盖子串(滑动窗口+hash)</h2><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：</p><ol><li>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。</li><li>如果 s 中存在这样的子串，我们保证它是唯一的答案。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span>[] have = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">r</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">l</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-跳跃游戏II（贪心）"><a href="#45-跳跃游戏II（贪心）" class="headerlink" title="45.跳跃游戏II（贪心）"></a>45.跳跃游戏II（贪心）</h2><p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ol><li>0 &lt;&#x3D; j &lt;&#x3D; nums[i] </li><li>i + j &lt; n</li></ol><p>返回到达 nums[n - 1] 的最小跳跃次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int jump(int* nums, int numsSize)&#123;</span><br><span class="line">    int maxPos = 0, end = 0, step = 0;</span><br><span class="line">    for (int i = 0; i &lt; numsSize - 1; ++i) &#123;</span><br><span class="line">        if (maxPos &gt;= i) &#123;</span><br><span class="line">            maxPos = fmax(maxPos, i + nums[i]);</span><br><span class="line">            if (i == end) &#123;</span><br><span class="line">                end = maxPos;</span><br><span class="line">                ++step;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</p><p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ol><li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li><li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li><li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li></ol><p>给你一个整数数组 nums ，找出 nums 的下一个排列。必须原地修改，只允许使用额外常数空间。</p><p><strong>题解</strong><br>对于长度为 n 的排列 a：</p><ol><li>首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</li><li>如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</li><li>交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *a, int *b) &#123;</span><br><span class="line">    int t = *a;</span><br><span class="line">    *a = *b, *b = t;</span><br><span class="line">&#125;</span><br><span class="line">void reverse(int *nums, int left, int right) &#123;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        swap(nums + left, nums + right);</span><br><span class="line">        left++, right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nextPermutation(int *nums, int numsSize) &#123;</span><br><span class="line">    int i = numsSize - 2;</span><br><span class="line">    while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        int j = numsSize - 1;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums + i, nums + j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums, i + 1, numsSize - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="61-旋转链表（闭合为环）"><a href="#61-旋转链表（闭合为环）" class="headerlink" title="61. 旋转链表（闭合为环）"></a>61. 旋转链表（闭合为环）</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p><strong>题解</strong><br><strong>闭合为环</strong><br>思路及算法：</p><p>记给定链表的长度为 n，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第  (n−1)−(k mod n) 个节点（从 0 开始计数）。</p><p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p><p>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p><p>特别地，当链表长度不大于 1 ，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode* rotateRight(struct ListNode* head, int k) &#123;</span><br><span class="line">    if (k == 0 || head == NULL || head-&gt;next == NULL) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = 1;</span><br><span class="line">    struct ListNode* iter = head;</span><br><span class="line">    while (iter-&gt;next != NULL) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    int add = n - k % n;</span><br><span class="line">    if (add == n) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;next = head;</span><br><span class="line">    while (add--) &#123;</span><br><span class="line">        iter = iter-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode* ret = iter-&gt;next;</span><br><span class="line">    iter-&gt;next = NULL;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合（回溯）"><a href="#77-组合（回溯）" class="headerlink" title="77. 组合（回溯）"></a>77. 组合（回溯）</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p><p>你可以按 任何顺序 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int* temp;</span><br><span class="line">int tempSize;</span><br><span class="line"></span><br><span class="line">int** ans;</span><br><span class="line">int ansSize;</span><br><span class="line"></span><br><span class="line">void dfs(int cur, int n, int k) &#123;</span><br><span class="line">    // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp</span><br><span class="line">    if (tempSize + (n - cur + 1) &lt; k) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录合法的答案</span><br><span class="line">    if (tempSize == k) &#123;</span><br><span class="line">        int* tmp = malloc(sizeof(int) * k);</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            tmp[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[ansSize++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 考虑选择当前位置</span><br><span class="line">    temp[tempSize++] = cur;</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">    tempSize--;</span><br><span class="line">    // 考虑不选择当前位置</span><br><span class="line">    dfs(cur + 1, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int** combine(int n, int k, int* returnSize, int** returnColumnSizes) &#123;</span><br><span class="line">    temp = malloc(sizeof(int) * k);</span><br><span class="line">    ans = malloc(sizeof(int*) * 10001);</span><br><span class="line">    tempSize = ansSize = 0;</span><br><span class="line">    dfs(1, n, k);</span><br><span class="line">    *returnSize = ansSize;</span><br><span class="line">    *returnColumnSizes = malloc(sizeof(int) * ansSize);</span><br><span class="line">    for (int i = 0; i &lt; ansSize; i++) &#123;</span><br><span class="line">        (*returnColumnSizes)[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度-单调栈"><a href="#739-每日温度-单调栈" class="headerlink" title="739. 每日温度(单调栈)"></a>739. 每日温度(单调栈)</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>示例 1:<br>输入: temperatures &#x3D; [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p><p><strong>题解</strong><br>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p><p>为什么可以在弹栈的时候更新 ans[prevIndex] 呢？因为在这种情况下，即将进栈的 i 对应的 temperatures[i] 一定是 temperatures[prevIndex] 右边第一个比它大的元素，试想如果 prevIndex 和 i 有比它大的元素，假设下标为 j，那么 prevIndex 一定会在下标 j 的那一轮被弹掉。</p><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="116-填充每个节点的下一个右侧节点指针（链表）"><a href="#116-填充每个节点的下一个右侧节点指针（链表）" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针（链表）"></a>116. 填充每个节点的下一个右侧节点指针（链表）</h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p><strong>迭代 使用next指针 两种连接方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从根节点开始</span><br><span class="line">    struct Node* leftmost = root;</span><br><span class="line"></span><br><span class="line">    while (leftmost-&gt;left != NULL) &#123;</span><br><span class="line">        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span><br><span class="line">        struct Node* head = leftmost;</span><br><span class="line"></span><br><span class="line">        while (head != NULL) &#123;</span><br><span class="line">            // CONNECTION 1 连接同一个父节点的两个子节点</span><br><span class="line">            head-&gt;left-&gt;next = head-&gt;right;</span><br><span class="line"></span><br><span class="line">            // CONNECTION 2 在不同父亲的子节点之间建立连接</span><br><span class="line">            if (head-&gt;next != NULL) &#123;</span><br><span class="line">                head-&gt;right-&gt;next = head-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 指针向后移动</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 去下一层的最左的节点</span><br><span class="line">        leftmost = leftmost-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归 使用层序遍历和队列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct Node* connect(struct Node* root) &#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化队列同时将第一层节点加入队列中，即根节点</span><br><span class="line">    struct Node* Q[5000];</span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    Q[right++] = root;</span><br><span class="line"></span><br><span class="line">    // 外层的 while 循环迭代的是层数</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        // 记录当前队列大小</span><br><span class="line">        int size = right - left;</span><br><span class="line"></span><br><span class="line">        // 遍历这一层的所有节点</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            // 从队首取出元素</span><br><span class="line">            struct Node* node = Q[left++];</span><br><span class="line"></span><br><span class="line">            // 连接</span><br><span class="line">            if (i &lt; size - 1) &#123;</span><br><span class="line">                node-&gt;next = Q[left];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 拓展下一层节点</span><br><span class="line">            if (node-&gt;left != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node-&gt;right != NULL) &#123;</span><br><span class="line">                Q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回根节点</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="139-单词拆分（dp）"><a href="#139-单词拆分（dp）" class="headerlink" title="139. 单词拆分（dp）"></a>139. 单词拆分（dp）</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const wordBreak = (s, wordDict) =&gt; &#123;</span><br><span class="line">  const wordSet = new Set(wordDict);</span><br><span class="line">  const len = s.length;</span><br><span class="line">  const dp = new Array(len + 1).fill(false);</span><br><span class="line">  dp[0] = true;</span><br><span class="line"></span><br><span class="line">  for (let i = 1; i &lt;= len; i++) &#123;</span><br><span class="line">    for (let j = i - 1; j &gt;= 0; j--) &#123;    // j去划分成两部分</span><br><span class="line">      const suffix = s.slice(j, i);       // 后缀部分 s[j: i-1]</span><br><span class="line">      if (wordSet.has(suffix) &amp;&amp; dp[j]) &#123; // 后缀部分是单词，且左侧子串[0,j-1]的dp[j]为真</span><br><span class="line">        dp[i] = true;</span><br><span class="line">        break;  // dp[i] = true了，i长度的子串已经可以拆成单词了，不需要j继续划分子串了</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[len];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="567-字符串的排列（双指针-滑动窗口）"><a href="#567-字符串的排列（双指针-滑动窗口）" class="headerlink" title="567. 字符串的排列（双指针+滑动窗口）"></a>567. 字符串的排列（双指针+滑动窗口）</h2><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p><p>换句话说，s1 的排列之一是 s2 的 子串 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>初始时，仅统计 s1 ​中的字符，则 cnt 的值均不为正，且元素值之和为<br>−n。</p><p>然后用两个指针 left 和 right 表示考察的区间 [left,right]。right 每向右移动一次，就统计一次进入区间的字符 x。</p><p>为保证 cnt 的值不为正，若此时 cnt[x]&gt;0，则向右移动左指针，减少离开区间的字符的 cnt 值直到 cnt[x]≤0。</p><p>注意到 [left,right] 的长度每增加 1，cnt 的元素值之和就增加 1。当<br>[left,right] 的长度恰好为 n 时，就意味着 cnt 的元素值之和为 0。由于 cnt 的值不为正，元素值之和为 0 就意味着所有元素均为 0，这样我们就找到了一个目标子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool checkInclusion(char* s1, char* s2) &#123;</span><br><span class="line">    int n = strlen(s1), m = strlen(s2);</span><br><span class="line">    if (n &gt; m) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt[26];</span><br><span class="line">    memset(cnt, 0, sizeof(cnt));</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        --cnt[s1[i] - &#x27;a&#x27;];</span><br><span class="line">    &#125;</span><br><span class="line">    int left = 0;</span><br><span class="line">    for (int right = 0; right &lt; m; ++right) &#123;</span><br><span class="line">        int x = s2[right] - &#x27;a&#x27;;</span><br><span class="line">        ++cnt[x];</span><br><span class="line">        while (cnt[x] &gt; 0) &#123;</span><br><span class="line">            --cnt[s2[left] - &#x27;a&#x27;];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        if (right - left + 1 == n) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="128-最长连续序列-哈希表-js-set"><a href="#128-最长连续序列-哈希表-js-set" class="headerlink" title="128. 最长连续序列(哈希表 js:set)"></a>128. 最长连续序列(哈希表 js:set)</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 +1 ,+2,⋯x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n^2)（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var longestConsecutive = function(nums) &#123;</span><br><span class="line">    let num_set = new Set();</span><br><span class="line">    for (const num of nums) &#123;</span><br><span class="line">        num_set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    let longestStreak = 0;</span><br><span class="line">    for (const num of num_set) &#123;</span><br><span class="line">        if (!num_set.has(num - 1)) &#123;</span><br><span class="line">            let currentNum = num;</span><br><span class="line">            let currentStreak = 1;</span><br><span class="line"></span><br><span class="line">            while (num_set.has(currentNum + 1)) &#123;</span><br><span class="line">                currentNum += 1;</span><br><span class="line">                currentStreak += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return longestStreak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure><p>数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。就是逆波兰式那种题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">const decodeString = (s) =&gt; &#123;</span><br><span class="line">    let numStack = [];        // 存倍数的栈</span><br><span class="line">    let strStack = [];        // 存 待拼接的str 的栈</span><br><span class="line">    let num = 0;              // 倍数的“搬运工”</span><br><span class="line">    let result = &#x27;&#x27;;          // 字符串的“搬运工”</span><br><span class="line">    for (const char of s) &#123;   // 逐字符扫描</span><br><span class="line">        if (!isNaN(char)) &#123;   // 遇到数字</span><br><span class="line">            num = num * 10 + Number(char); // 算出倍数</span><br><span class="line">        &#125; else if (char == &#x27;[&#x27;) &#123;  // 遇到 [</span><br><span class="line">            strStack.push(result); // result串入栈</span><br><span class="line">            result = &#x27;&#x27;;           // 入栈后清零</span><br><span class="line">            numStack.push(num);    // 倍数num进入栈等待</span><br><span class="line">            num = 0;               // 入栈后清零</span><br><span class="line">        &#125; else if (char == &#x27;]&#x27;) &#123;  // 遇到 ]，两个栈的栈顶出栈</span><br><span class="line">            let repeatTimes = numStack.pop(); // 获取拷贝次数</span><br><span class="line">            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串</span><br><span class="line">        &#125; else &#123;                   </span><br><span class="line">            result += char;        // 遇到字母，追加给result串</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a>29. 两数相除</h2><p>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p><p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p><p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p><p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−2^31,  2^31 − 1] 。本题中，如果商 严格大于 2^31 − 1 ，则返回 2^31 − 1 ；如果商 严格小于 -2^31 ，则返回 -2^31 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int divide(int dividend, int divisor) &#123; // 被除数 除数</span><br><span class="line">        if(divisor == -1 &amp;&amp; dividend == Integer.MIN_VALUE) return Integer.MAX_VALUE; // 溢出</span><br><span class="line">        int sign = 1;</span><br><span class="line">        if((dividend &gt; 0 &amp;&amp; divisor &lt; 0)||(dividend &lt; 0 &amp;&amp; divisor &gt; 0))</span><br><span class="line">            sign = -1;</span><br><span class="line">       // if(divisor == 1) return dividend;</span><br><span class="line">        // if(divisor == -1) return -dividend;</span><br><span class="line">        int a = dividend&gt;0 ? -dividend : dividend;</span><br><span class="line">        int b = divisor&gt;0 ? -divisor : divisor;</span><br><span class="line">        // 都改为负号是因为int 的范围是[2^31, 2^31-1]，如果a是-2^32，转为正数时将会溢出</span><br><span class="line">        //System.out.println(a + &quot; &quot; + b);</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int ans = div(a,b);</span><br><span class="line">        return sign == -1 ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int div(int a, int b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a &gt; b) return 0;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int tb = b;</span><br><span class="line">        while(tb+tb &gt;= a &amp;&amp; tb+tb &lt; 0)&#123; // 溢出之后不再小于0</span><br><span class="line">            tb += tb;</span><br><span class="line">            count += count;</span><br><span class="line">            //System.out.println(tb + &quot; &quot; + count + &quot; &quot; + count*b);</span><br><span class="line">        &#125;</span><br><span class="line">        return count+div(a-tb,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-12-矩阵中的路径（回溯-visited使用-）"><a href="#剑指-Offer-12-矩阵中的路径（回溯-visited使用-）" class="headerlink" title="剑指 Offer 12. 矩阵中的路径（回溯[visited使用]）"></a>剑指 Offer 12. 矩阵中的路径（回溯[visited使用]）</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>思路与算法</strong></p><p>设函数 check(i,j,k) 表示判断以网格的 (i,j) 位置出发，能否搜索到单词 word[k..]，其中 word[k..] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。函数 check(i,j,k) 的执行步骤如下：</p><p>如果 board[i][j] &#x3D;s[k]，当前字符不匹配，直接返回 false。</p><p>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。</p><p>否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子串 word[k+1..]，则返回 true，否则返回 false。</p><p>这样，我们对每一个位置 (i,j) 都调用函数 check(i,j,0) 进行检查：只要有一处返回 true，就说明网格中能够找到相应的单词，否则说明不能找到。</p><p>为了防止重复遍历相同的位置，需要额外维护一个与 board 等大的 visited 数组，用于标识每个位置是否被访问过。每次遍历相邻位置时，需要跳过已经被访问的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var exist = function(board, word) &#123;</span><br><span class="line">    const h = board.length, w = board[0].length;</span><br><span class="line">    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];</span><br><span class="line">    const visited = new Array(h);</span><br><span class="line">    for (let i = 0; i &lt; visited.length; ++i) &#123;</span><br><span class="line">        visited[i] = new Array(w).fill(false);</span><br><span class="line">    &#125;</span><br><span class="line">    const check = (i, j, s, k) =&gt; &#123;</span><br><span class="line">        if (board[i][j] != s.charAt(k)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (k == s.length - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        let result = false;</span><br><span class="line">        for (const [dx, dy] of directions) &#123;</span><br><span class="line">            let newi = i + dx, newj = j + dy;</span><br><span class="line">            if (newi &gt;= 0 &amp;&amp; newi &lt; h &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; w) &#123;</span><br><span class="line">                if (!visited[newi][newj]) &#123;</span><br><span class="line">                    const flag = check(newi, newj, s, k + 1);</span><br><span class="line">                    if (flag) &#123;</span><br><span class="line">                        result = true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = false;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; h; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; w; j++) &#123;</span><br><span class="line">            const flag = check(i, j, word, 0);</span><br><span class="line">            if (flag) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">void backtrace(char** rec , int * recSize, int* vis, char * s , int i , int n , char* perm)&#123;</span><br><span class="line">    if(i == n)&#123;</span><br><span class="line">        char* tmp = malloc(sizeof(char) * (n+1));</span><br><span class="line">        strcpy(tmp,perm);</span><br><span class="line">        rec[(*recSize)++] = tmp;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=0 ; j&lt;n ; j++)&#123;</span><br><span class="line">        if(vis[j] || (j&gt;0&amp;&amp;!vis[j-1]&amp;&amp;s[j-1]==s[j]))&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[j] = true;</span><br><span class="line">        perm[i] = s[j];</span><br><span class="line">        backtrace(rec, recSize, vis, s, i + 1, n, perm);</span><br><span class="line">        vis[j] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmp(char* a,char *b)&#123;</span><br><span class="line">    return *a-*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char** permutation(char* s, int* returnSize)&#123;</span><br><span class="line">    int n = strlen(s);</span><br><span class="line">    int recMaxSize = 1;</span><br><span class="line">    for(int i =2 ; i&lt;=n ; i++)&#123;</span><br><span class="line">        recMaxSize*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    char **rec = malloc(sizeof(char*)*recMaxSize);</span><br><span class="line">    *returnSize = 0;</span><br><span class="line">    int vis[n];</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    char perm[n+1];</span><br><span class="line">    perm[n] = &#x27;\0&#x27;;</span><br><span class="line">    qsort(s,n,sizeof(char),cmp);</span><br><span class="line">    backtrace(rec, returnSize, vis, s, 0, n, perm);</span><br><span class="line">    return rec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-51-数组中的逆序对-归并排序"><a href="#剑指-Offer-51-数组中的逆序对-归并排序" class="headerlink" title="剑指 Offer 51. 数组中的逆序对(归并排序)"></a>剑指 Offer 51. 数组中的逆序对(归并排序)</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>题解</strong><br>merge_sort() 归并排序与逆序对统计：</p><ol><li><p>终止条件： 当 l≥r 时，代表子数组长度为 1 ，此时终止划分；</p></li><li><p>递归划分： 计算数组中点 m ，递归划分左子数组 merge_sort(l, m) 和右子数组 merge_sort(m + 1, r);</p></li><li><p>合并与逆序对统计：</p><ol><li>暂存数组 nums 闭区间 [i,r] 内的元素至辅助数组 tmp ；</li><li>循环合并： 设置双指针 i , j 分别指向左 &#x2F; 右子数组的首元素；<ol><li>当 i&#x3D;m+1 时： 代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j&#x3D;j+1 ；</li><li>否则，当 j&#x3D;r+1 时： 代表右子数组已合并完，因此添加左子数组当前元素 tmp[i] ，并执行 i&#x3D;i+1 ；</li><li>否则，当 tmp[i]≤tmp[j] 时： 添加左子数组当前元素 tmp[i] ，并执行 i&#x3D;i+1；</li><li>否则（即 tmp[i]&gt;tmp[j]）时： 添加右子数组当前元素 tmp[j] ，并执行 j&#x3D;j+1 ；此时构成 m−i+1 个「逆序对」，统计添加至 res ；</li></ol></li></ol></li><li><p>返回值： 返回直至目前的逆序对总数 res ；</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int mergeSort(int l, int r , int* nums, int* tmp)&#123;</span><br><span class="line">     // 终止条件</span><br><span class="line">    if(l&gt;=r) return 0;</span><br><span class="line">     // 递归划分</span><br><span class="line">    int m = (l+r)/2;</span><br><span class="line">    int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp);</span><br><span class="line">     // 合并阶段</span><br><span class="line">    int i = l, j = m + 1;</span><br><span class="line">        for (int k = l; k &lt;= r; k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        for (int k = l; k &lt;= r; k++) &#123;</span><br><span class="line">            if (i == m + 1)</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">            else if (j == r + 1 || tmp[i] &lt;= tmp[j])</span><br><span class="line">                nums[k] = tmp[i++];</span><br><span class="line">            else &#123;</span><br><span class="line">                nums[k] = tmp[j++];</span><br><span class="line">                res += m - i + 1; // 统计逆序对</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int reversePairs(int* nums, int numsSize)&#123;</span><br><span class="line">    int * tmp = malloc(sizeof(int) * numsSize);</span><br><span class="line">    return mergeSort(0,numsSize-1,nums,tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    struct TreeNode* ancestor = root;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;left;</span><br><span class="line">        &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;</span><br><span class="line">            ancestor = ancestor-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ancestor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;</span><br><span class="line">    /* 当前节点为p、q、NULL都返回本身即可 */</span><br><span class="line">    if (root == q || root == p || !root) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 递归处理左子树 */</span><br><span class="line">    struct TreeNode* left  = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    /* 递归处理右子树 */</span><br><span class="line">    struct TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    /* 处理当前根节点 */</span><br><span class="line">    /* 当前节点左右子树均不为NULL，则找到公共祖先 */</span><br><span class="line">    if (left != NULL &amp;&amp; right != NULL) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if (left == NULL &amp;&amp; right != NULL) &#123;    /* 左子树未发现p、q、右子树发现p、q */</span><br><span class="line">        return right;</span><br><span class="line">    &#125; else if (left != NULL &amp;&amp; right == NULL) &#123; /* 右子树未发现p、q、左子树发现p、q */</span><br><span class="line">        return left;</span><br><span class="line">    &#125; else  &#123;   /* 左、右子树均未发现p、q */</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022总结</title>
      <link href="/post/20bbe8e4.html"/>
      <url>/post/20bbe8e4.html</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>从8月份开始博客就停摆了，期间一直在图书馆准备考研，结果在考前两天又阳了，发挥的很一般，只能说今年是有那么一点不顺利了。<br>回顾整个2022，感觉还是不太满意的，很多自己想学的想干的都因为种种原因而搁浅，从去年12月到上半年的4月份，自己其实是没有读研的想法的，一直想着找份工作先干几年再考虑读研的问题。而这个计划胎死腹中则是因为在腾讯面试的过程中根本没有给我去总部的机会，而是直接将我的简历分到了腾讯云那边，我自己又有点眼高手低，觉得还是读个研究生再来找工作可能会好一点随后就放弃了找工作的计划(现在想想还是有那么一点后悔，毕竟2年后的形式可能会更差，春招也得搏一搏了)<br>2022感觉自己没有做成什么事情，最后的初试也不知道能不能通过，只是在整个2022种下了一系列的因，希望在2023能结一些好的果吧。</p><h2 id="展望一下"><a href="#展望一下" class="headerlink" title="展望一下"></a>展望一下</h2><p>2023当然最想的就是上岸了，说实话想一想科软的培养方案，我就很心动，如果今年失利，后面肯定还会继续尝试。然后呢，则是给自己再定几个目标：一个是先把力扣刷明白，明年至少做500题吧；二是把开发搞明白，然后再学一点高并发和图形学的东西，都是我很感兴趣但是因为各种原因搁置的知识；三是过的轻松点吧，指的是心态上，别逼自己太紧了，感觉最后这一个月保持的就还不错，虽然临近考研，还有毕设开题，阳了，胃病，莫名其妙头晕等一系列乱七八糟的东西，但是心态一直不错，希望2023不顺的事少一点，心态也放平一点。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>最后，还是想感谢家人朋友和同学吧，生活为啥是生活，就来源于身边人的力量吧，谢谢大家，希望2023大家都越来越好。</p>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http的8种请求方法</title>
      <link href="/post/1e0e1e64.html"/>
      <url>/post/1e0e1e64.html</url>
      
        <content type="html"><![CDATA[<h2 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h2><p><strong>8种：GET、HEAD、POST、PUT、DELETE、OPTIONS、TRACE、PATCH</strong><br>根据RFC2616第九章说明，http方法的定义有两点：safe and Idempotent，即安全性和幂等性，可以结合这两点对以上方法进行说明。</p><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>特点：安全、幂等。<br>说明：从服务器端获取数据，请求body在地址栏上。<br>作用：获取资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>特点：安全、幂等。<br>说明：与get方法类似，但不返回message body内容，仅仅是获得获取资源的部分信息（content-type、content-length）。<br>作用：restful框架中较少使用。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>特点：非安全、非幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据要重新新创建。<br>作用：用于创建子资源。创建、更新、删除、查询资源均可使用。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个修改数据的请求，需求数据更新（全部更新）。<br>作用：用于创建、更新资源。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>发送一个删除数据的请求。<br>作用：删除资源。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>特点：安全、幂等。<br>作用：用于url验证，验证接口服务是否正常。</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>特点：安全、幂等。<br>说明：维基百科“回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现。”<br>作用：restful框架中较少使用。</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>特点：非安全、幂等。<br>说明：向服务器端提交数据，请求数据在报文body里；<br>与PUT类似，发送一个修改数据的请求，区别在于PATCH代表部分更新；<br>后来提出的接口方法，使用时可能去要验证客户端和服务端是否支持；<br>作用：用于创建、更新资源。局部更新，比如：user对象，只更改了name属性，那么他的其他属性值是不会变的，如果用post，那么其他属性值会被设置为null（全局更新）</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</span><br><span class="line">比如:GET http://www.bank.com/account/123456,不会改变资源的状态，不论调用一次还是N次都没有副作用。</span><br><span class="line">请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</span><br><span class="line">GET http://www.news.com/latestnews这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</span><br><span class="line"></span><br><span class="line">HTTP DELETE方法用于删除资源，有副作用,但它应该满足幂等性。比如: DELETE http://www.forum.com/article/4231,</span><br><span class="line">调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子;因此，调用者可以多次调用或刷新页面而不必担心引起错误。</span><br><span class="line"></span><br><span class="line">重点来了：比较容易混淆的是HTTP的 POST和PUT。POST和PUT的区别容易被简单地误认为&quot;POST表示创建资源，PUT表示更新资源”;</span><br><span class="line">而实际上,二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的:</span><br><span class="line">POST所对应的URI并非创建的资源本身，而是资源的接收者。</span><br><span class="line">比如: POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。</span><br><span class="line">两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI; 所以，POST方法不具备幂等性。</span><br><span class="line">而PUT所对应的URI是要创建或更新的资源本身。</span><br><span class="line">比如: PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。</span><br><span class="line">对同一URI进行多次PUT的副作用和一次PUT是相同的;因比，PUT方法具有幕等性。</span><br><span class="line"></span><br><span class="line">在介绍了几种操作的语义和幂等性之后,我们来看看如何通过Web API的形式实现前面所提到的取款功能。</span><br><span class="line">很简单，POST /tickets来实现create_ticket;用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent _withdraw。</span><br><span class="line">值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_ id/ticket_id,而amount应该放在请求的body中。</span><br><span class="line">这种模式可以应用于很多场合，比如:论坛网站中防止意外的重复发帖。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extra-bbs开发项目</title>
      <link href="/post/9a9a747.html"/>
      <url>/post/9a9a747.html</url>
      
        <content type="html"><![CDATA[<h3 id="项目总述"><a href="#项目总述" class="headerlink" title="项目总述"></a>项目总述</h3><p>一个社区论坛形式的项目，有点类似贴吧，知乎。分为web应用前端live，后端sever以及后台管理系统admin。<br><img src="/img/extrabbs.png" alt="extra_bbs"></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>前端技术栈</p></blockquote><p><code>vue</code> <code>vuex</code> <code>vue-router</code></p><p>其中也涉及到一些依赖，比如sweetalert等等<br>repository: <a href="https://github.com/V1per3/Extra-BBS-live">https://github.com/V1per3/Extra-BBS-live</a></p><h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>技术栈</p></blockquote><p><code>node</code> + <code>koa2</code> + <code>koa-router</code> + <code>ES6</code> + <code>mysql</code> + <code>mongodb</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-server">https://github.com/V1per3/Extra-BBS-server</a></p><h4 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">└── PPAP.server</span><br><span class="line">    ├── config <span class="comment"># 配置文件</span></span><br><span class="line">    │   └── index.js  </span><br><span class="line">    ├── controller <span class="comment"># 操作层 验证视图层用户输入，调用业务层方法，json接口返回数据</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── model <span class="comment"># 数据模型层 执行数据操作</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── router <span class="comment"># 路由层 控制路由</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── service <span class="comment"># 业务层 操作数据层，对业务逻辑进行处理，将结果返回控制层</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── sql <span class="comment"># 数据表sql</span></span><br><span class="line">    │   └── init.sql</span><br><span class="line">    ├── util <span class="comment"># 工具函数</span></span><br><span class="line">    │   └── index.js</span><br><span class="line">    ├── app.js <span class="comment"># 入口文件</span></span><br><span class="line">    ├── package.json </span><br><span class="line">    ├── README.md</span><br><span class="line">    └── yarn.lock</span><br></pre></td></tr></table></figure><h4 id="构建步骤-1"><a href="#构建步骤-1" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn dev</span><br></pre></td></tr></table></figure><h3 id="后台管理系统"><a href="#后台管理系统" class="headerlink" title="后台管理系统"></a>后台管理系统</h3><blockquote><p>技术栈</p></blockquote><p><code>react</code> + <code>ant-design UI</code></p><p>repository: <a href="https://github.com/V1per3/Extra-BBS-admin">https://github.com/V1per3/Extra-BBS-admin</a></p><h4 id="构建步骤-2"><a href="#构建步骤-2" class="headerlink" title="构建步骤"></a>构建步骤</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 线性表</title>
      <link href="/post/aeec3311.html"/>
      <url>/post/aeec3311.html</url>
      
        <content type="html"><![CDATA[<h2 id="线性表的定义与基本操作"><a href="#线性表的定义与基本操作" class="headerlink" title="线性表的定义与基本操作"></a>线性表的定义与基本操作</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><ol><li>线性表是具有<strong>相同</strong>数据类型的n(n&gt;&#x3D;0)个数据元素的<strong>有限序列</strong>，其中n为表长，当n&#x3D;0时线性表是一个空表。</li><li>若用L命名线性表，则其一般表示为L&#x3D;(a1,a2,…,ai,ai+1,…an)</li><li>表达式中a1是唯一<strong>第一个</strong>数据元素，又称为表头元素；an是唯一的<strong>最后一个</strong>数据元素，又称为表尾元素。</li><li>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后驱。<br><strong>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆</strong></li></ol><h3 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InitList(&amp;L): 初始化表。构造一个空的线性表。</span><br><span class="line">Length(L): 求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e): 按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetElem(L,i): 按位查找操作。获取表L中第i个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e): 插入操作。在表L中的第i个位置上插入指定元素e。</span><br><span class="line">ListDelete(&amp;L,i,&amp;e): 删除操作。删除表中L中第i个位置的元素，并用e返回删除的元素。</span><br><span class="line">PrintList(L): 输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L): 判空操作。若L为空表，则返回true，否则返回false。</span><br><span class="line">DestroyList(&amp;L): 销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><p><strong>注意：基本操作的具体实现取决于采用哪种存储结构（见下图）,存储结构不同，算法的实现也不同.”&amp;”表示C++语言中的引用调用,在c语言中采用指针也可以达到相同的效果.后续文章中两种方式都会使用.</strong></p><p><img src="/img/sujgxxb1.png"></p><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p><p>假定线性表的元素类型为ElemType,则线性表的顺序存储类型描述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 10  //定义顺序表的最大长度，在声明数组时使用</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];//顺序表的数据元素</span><br><span class="line">    int length;//顺序表的当前长度</span><br><span class="line">&#125;Sqlist;//顺序表的类型定义</span><br></pre></td></tr></table></figure><p>一维数组可以是静态分配的，也可以是动态分配的。在静态分配时，由于数组的大小和空间事先已经固定好，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序奔溃甚至引起其他未知异常。</p><p>而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦存储空间占满，就另外开辟一块更大的存储区间，将原来的元素复制过去，从而达到扩充存储数组空间的目的，而不需要一次性分配很大的空间。<br>C语言的初始动态分配语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure><p>C++语言的初始化动态分配语句为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data=new ElemType[InitSize];</span><br></pre></td></tr></table></figure><p><strong>注意：动态存储并不是链式存储，它同样属于顺序存储，物理结构没有变化，还是和逻辑结构一样保持相邻，只是分配的空间不再是编译器决定，而是运行时分配。</strong></p><h3 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h3><p>随机访问：可通过首地址和元素序号在单位时间O(1)内找到指定的元素。</p><p>存储密度高：存储密度高是因为每个结点存储空间指用来存储数据元素，没有别的额外开销。</p><p>物理位置相邻：物理位置和逻辑位置一样，保持相邻，因此插入和删除元素需要移动大量元素，比较耗时。这是物理结构相邻的所有数据结构的通病，虽然访问快，但是如果有频繁的增删移动操作，就会效率很低。</p><h3 id="顺序表上的基本操作"><a href="#顺序表上的基本操作" class="headerlink" title="顺序表上的基本操作"></a>顺序表上的基本操作</h3><p>仅展示查、增、删三种操作，其余的在线性表中较为简单，在后续更复杂的链表中展示。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>在顺序表L的第i（1&lt;&#x3D;i&lt;&#x3D;L.length+1）位插入新元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool ListInsert(SqList &amp;L, int i, ElemType e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length + 1)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    if (L.length &gt;= MaxSize)   //判断是否超出存储空间</span><br><span class="line">        return false;</span><br><span class="line">    for (int j = L.length; j &gt;= i; j--)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j - 1];</span><br><span class="line">    L.data[i - 1] = e;   //在第i位插入元素e</span><br><span class="line">    L.length++;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：在表尾插入（即i&#x3D;n+1）,原本的元素不移动，时间复杂度为O(1)。</p><p>最坏情况：在表头插入（即i&#x3D;1），所有元素需要后移一位，元素后移语句执行n次，时间复杂度为O(n)。</p><p>平均情况：假设Pi(Pi&#x3D;1&#x2F;(n+1))是在第i个位置上插入一个结点的概率，则在长度为n的顺序表中插入一个结点时，所需要移动结点的平均次数为n&#x2F;2，时间复杂度为O(n)。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除顺序表L中第i（1&lt;&#x3D;i&lt;&#x3D;L.length）个位置的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L, int i, ElemType&amp; e) </span><br><span class="line">&#123;</span><br><span class="line">    if (i&lt;1 || i&gt;L.length)  //判断i要插入的位置是否有效</span><br><span class="line">        return false;</span><br><span class="line">    e = L.data[i - 1];     //保存要删除的数据到e</span><br><span class="line">    for (int j = i-1; j &lt;= L.length; ++j)  //将第i个元素以及之后的元素后移一位</span><br><span class="line">        L.data[j] = L.data[j + 1];</span><br><span class="line">    L.length--;     //顺序表长度加1</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度与插入一样（平均时间复杂度上，插入始终每一步比删除多一次操作，即插入操作，但是不会引起量级变化，所以平均时间复杂度依旧为O(N)）</p><h4 id="按值查找（顺序查找）操作"><a href="#按值查找（顺序查找）操作" class="headerlink" title="按值查找（顺序查找）操作"></a>按值查找（顺序查找）操作</h4><p>在顺序表中查找第一个元素值等于e的元素的位置，未查找到返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L,const ElemType &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; L.length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        if (L.data[i] == e)</span><br><span class="line">        &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：在表头找到（即i&#x3D;1）,时间复杂度为O(1)。</p><p>最坏情况：在表尾插入（即i&#x3D;n），时间复杂度为O(n)。</p><p>平均情况：时间复杂度为O(n)。</p><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><p>逻辑上相邻的元素在物理位置上不一定相邻。<br>优点：</p><ol><li>没有了顺序存储所具有的弱点（也就是说：插入和删除不需要移动元素，而只需要修改指针。）</li><li>同时，由于不借助数组实现，在定义链表时，无需指定它的长度。</li></ol><p>缺点：<br>也失去了顺序存储的优点</p><ol><li>非随机存取（不能直接找到某个特定序号的结点，需要从表头开始遍历）</li><li>存储密度降低（除了存储本身信息外链表还要存储指针）</li></ol><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><p>线性表的链式存储又称为单链表，它是指通过一组任意的存储单位来存储线性表中的元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素的自身信息外，还需要存放一个指向其后继的指针。</p><p>由于逻辑上相邻的元素在物理位置上不一定相邻，那么我们如何确定下一个元素的存储位置呢？<br><strong>解决办法，增加一个变量。用来存储一个指示其后继位置的指针。</strong><br>我们把这两部分的信息组成数据元素a的存储映像，称为<strong>结点</strong>。它包含两个域，其中存储数据元素信息的域称为<strong>数据域</strong>，存储直接后继存储位置的域称为<strong>指针域</strong>。</p><p>单链表中结点定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123; //定义单链表节点类型</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct LNode *next;//指针域</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>头指针</strong><br>整个链表的存储<strong>必须从头指针开始</strong><br>头指针指示链表中第一个结点的存储位置<br>同时，由于最后一个数据元素没有直接后继，则单链表中最后一个一个结点的指针为NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//头指针定义1</span><br><span class="line">LinkList L;</span><br><span class="line">//头指针定义2</span><br><span class="line">LNode *L;</span><br></pre></td></tr></table></figure><p><strong>头结点</strong><br>在单链表的第一个结点之前附设一个结点，称为头结点。<br>头结点的数据域可以不存储任何信息，也可以存储如线性表的长度之类的附加信息。<br>头结点的指向第一个结点的指针（即第一个元素结点的存储位置）<br>此时，单链表的头指针指向头结点。<br><img src="/img/sujgxxb2.png"></p><p><strong>空表</strong><br>含头结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L-&gt;next==NULL时为空表</span><br></pre></td></tr></table></figure><p>不含头结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkList L;</span><br><span class="line">L==NULL时为空表；</span><br></pre></td></tr></table></figure><h3 id="单链表上具体操作的实现和时间复杂度"><a href="#单链表上具体操作的实现和时间复杂度" class="headerlink" title="单链表上具体操作的实现和时间复杂度"></a>单链表上具体操作的实现和时间复杂度</h3><h4 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h4><p>构造一个空表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int InitList_Link(LinkList *L)&#123;</span><br><span class="line">    *L=(LinkList)malloc(sizeof(LNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">时间复杂度为O(1)</span><br></pre></td></tr></table></figure><h4 id="根据数组创建单链表"><a href="#根据数组创建单链表" class="headerlink" title="根据数组创建单链表"></a>根据数组创建单链表</h4><h5 id="含头结点的单链表"><a href="#含头结点的单链表" class="headerlink" title="含头结点的单链表"></a>含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点指向第一个结点</span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该结点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        r=s;//r移动到链表尾端</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不含头结点的单链表"><a href="#不含头结点的单链表" class="headerlink" title="不含头结点的单链表"></a>不含头结点的单链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//头插法</span><br><span class="line">int create_HeadInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line">    *L=NULL;</span><br><span class="line">    LNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            *L=s;//头指针指向插入结点</span><br><span class="line">            s-&gt;next=NULL;//倒序插入，最后一个结点的指针域赋值为NULL</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            s-&gt;next=*(L);//新插入的结点指向第一个结点</span><br><span class="line">            *(L)=s;//头指针指向新的插入节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//尾插法</span><br><span class="line">int create_TailInsert(LinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_Link(L);</span><br><span class="line">    (*L)=NULL;</span><br><span class="line">    LNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        if((*L)==NULL)&#123;//对第一个结点需要特殊处理</span><br><span class="line">            (*L)=s;//头指针指向第一个结点</span><br><span class="line">            r=s;//尾指针移动到最后一个结点</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">            r=s;//r移动到链表尾端</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>含头结点优点：</p><ol><li>使得链表第一个结点的操作和其他位置一样，无需特殊处理。</li></ol><p>含头结点缺点：</p><ol><li>头结点的数据域一般不存储数据，该空间被浪费。</li></ol><p>时间复杂度：</p><ol><li>每个结点插入的时间为O(1),设表长为n，所有方式的时间复杂度均为O(n)</li></ol><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int Length_Link(LinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        L=L-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：设表长为n,时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h4><p>在表L中的第i个位置上插入指定元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListInsert_Link(LinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(LinkList)malloc(sizeof(LNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int ListDelete_Link(LinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    LNode *p=(*L);//p指向头结点</span><br><span class="line">    LNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="按位查找操作"><a href="#按位查找操作" class="headerlink" title="按位查找操作"></a>按位查找操作</h4><p>获取表L中第i个位置的元素的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int GetElem_List(LinkList L,int i,ElemType *e)&#123;</span><br><span class="line">    LNode *p=L; //p指向头结点</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (p&amp;&amp;j&lt;i)&#123;//找到第i个位置</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!(p)||i&lt;1)  return FALSE; //i不在有效范围内</span><br><span class="line">    *e=p-&gt;data; //把第i个结点的值用e返回</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="按值查找操作"><a href="#按值查找操作" class="headerlink" title="按值查找操作"></a>按值查找操作</h4><p>在表L中查找具有给定关键字值的元素,返回序号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem_List(LinkList L,ElemType e,int *i)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    while (L-&gt;next!=NULL)&#123;//遍历链表</span><br><span class="line">        L=L-&gt;next;//向后移动</span><br><span class="line">        j++;//序号加一</span><br><span class="line">        if (L-&gt;data.id==e.id)&#123;//这里我们只用id来判断元素的值是否相等，假设id唯一</span><br><span class="line">            *i=j;//如果相等，用i返回序号</span><br><span class="line">            return TRUE;//查找成功</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h4 id="销毁表"><a href="#销毁表" class="headerlink" title="销毁表"></a>销毁表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DestroyList(LinkList *L)&#123;</span><br><span class="line">    while((*L)-&gt;next!=NULL) &#123;//遍历链表</span><br><span class="line">    LNode *p=(*L)-&gt;next;//p指示头结点的下一个，要被删除的结点</span><br><span class="line">    (*L)-&gt;next=p-&gt;next;//让头结点指向p的下一个，把p从链表断开</span><br><span class="line">    free(p);//删除p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表结点中只有一个指向其后继结点的指针，使得单链表只能从头结点依次顺序地向后遍历。<br>要访问某个结点的前驱结点，只能从头开始遍历。<br>也就是说：访问后继结点的时间复杂度为O(1),访问前驱结点的时间复杂度为O(n)</p><p><strong>为了克服单链表的上述缺点，引入了双链表。</strong><br><strong>双链表中有两个指针prior和next，分别指向其前驱结点和后继结点</strong></p><h4 id="双链表的定义"><a href="#双链表的定义" class="headerlink" title="双链表的定义"></a>双链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DNode&#123;</span><br><span class="line">    ElemType data;//数据域</span><br><span class="line">    struct DNode *prior;//前驱指针</span><br><span class="line">    struct DNode *next;//后继指针</span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure><p><img src="/img/sujgxxb3.png"></p><h4 id="双链表上具体操作的实现和时间复杂度"><a href="#双链表上具体操作的实现和时间复杂度" class="headerlink" title="双链表上具体操作的实现和时间复杂度"></a>双链表上具体操作的实现和时间复杂度</h4><p>使用含头结点的双链表</p><h5 id="初始化表-1"><a href="#初始化表-1" class="headerlink" title="初始化表"></a>初始化表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitList_DLink(DLinkList *L)&#123;</span><br><span class="line">    *L=(DLinkList)malloc(sizeof(DNode));//创建头结点，并让头指针指向头结点</span><br><span class="line">    if (!(*L)) return FALSE;//分配失败</span><br><span class="line">    (*L)-&gt;prior=NULL;//头结点的prior永远指向NULL</span><br><span class="line">    (*L)-&gt;next=NULL;//初始化为空</span><br><span class="line">    return TRUE;//初始化成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度为O(1)</span><br></pre></td></tr></table></figure><h5 id="根据数组创建双链表"><a href="#根据数组创建双链表" class="headerlink" title="根据数组创建双链表"></a>根据数组创建双链表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*头插法创建双链表*/</span><br><span class="line">int create_HeadInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s;//用来指示新创建的结点</span><br><span class="line">    int i;</span><br><span class="line">    for(i=n-1;i&gt;=0;i--)&#123;//由于D头插法是倒序插入，所以这里我们从数组最后开始遍历</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        s-&gt;next=(*L)-&gt;next;//让该结点的后继指向第一个结点</span><br><span class="line">        if((*L)-&gt;next!=NULL) (*L)-&gt;next-&gt;prior=s;//第一个结点的前驱指向该结点</span><br><span class="line">        s-&gt;prior=(*L);//让该结点的前驱指向头结点   </span><br><span class="line">        (*L)-&gt;next=s;//让头结点指向该D结点（该结点成为第一个结点）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*尾插法创建双链表*/</span><br><span class="line">int create_TailInsert(DLinkList *L,ElemType a[],int n)&#123;</span><br><span class="line"> // InitList_DLink(L);</span><br><span class="line">    DNode *s,*r=(*L); //s用来指示新创建的结点，r用来移动以连接链表</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;//遍历数组</span><br><span class="line">        s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">        s-&gt;data=a[i];//为结点赋值</span><br><span class="line">        r-&gt;next=s;//r始终指向链表的尾端，这里将新结点连接到r的后面</span><br><span class="line">        s-&gt;prior=r;//该结点的前驱指向r指向的结点</span><br><span class="line">        r=s;//r移动到链表尾端o</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NULL;//结束时，最后一个结点的指针域赋值为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每个结点插入的时间为O(1),设表长为n,所有方式的时间复杂度均为O(n)</span><br></pre></td></tr></table></figure><h5 id="插入操作-2"><a href="#插入操作-2" class="headerlink" title="插入操作"></a>插入操作</h5><p>在表L中的第i个位置上插入指定元素e。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_DLink(DLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(!p||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(DLinkList)malloc(sizeof(DNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    if (p-&gt;next!=NULL) p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前D驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后插入新结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><h5 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h5><p>删除表中L中第i个位置的元素，并用e返回删除的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*删除*/</span><br><span class="line">int ListDelete_DLink(DLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    DNode *p=(*L);//p指向头结点</span><br><span class="line">    DNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    if(q-&gt;next!=NULL)q-&gt;next-&gt;prior=p;</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br><span class="line">//时间复杂度：在给定的结点后删除结点的时间复杂度为O(1),查找第i-1个节点的时间复杂度为O(n)</span><br><span class="line">//综上：时间复杂度为O(n)</span><br></pre></td></tr></table></figure><p>其他操作与单链表一样，不展示</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>特点：表中最后一个结点的指针域指向头结点，整个链表形成一个环。<br>既然是环的话，那就不难想象，从表中任意一个结点出发都可以找到表中其他结点。</p><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表与单链表唯一的区别就是多了一个由尾结点指向头结点的指针。<br>所以循环链表的操作与单链表基本一致<br>唯一的差别就是<strong>循环的条件不是p或p-&gt;next是否为空，而是它们是否等于头指针</strong><br>($p&#x3D;&#x3D;L或p-&gt;next&#x3D;&#x3D;L$)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int Length_CLink(CLinkList L)&#123;</span><br><span class="line">    int i=0;//空表返回0</span><br><span class="line">    CNode *s=L;</span><br><span class="line">    while (s-&gt;next!=L)&#123;//遍历，直到尾结点，空表不进入循环</span><br><span class="line">        s=s-&gt;next;//向后移动一个</span><br><span class="line">        i++;//表长加一</span><br><span class="line">    &#125;</span><br><span class="line">    return i;//返回表长</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>循环双链表与循环单链表唯一的区别就是多了一个指向前驱的指针。<br>所以循环双链表的操作与循环单链表也基本一致<br>就是<strong>对结点操作时，需要多操作一步，让p-&gt;prior指向前驱结点。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*插入*/</span><br><span class="line">int ListInsert_CDLink(CDLinkList *L,int i,ElemType e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *s;//s用来指示新创建的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到被插入序号的前一个位置</span><br><span class="line">       p=p-&gt;next;//向后移动一个</span><br><span class="line">       j++; </span><br><span class="line">    &#125;</span><br><span class="line">    if(p==(*L)||(i-j)&gt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    s=(CDLinkList)malloc(sizeof(CDNode));//创建一个新结点</span><br><span class="line">    s-&gt;data=e;//赋值</span><br><span class="line">    s-&gt;next=p-&gt;next;//让该结点指向p（插入位置的前一个结点）的下一个结点</span><br><span class="line">    p-&gt;next-&gt;prior=s;//让p的下一个结点的前驱指向该结点</span><br><span class="line">    s-&gt;prior=p;//让该结点的前驱指向p</span><br><span class="line">    p-&gt;next=s; //让p指向该结点  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*删除*/</span><br><span class="line">int ListDelete_CDLink(CDLinkList *L,int i,ElemType *e)&#123;</span><br><span class="line">    int j=0;//空表序号为0</span><br><span class="line">    CDNode *p=(*L);//p指向头结点</span><br><span class="line">    CDNode *q;//q用来指向被删除的结点</span><br><span class="line">    while (p-&gt;next!=(*L)&amp;&amp;j&lt;i-1)&#123;//找到要被删除结点的前一个结点</span><br><span class="line">        p=p-&gt;next;//向后移动一个</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((p-&gt;next)==(*L)||i&lt;1) return FALSE;//序号在无效范围内</span><br><span class="line">    q=p-&gt;next;//让q指向被删除的结点</span><br><span class="line">    p-&gt;next=q-&gt;next;//让p（被删除结点的前一个结点）指向被删除结点的下一个结点，q从链表中断开</span><br><span class="line">    q-&gt;next-&gt;prior=p;//让删除结点的下一个结点的前驱指向p；</span><br><span class="line">    *e=q-&gt;data;//把被删除的结点的值返回</span><br><span class="line">    free(q);//释放该结点</span><br><span class="line">    return TRUE; //删除成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>众所周知，指针是c语言的灵魂，指针使得链表的实现简单明了起来。但是问题来了，在c语言还没有的时代，又想描述链表，怎么办呢？<br>这就有了静态链表</p><h4 id="静态链表的设计"><a href="#静态链表的设计" class="headerlink" title="静态链表的设计"></a>静态链表的设计</h4><p>首先，我们来解决一个最重要的问题，没有指针，怎么表示下一个元素的位置呢？</p><p>当时的人们想出来的办法便是，用数组的下标来代替指针。我们把这个数组的下标叫做游标。</p><p>第二个问题，当我们要往数组里插入元素时，如何确定数组里哪些分量未被使用，要插到哪个位置上呢？当我们删除一个元素的时候，要把这个删除后已经不存放数据的数组分量链接到哪里去，然后再次被使用呢？</p><p>解决办法是将所有未被使用过的以及被删除的分量用一个游标链成一个备用链表。<br>每当进行插入的使用便从备用链表上取得第一个结点作为待插入的新结点。<br>反之，在删除时将从链表中删除下来结点链接到备用链表上。</p><p>有没有觉得上面的描述特别熟悉，这实际上就是C语言里面malloc函数和free函数做的事情，在静态链表中，我们得自己实现，不过操作起来也不复杂。</p><p>最后一个问题，我们现在已经知道了我们把静态链表分为两部分，一部分存放数据，一部分不存放数据，我们称之为备用链表。那么我们如何标识这两部分呢？</p><p>解决办法，我们这里把数组下标为0位置的游标用来存放备用链表的第一个元素（也就是数组中第一个不存放数据的元素）的下标<br>我们这里把数组下标为1的位置游标用来存放第一个数据不为空的元素的下标<br>这里还有个细节就是我们把游标为0设为这两部分的结束。</p><h4 id="静态链表的定义"><a href="#静态链表的定义" class="headerlink" title="静态链表的定义"></a>静态链表的定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ElemType char//这里我们使用的例子，采取字符</span><br><span class="line">#define MaxSize 10  //链表的最大长度</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data;//存储的数据元素</span><br><span class="line">    int next;//游标，用来指示下一个数组分量的下标</span><br><span class="line">&#125;SLinkList[MaxSize];//静态链表</span><br></pre></td></tr></table></figure><h4 id="静态链表的操作"><a href="#静态链表的操作" class="headerlink" title="静态链表的操作"></a>静态链表的操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*初始化*/</span><br><span class="line">int InitSpace_SL(SLinkList space)&#123; </span><br><span class="line">  int i;</span><br><span class="line">  for (i = 2; i &lt; MaxSize-1; i++)&#123;</span><br><span class="line">      space[i].data=&#x27; &#x27;;</span><br><span class="line">      space[i].next=i+1;</span><br><span class="line">  &#125;</span><br><span class="line">  space[0].next=2;</span><br><span class="line">  space[0].data=&#x27; &#x27;;</span><br><span class="line">  space[1].next=0;</span><br><span class="line">  space[1].data=&#x27; &#x27;;</span><br><span class="line">  space[MaxSize-1].next=0;</span><br><span class="line">  space[MaxSize-1].data=&#x27; &#x27;;</span><br><span class="line">  return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求表长-1"><a href="#求表长-1" class="headerlink" title="求表长"></a>求表长</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*求表长*/</span><br><span class="line">int ListLength(SLinkList space)&#123;</span><br><span class="line">    int length=0;//空表长度为0</span><br><span class="line">    int i=space[1].next;//指向第一个有数据的位置</span><br><span class="line">    while (i!=0)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        i=space[i].next;//相当于指针的p=p-&gt;next</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的操作便是遍历表：<br>这里的i&#x3D;space[i].next;相当于指针的p&#x3D;p-&gt;next</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>尽管我们现在有了单链表，也不再会使用静态链表了，但是它的思想还是挺神奇的。<br>总的来说，它和单链表很像，插入删除不需要移动元素，所有我们称之为静态链表。<br>但是它不仅有单链表不能随机存取的缺点，也没有解决连续分配（数组）带来的表长难以确定的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构 绪论</title>
      <link href="/post/146816a0.html"/>
      <url>/post/146816a0.html</url>
      
        <content type="html"><![CDATA[<p><strong>程序&#x3D;数据结构+算法</strong><br><img src="/img/sujgxl.png"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>数据 数据元素和数据项<br>数据对象：具有相同性质的数据元素的集合，是数据的一个子集<br>数据结构：相互之间存在一种或多种特定关系的数据元素的集合<br>数据类型：值的集合和定义在此集合上的一组操作的总称（原子类型和结构类型）<br>抽象数据类型（Abstract Data Type）：是抽象数据组织及与之相关的操作，数学化的语言定义数据的逻辑结构、定义运算。与具体的实现无关。</p><h4 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h4><p>逻辑结构 存储结构 运算</p><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5><p>线性结构：线性表、栈、队列、数组<br>非线性结构：集合、树、图</p><h5 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h5><p>指数据结构在计算机中的表示或映像。存储结构会影响数据运算的速度、存储空间分配的方便与否<br><strong>常用存储结构：</strong><br>顺序存储（下面三种为非顺序存储）<br>链式存储<br>索引存储：附加一个索引表（索引项&#x3D;关键字+地址）<br>散列存储（哈希存储）：根据元素的关键字计算该元素的存储地址</p><h5 id="数据运算"><a href="#数据运算" class="headerlink" title="数据运算"></a>数据运算</h5><p>每个逻辑结构都有自己的基本的数据运算<br><strong>运算的定义是针对逻辑结构的，指出运算的功能</strong><br><strong>运算的实现是针对存储结构的，指出运算的具体操作步骤（即不同存储结构有着不同的实现）</strong></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="五个特性"><a href="#五个特性" class="headerlink" title="五个特性"></a>五个特性</h5><p>有穷性：算法必须是有穷的，而程序可以是无穷的<br>确定性：相同的输入只能得出相同的输出<br>可行性：能通过基本操作实现算法<br>输入<br>输出：算法处理的结果</p><h5 id="优秀算法的标准"><a href="#优秀算法的标准" class="headerlink" title="优秀算法的标准"></a>优秀算法的标准</h5><p>正确性<br>可读性<br>健壮性：能处理异常状况<br>高效率与低存储</p><h4 id="算法效率量度"><a href="#算法效率量度" class="headerlink" title="算法效率量度"></a>算法效率量度</h4><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><p>事前预估算法时间开销T(n)与问题规模n的关系（T表示“time”）<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>助记：常对幂指阶</strong><br><strong>一般只需挑循环中的一个基本操作分析它的执行次数与n的关系即可，如果有多层嵌套循环，只需关注最深层循环循环了几次</strong><br><strong>存在不同情况讨论时，平均时间复杂度&#x3D;各个情况的循环次数与概率的加权和</strong><br>可以只考虑阶数高的部分<br>问题规模足够大时，常数项可以忽略<br>大O表示“同阶”，同等数量级<br>多项相加，只保留最高阶项；多项相乘都保留</p><h5 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h5><p>空间开销(内存开销)与问题规模n的关系<br>$O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br><strong>普通程序</strong><br>内存装入程序代码和数据，一般程序代码与问题规模无关，而数据格式：<br>单一变量 $O(1)$<br>一维数组 $O(n)$<br>k维数组  $O(n^k)$<br><strong>递归程序：空间复杂度&#x3D;递归调用的深度×数据格式</strong></p><h5 id="master公式"><a href="#master公式" class="headerlink" title="master公式"></a>master公式</h5><p>递归函数可表示成$T(N) &#x3D; a * T(N&#x2F;b) + O(N^d)$<br>$log_ba &gt; d时，时间复杂度为O(N^{log_ba})$<br>$log_ba &lt; d时，时间复杂度为O(N^d)$<br>$log_ba &#x3D; d时，时间复杂度为O(N^d * log_2N)$</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百囚徒问题</title>
      <link href="/post/5a05dd41.html"/>
      <url>/post/5a05dd41.html</url>
      
        <content type="html"><![CDATA[<p>这两天偶然刷到了一个油管博主讲解百囚徒问题，感觉非常有意思，思路非常好，所以决定记录下来。<br>本文内容来自Eugene Curtin，Max Warshauer. The locker puzzle，The Mathematical Intelligencer（2006）：28-31<br>参考知乎 凉拌苦瓜 博主的文章：<a href="https://zhuanlan.zhihu.com/p/410614948">https://zhuanlan.zhihu.com/p/410614948</a></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在某个法制不健全的国家， 监狱中有编号1到100的100名死刑犯。监狱长给了他们最后一次机会：</p><p>一个房间里有100个抽屉，监狱长随意地把1到100这100个号码放入1号到100号抽屉中，每个抽屉一张。囚犯们逐个进入房间，每人可以任意打开50个抽屉，之后关上。如果每名囚犯都在这50个抽屉中发现了他的号码，那么所有的犯人都会被赦免；如果有人没有找到他的号码，那么所有的囚犯都会被处死。在第一个囚犯进入房间之前，囚犯们允许一起讨论开抽屉的“策略”，但一旦第一个囚犯进入房间，他们之间就被禁止交流。</p><h4 id="寻找思路"><a href="#寻找思路" class="headerlink" title="寻找思路"></a>寻找思路</h4><p>如果<strong>纯粹随机</strong>开抽屉，那么所有人都被赦免的概率只有：<br>$(\frac{1}{2})^{100}\approx0.000000000000000000000000000000008$<br>这个概率相当于两个人在地球上找到同一粒沙子的概率，根本不可能</p><p>寻找线索，以原文为框架，尽量给出了一个正向寻找最佳策略的思路。但要注意最佳策略未必本来就是一个被正向找到的过程。<br>为了简化问题，我们先把囚徒成员数简化为10个，每个成员可以检查5个抽屉，这时随机策略的成功概率也只有$(\frac{1}{2})^{10}&#x3D;(\frac{1}{1024})$了。</p><p>提高成功概率的一个思路是给每个人分配固定的5个抽屉去检查，我们可以先来验证一下这个猜测。假设我们制定的策略1为：1-5号成员检查1-5号抽屉，6-10号成员检查6-10号抽屉。那么他们成功的概率等于1-5号码牌刚好被分配到了1-5号抽屉中，概率为：<br>$(\frac{5}{10})(\frac{4}{9})(\frac{3}{8})(\frac{2}{7})(\frac{1}{6})&#x3D;(\frac{1}{242})$</p><p>该策略成功的概率比随机策略提高了，但成功的概率仍然比较小。值得注意的是，prisoner1如果在该策略中找到了自己的号码，则prisoner6找到自己号码的概率为5&#x2F;9，prisoner2找到自己号码的概率为4&#x2F;9，即prisoner1是否成功与其他成员是否成功具有相关性。</p><p>那么我们猜想，在策略中提高不同成员检查结果的相关性可能会提高团队的成功概率。理想的策略是如果prisoner1成功，那么其他所有成员也会成功，这时团队成功的概率为1&#x2F;2，当然很难实现（实际上无法实现），但我们可以找到一个使prisoner1与一部分成员成功的概率相同的策略，并验证在该策略下团队成功的概率。</p><h4 id="完美策略方案-单向循环链表的运用"><a href="#完美策略方案-单向循环链表的运用" class="headerlink" title="完美策略方案 单向循环链表的运用"></a>完美策略方案 单向循环链表的运用</h4><p>每个囚徒的策略，就是首先打开与自己编号相同的抽屉，从中取出号码牌，并打开号码牌所对应的抽屉。之后，重复此过程，直到找到自己的号码牌，或者50个抽屉的机会用完。 <strong>实际就是看抽屉是否存在大于51个元素的链表，如果都小于50，那么所有囚徒一定都可以存活。</strong><br><img src="/img/loop1.png" alt="loop"><br>例如，29号囚徒首先打开了29号抽屉，里面放着51号的号码牌，于是他打开51号抽屉，里面放着18号的号码牌，于是他打开18号的抽屉，里面放着29号的号码牌，他完成了任务。</p><h5 id="计算概率"><a href="#计算概率" class="headerlink" title="计算概率"></a>计算概率</h5><p>比起计算“所有循环链表的长度不超过50”的概率，“有一个循环链表长度超过50”的概率更容易计算。因为“有一个循环链表的长度是51”和“有一个循环链表的长度是52”之类的事件是彼此互斥的（循环链表的长度总和是100，所以如果有大于50的链表，也只会存在一个），所以总概率就是它们的和。而对于$m&gt;&#x3D;51$，只需先选出$m$个元素，将它们构成一个环，之后再将剩下的元素随机打乱即可唯一地得到一种分布。</p><p>具体地说，所有形成长度为m环的映射种类为：<br>$C^m_{100}(m-1)!(100-m)!&#x3D;100!&#x2F;m$</p><p>全排列个数为$100!$  </p><p>因此这个概率等于$P(m)&#x3D;1&#x2F;m$ </p><p>综上，所有圆环长度不超过50的概率等于<br>$P&#x3D;1-\sum_{m&#x3D;51}^{100}\frac{1}{m}\approx0.312$</p><p>这个概率就是囚徒被释放的概率。当囚徒人数趋于无穷大时，概率趋向于：<br>$P&#x3D;1-\sum_{m&#x3D;N+1}^{2N}\frac{1}{m}\rightarrow1-ln2$  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不那么严密地说，这个策略的关键点在于让所有囚徒尽可能地一起成功或者一起失败，因此所有玩家的任务不再是独立的，一旦有一个人成功，他所翻出的号码牌对应的人也一定会成功，同时只要有一半的人成功，剩下的人都一定成功。</p><p>通过计算可得，在之前所有人都成功的条件下，下一个人成功的概率依次为<br>50%,75.25%,89.26%,95.63%,…..</p><p>这个策略被证明最优。</p><h5 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h5><p>我觉得这个问题精彩在于对于概率本质的理解，收获很多，也再一次感受到了数学的魅力。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex基础知识</title>
      <link href="/post/3acd2553.html"/>
      <url>/post/3acd2553.html</url>
      
        <content type="html"><![CDATA[<h4 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h4><p>官方介绍：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>总结：<strong>vuex是一个集中式管理组件依赖的共享数据的工具，可以解决不同组件数据共享问题。</strong></p><h4 id="vue的引入"><a href="#vue的引入" class="headerlink" title="vue的引入"></a>vue的引入</h4><p>可以在使用脚手架手动创建项目的时候就选中vuex，会自动引入。或者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save    //安装</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入vuex</span><br><span class="line">import Vuex from &#x27;vuex&#x27; </span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//注册vuex</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数 </span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><h4 id="vuex核心模块"><a href="#vuex核心模块" class="headerlink" title="vuex核心模块"></a>vuex核心模块</h4><p>vuex核心: state，mutations，actions，getters，modules<br><img src="/img/vuex.png" alt="vuex"></p><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><p><strong>state是放置所有公共状态的属性，如果你有一个公共状态数据，你只需要定义在 state对象中。下面就是定义了一个存储数字的count。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    // 管理数据</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们怎样在其他组件使用state里面的值呢？<br>主要是两种方式：<br>1.原始形式<br>组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 通过this.$store.state.count使用 --&gt;</span><br><span class="line">&lt;!-- 使用插值表达式获取，省略this --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数 mapState<br>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapState&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">//利用展开运算符将导出的状态映射给计算属性</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接当作计算属性使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用插值表达式获取 --&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我们怎么修改count的值呢？</p><h5 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h5><p><strong>使用mutations修改state里面的数据。state数据的修改只能通过mutations，并且一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">//定义一个让count增加的方法，每次增加多少要传递参数</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">//定义一个让count减少的方法，每次减少多少要传递参数，以对象的形式传递。</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>mutations里面存放修改state数据的方法。方法的第一个参数是store里面的state属性。我们可以在state上面找到我们存放的数据；方法的第二个参数是payload（参数名字也可以自己重命名），载荷，调用mutaiions的时候，可以传递参数，任何形式的参数都可以。官方推荐大多数情况下payload应该是一个对象，因为包含多个字段时使用对象形式更清晰已读。</strong></p><p>然后我们在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.commit(&#x27;add&#x27;,2)&quot;&gt;点击每次count增加2&lt;/div&gt;</span><br><span class="line">&lt;div @click=&quot;$store.commit(&#x27;sub&#x27;,&#123;num:1&#125;)&quot;&gt;点击每次count减少1。参数以对象形式传递&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数  mapMutations<br>和mapState很像，把位于mutations中的方法提取了出来，我们可以将它导入。mapMutations将组件中的 methods 映射为 store.commit调用。用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState, mapMutations&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">//然后当作普通方法使用</span><br><span class="line">    ...mapMutations([&#x27;add&#x27;, &#x27;sub&#x27;])</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([&#x27;count&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例如</span><br><span class="line"> &lt;div @click=&quot;add(2)&quot;&gt;+&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h5><p><strong>state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作。比如异步请求数据和定时器等操作。官方介绍：Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。所以我们在addAsync 中使用context.commit(‘add’, num)使用了mutations的add方法。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改state的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">//一秒后增加count的值</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;$store.dispatch(&#x27;addAsync&#x27;,2)&quot;&gt;点击后等待一秒再增加2&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数  mapActions</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions&#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    //当作普通方法调用就好</span><br><span class="line">    ...mapActions([&#x27;addAsync&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h5><p><strong>有时我们还需要从state中派生出一些状态，这些状态是依赖state的，然后我们就会用到getters</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  // 实例化vuex的构造参数</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  // 通过mutation操作state里面的值,同步操作</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state, num) &#123;</span><br><span class="line">      state.count += num</span><br><span class="line">    &#125;,</span><br><span class="line">    sub (state, payload) &#123;</span><br><span class="line">      state.count -= payload.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 异步操作，通过mutations间接更改statement的值</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAsync (context, num) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        context.commit(&#x27;add&#x27;, num)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  getters: &#123;</span><br><span class="line">    handeleCount: (state) =&gt; &#123;</span><br><span class="line">      return `$&#123;state.count&#125;只小鸡`</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在其他组件中使用：<br>1.原始形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;$store.getters.handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>2.辅助函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">   //然后当作计算属性使用即可</span><br><span class="line">    ...mapGetters([&#x27;handeleCount&#x27;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//例如</span><br><span class="line">&lt;div&gt;&#123;&#123;handeleCount&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>1.state定义数据，使用$store.state获取<br>2.mutations修改数据，同步操作，使用$store.commit提交修改。<br>3.actions主要用于异步操作，通过mutations间接修改state数据，使用$store.dispatch提交修改。<br>4.getters主要用于派生依赖state的数据，使用$store.getters获取</strong><br>此文章介绍的是vuex最基础的使用，更多用法和更详细的介绍指路官网：<a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次型</title>
      <link href="/post/33cf95bf.html"/>
      <url>/post/33cf95bf.html</url>
      
        <content type="html"><![CDATA[<h4 id="二次型基本概念"><a href="#二次型基本概念" class="headerlink" title="二次型基本概念"></a>二次型基本概念</h4><p>对于二次齐多项式:<br>$f(x1,x2,x3,…,xn)&#x3D;a_{11}x_1^2+2a_{12}x_1x_3+…+2a_{1n}x_1x_n+…+…+a_{nn}x_n^2$<br>可以写成矩阵形式：<br>$\left[\begin{array}{c}x_1&amp;x_2&amp;…x_n\end{array}\right]<br>\left[\begin{array}{cc}a_{11}&amp;a_{12}&amp;…a_{1n} \\<br>a_{21}&amp;a_{22}&amp;…a_{2n}  \\<br>a_{n1}&amp;a_{n2}&amp;…a_{nn}\end{array}\right]<br>\left[\begin{array}{}x_1  \\<br>x_2  \\<br>…  \\<br>x_n\end{array}\right]&#x3D;x^TAx$</p><h4 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h4><p>标准型与规范型<br>标准型：没有混合项   规范型：平方项系数只有1，-1, 0<br>若存在可逆矩阵C使得C^TAC&#x3D;B,则称A与B合同<br>二次型化为标准型后得到的$\Lambda$与A合同并且其对角线的值是A的特征值</p><h4 id="变换二次型为标准型的方法"><a href="#变换二次型为标准型的方法" class="headerlink" title="变换二次型为标准型的方法"></a>变换二次型为标准型的方法</h4><p>配方法与正交法</p><h5 id="正交法"><a href="#正交法" class="headerlink" title="正交法"></a>正交法</h5><ol><li>写出二次型矩阵A</li><li>求出A的特征值</li><li>求出对应特征向量</li><li>将特征向量正交化，组合到一起即可得到正交矩阵Q $x&#x3D;Qy$</li></ol><h4 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h4><p>3个重要的充要条件：</p><ol><li>正惯性指数$p&#x3D;n$</li><li>特征值都大于0</li><li>全部顺序主子式大于</li></ol><p>必要条件：A的行列式|A|&gt;0,所有主对角线元素大于0</p><hr><p>考研复习的进度有点慢，自己要抓紧了<br>实习生活还挺舒服的，之前学的前端开发知识有了用武之地<br>千里之行始于这一篇blog，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 基础数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建站感想</title>
      <link href="/post/134cee24.html"/>
      <url>/post/134cee24.html</url>
      
        <content type="html"><![CDATA[<hr><p>blog正式成型是2022年6月28号，正值繁忙的小学期，也离考研仅5个月了，希望自己能够越来越好吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">better than better</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> chat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笑着活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
